# Android开发学习

## UI界面

### 控件

#### TextView

常用属性：

1. android:layout_width：组件的宽度
2. android:layout_height：组件的高度
3. android:id：为TextView设置一个组件id，可通过java代码的类访问
4. android:text：设置显示文本的内容
5. android:textColor：设置字体颜色
6. android:textStyle：设置字体风格，默认normal(无效果)、bold(加粗)、italic(斜体)
7. android:textSize：字体大小，单位一般是sp
8. android:background：TextView控件的背景颜色，可以理解为填充整个控件的颜色，也可以是图片
9. android:gravity：设置控件中内容的对齐方向，TextView中是文字，imageView是图片

带阴影的TextView：

1. android:shadowColor：设置阴影颜色，需要与shadowRadius一起使用
2. android:shadowRadius：设置阴影的模糊程度，设为0.1是字体颜色，建议用3.0
3. android:shadowDx：设置阴影在水平方向的偏移，就是水平方向阴影开始的横坐标位置
4. android:shadowDy：设置阴影在竖直方向的偏移，就是竖直方向阴影开始的纵坐标位置

跑马灯效果的TextView：

1. android:singleLine：设置内容单行显示
2. android:focusable：是否可以获取焦点，true or false
3. android:focusableInTouchMode：用于控制视图在触摸模式下是否可以聚焦
4. android:ellipsize：在哪里省略文本
5. android:marqueeRepeatLimit：字幕动画重复的次数

#### Button

StateListDrawable是Drawable资源的一种，可以根据不同的状态，设置不同的图片效果，关键节点<selector>，我们只需要将Button的background属性设置为该drawable资源即可轻松实现，按下按钮时不同的按钮颜色或背景

1. android:drawable：引用的Drawable位图
2. android:state_focused：是否获得焦点
3. android:state_pressed：控件是否被按下
4. android:state_enabled：控件是否可用
5. android:state_selected：控件是否被选择，针对有滚轮的状况
6. android:state_checked：控件是否被勾选
7. android:state_checkable：控件可否被勾选，如checkbox
8. android:state_window_focused：是否获得窗口焦点
9. android:state_active：控件是否处于活动状态，如slidingTab
10. android:state_single：控件包含多个子控件时，确定是否只显示一个子控件
11. android:state_first：控件包含多个子控件时，确定第一个子控件是否处于显示状态
12. android:state_middle：控件包含多个子控件时，确定中间一个子控件是否处于显示状态
13. android:state_last：控件包含多个子控件时，确定最后一个子控件是否处于显示状态

#### EditText

1. android:hint：输入提示
2. android:textColorHint：输入提示文字的颜色
3. android:inputType：输入类型，如phone、password
4. android:drawableXxxx：在输入框的指定方位添加图片，Xxxx指Left\Rgiht.....
5. android:drawablePadding：设置图片与输入内容的间距
6. android:paddingXxxx：设置内容与边框的间距
7. android:background：背景色

#### ImageView

1. android:src：设置图片资源
2. android:scaleType：设置图片缩放类型
   * fitCenter：默认值，保持宽高比缩放图片，直到较长边与image的边长相等，缩放完成后将图片放在ImageView的中间
   * fitStart：同上，缩放后放于左上角
   * fitEnd：同上，缩放后放于右下角
   * fixXY：对图像的横纵方向进行独立缩放，使得该土拍你完全适应imageView，但是图片的宽高比可能会发生改变，等同拉伸
   * center：保持原图的大小，显示在ImageView的中心，当原图的size大于ImageView的size，超过部分裁剪处理
   * centerCrop：保持宽高比例缩放图片，直到完全覆盖ImageView，可能会出现图片的显示不完全，
   * centerInside：保持宽高比例缩放图片，直到ImageView能够完全地显示图片
   * matrix：不改变原图的大小，从ImageView的左上角开始绘制原图，原图超过ImageView的部分作剪裁处理
3. android:maxHeight：最大高度
4. android:maxWidth：最大宽度
5. android:adjustViewBounds：调整view的界限

#### ProgressBar

1. android:max：进度条的最大值，用于水平进度条的最大值
2. android:progress：进度条已完成进度值
3. android:indeterminate：如果设置完成true，则进度条不精确显示进度
4. android:style="?android:attr/progressBarStyleHorizontal"：设置水平进度条

#### Notification

实现Notification控件需要创建两个类，分别是Notification和NotificationManager

1. 创建NotificationManager

   NotificationManager类是一个通知管理器类，这个对象是由系统维护的服务，是以单例模式获得，所以一般并不直接实例化这个对象，在Activity中，可以使用Activity.getSystemService(String)方法获取NotificationManager对象，Activity.getSystemService(String)方法可以通过Android系统级服务的句柄，返回对应的对象，在这里需要返回NotificationManger，所以直接传递Context.NOTIFICATION_SERVICE即可。

2. 使用Builder构造器来创建Notification对象

   使用NotificationCompat类的Builder构造器来创建Notification对象，可以保证程序在所有的版本上都能正常工作，Android8.0新增了通知渠道这一概念，如果没有设置，则通知无法在Android8.0的机器上显示。

#### ToolBar

将ActionBar替换成ToolBar，可以自我修改一些内容，常用的一些属性如下：

1. android:layout_width="match_parent"
2. android:layout_height="?attr/actionBarSize"
3. android:background="#ffff00"
4. app:navigation="@drawable/ic_baseline_arrow_back_24"
5. app:title="主标题"
6. app:titleMarginStart="90dp"
7. app:subtitle="子标题"
8. app:subtitleTextColor="#00ffff"
9. app:logo="@mipmap/ic_launcher"

#### AlertDialog

弹出对话框，具有以下基本属性：

1. Alert.dialog.Builder buider = new AlertDialog.Builder(context)：构建Dialog的各种参数
2. Builder.setIcon(int iconId)：添加ICON
3. Builder.setTitle(CharSequence title)：添加标题
4. Builder.setMessage(CharSequence message)：添加消息
5. Builder.setView(View view)：设置自定义布局
6. Builder.create()：创建Dialog
7. Builder.show()：显示对话框
8. setPositiveButton：确定按钮，配合ClickListener
9. setNegativeButton：取消按钮，配合ClickListener
10. setNeutralButton：中间按钮

#### PopupWindow

弹窗功能，具有以下基本属性：

1. setContentView(View contentView)：设置PopupWindow显示的View
2. showAsDropDown(View anchor)：相对某个控件的位置(正左下方)，无偏移
3. showAsDropDown(View anchor,int xoff,int yoff)：相对某个控件的位置，有偏移
4. setBackgroundDrawable(Drawable background)：设置背景
5. dismiss()：关闭弹窗
6. setAnimationStyle(int animationStyle)：设置加载动画
7. setTouchable(boolean touchable)：设置触摸使能
8. setOutsideTouchable(boolean touchable)：设置PopupWindow外面的触摸使能

#### ListView

ListView的作用是展示很多数据，但其只承担交互和展示工作，至于数据来源，ListView是并不担心的，所以ListView的基本工作模式就是要有一个ListView控件和一个数据源。而直接让ListView和数据源打交道的话，ListView的适配工作就非常繁杂，于是就产生了适配器(Adapter)机制，它在ListView和数据源之间起到了一个桥梁的作用，ListView并不会直接和数据源打交道，而是会借助Adapter这个桥梁去访问真正的数据源，与之前不同的是，Adapter的接口都是统一的，因此ListView不用再担心任何适配方面的问题。具体如下图：

![img](https://img-blog.csdn.net/20150719202924532?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

#### RecyclerView

RecyclerView可以说是一个增强版的ListView，不仅可以轻松实现和ListView同样的效果，还优化了ListView存在的各种不足，其扩展性要比ListView更好一些

#### ViewPager

视图翻页工具，提供了多页面切换的效果，通过adapter给它填充多个view，左右滑动时，切换不同的view

PagerAdapter的方法如下：

1. getCount()：获得ViewPager中有多少个view
2. instantiateItem()：
   * 将给定位置的view添加的ViewGroup(容器)中，创建并显示出来
   * 返回一个代表新增页面的Object(key)，通常都是直接返回view本身就可以了，当然你也可以自定义自己的key，但是key和每个view都要一一对应的关系
3. isViewFromObject()：判断instantiateItem(ViewGroup,int)函数所返回来的Key与一个页面视图是否是代表的同一个视图(即它俩是否是对应的，对应的表示同一个View)，通常我们直接写return view == object
4. destroyItem()：移除一个给定位置的页面，适配器有责任从容器中删除这个视图，这是为了确保在finishUpdate(viewGroup)返回时视图能够被移除

#### Animation

1. 逐帧动画

逐帧动画(frame-by-frame animation)，逐帧显示动画，可设置Duration，动画的启停，重要的属性：

Animation-list

- AnimaitonDrawable anim = (AnimationDrawable) relativeLayout.getBackground();//获取动画的Drawable资源
- anim.start();//启动动画
- anim.end();//停止动画

2. 补间动画

补间动画(tweened animation)，对一个图片资源进行动画效果操作，重要属性：

Animation animation = AnimationUtils.loadAnimation(MainActivity.this, R.anim.xxxx)，xxxx如下：

- alpha，透明度
- rotate，旋转
- scale，缩放
- translate，平移

imageView.startAnimation(animation);

3. 属性动画

属性动画(property animation)，通过动画的方式改变对象的属性，重要属性：

使用objectAnimator实现

- Duration：动画的持续时间，默认300ms；
- Time interpolation：时间差值，动画的变化率
- Repeat count and behavior：重复次数、重复模式、可以定义重复多少次，重复时从头开始，还是反向
- Animator sets：动画集合，你可以定义一组动画，一起执行或者顺序执行
- Frame refresh delay：帧刷新延迟，对于动画，多久刷新一次帧，默认为10ms

### 布局

#### 线性布局(LinearLayout)

线性布局(LinearLayout)，将其所包含的控件在线性方向上依次排列，最常用属性：

1. android:id，标识，通过id找到布局控件
2. android:layout_width，布局宽度
3. android:layout_height，布局高度
4. android:background，背景，可以设置颜色、图片或者xml文件
5. android:layout_margin，布局外边距
6. android:layout_padding，布局内边距
7. android:orientation，方向，横竖的方向，vertical、horizontal
8. android:layout_gravity，对齐效果，top、bottom、center_vertical

#### 相对布局(RelativeLayout)

相对布局(RelativeLayout)，通过相对定位的方式让控件出现在布局的任何位置，最常用属性：

1. 根据父容器定位：
   * layout_alignParentLeft：左对齐
   * layout_alignParentRight：右对齐
   * layout_alignParentTop：顶部对齐
   * layout_alignParentBottom：底部对齐
   * layout_centerHorizontal：水平居中
   * layout_centerVertical：竖直居中
   * layout_centerInParent：中间位置
2. 根据兄弟组件定位：
   * layout_toLeftOf：放置于参考组件的左边
   * layout_toRightOf：放置于参考组件的右边
   * layout_above：放置于参考组件的上方
   * layout_below：放置于参考组件的下方
   * layout_alignTop：对齐参考组件的上边界
   * layout_alignBottom：对齐参考组件的下边界
   * layout_alignLeft：对齐参考组件的左边界
   * layout_alignRight：对齐参考组件的右边界

3. 设置组件与父容器的边距：
   * layout_margin：上下左右偏移
     * layout_marginLeft
     * layout_marginRight
     * layout_marginTop
     * layout_marginBottom
4. 设置组件内部元素的边距：
   * padding

#### 帧布局(FrameLayout)

帧布局(FrameLayout)，没有丰富的定位方式，所有的控件都会默认摆放在布局的左上角，最常用属性：

1. foreground：设置前景

2. foregroundGravity：设置前景位置

#### 表格布局(TableLayout)

帧布局(FrameLayout)，需要和TableRow配合使用，每一行都由TableRow对象组成，因此TableRow的数量决定表格的行数，而表格的列数是由包含多个控件的TableRow决定的，最常用属性：

1. collapseColumns：设置需要被隐藏的列序号，从0开始
2. stretchColumns：设置允许被拉伸的列序号，从0开始
3. shrinkColumns：设置允许被收缩的列序号，从0开始

子控件设置属性：

1. layout_column：显示在第几列
2. layout_span：横向跨几列

#### 网格布局(GridLayout)

网格布局(GridLayout)，可以减少布局嵌套，最常用属性：

1. orientation：设置水平还是垂直显示
2. columnCount：设置行的显示个数
3. rowCount：设置列的显示个数

子控件属性：

1. layout_column：显示在第几列
2. layout_columnSpan：横向跨几列
3. layout_columnWeight：横向剩余空间分配方式
4. layout_row：显示在第几行
5. layout_rowSpan：纵向跨几行
6. layout_rowWeight：纵向剩余空间分配方式
7. layout_gravity：在网格中的显示位置

#### 约束布局(ConstraintLayout)

约束布局(ConstraintLayout)，主要是解决布局嵌套过多的问题，以灵活的方式定位和调整小部件，采用可视化操作内部控件的相对布局

### 控件与布局的关系

布局是一种可用于放置很多控件的容器，它可以按照一定的规律调整内部控件的位置，从而编写出精美的界面，布局的内部除了放置控件外，也可以放置布局，通过多层布局的嵌套，能够实现一些比较复杂的界面实现：

![img](https://upload-images.jianshu.io/upload_images/1306890-a329e94168459de2.png?imageMogr2/auto-orient/strip%7CimageView2/2)

### 单位和尺寸

1. px：pixels，像素，不同设备显示效果相同
2. pt：point，是一个标准的长度单位，1pt=1/72英寸，用于印刷业，非常简单易用
3. dip：device independent pixels(设备独立像素)，不同设备有不同的显示效果，这个和设备硬件有关，一般我们为了支持WVGA、HVGA和QVGA推荐使用这个，不依赖像素
4. dp：就是dip
5. sp：scaled pixels，放大像素，主要用于字体显示best for textsize
6. LayoutParams：相当于一个Layout的信息包，封装了Layout的位置、高、宽等信息

### Fragment

#### Fragment是什么？

Fragment可以让界面在平板和手机上更好地展示，可以兼顾手机和平板的开发。Fragment是一种可以嵌入在Activity当中的UI片段，能让程序更加合理和充分地利用大屏幕的空间，因而在平板上应用得非常广泛，Fragment和Activity实在是太像了，同样都能包含布局，同样都有自己的生命周期，可以将Fragment理解成一个迷你型的活动。

#### Fragment的使用方式

1. 定义Fragment的布局

新建一个左侧Fragment的布局left_fragment.xml，再新建一个右侧right_fragment.xml，代码如下

```xml
//left_fragment.xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <Button
        android:id="@+id/button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        android:text="Button"
        />

</LinearLayout>
//right_fragment.xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:background="#00ff00"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        android:textSize="24sp"
        android:text="This is right fragment"
        />

</LinearLayout>
```

2. 创建Fragment

编写LeftFragment和RightFragment中的代码，代码如下

```java
//left_fragment
pulibc class LeftFragment extends Fragment{
  @Override
  public View onCreateView(LayoutInflater inflator, ViewGroup container,Bundle savedInstanceState){
    View view = inflater.inflate(R.layout.left_fragment,container,false);
    return view;
  }
}
//right_fragment
```

3. 在布局中引入Fragment

修改activity_main.xml，在布局中引入Fragment，代码如下

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent" >

    <fragment
        android:id="@+id/leftFrag"
        android:name="com.example.fragmenttest.LeftFragment"
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:layout_weight="1" />

    <fragment
        android:id="@+id/rightFrag"
        android:name="com.example.fragmenttest.RightFragment"
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:layout_weight="1" />

</LinearLayout>
```

#### 动态添加Fragment

1. 动态添加Fragment步骤：

- 创建待添加Fragment的实例。
- 获取FragmentManager，在Activity中可以直接调用getSupportFragmentManager()方法获取。
- 开启一个事务，通过调用beginTransaction()方法开启。
- 向容器内添加或替换Fragment，一般使用replace()方法实现，需要传入容器的id和待添加的Fragment实例。
- 提交事务，调用commit()方法来完成。

2. 动态添加Fragment代码：

- 准备一个布局作为动态添加Fragment的窗口

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="match_parent" >

    <fragment
        android:id="@+id/leftFrag"
        android:name="com.example.fragmenttest.LeftFragment"
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:layout_weight="1" />

    <FrameLayout
        android:id="@+id/rightLayout"
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:layout_weight="1" >
    </FrameLayout>

</LinearLayout>
```

- 在Activity代码中向FrameLayout里添加内容，实现动态添加Fragment的功能

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener{
  @Override 
  protected void onCreate(Bundle savedInstanceState){
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    Button button = (Button) findViewById(R.id.button);
    button.setOnClickListener(this);
    replaceFragment(new RightFragment());
  }
  @Override
  public void onClick(View v){
    switch(v.getID()){
      case R.id.button:
        replaceFragment(new AnotherRightFragment());
        break;
      default:
        break;
    }
  }
    private void replaceFragment(Fragment fragment) {
        FragmentManager fragmentManager = getSupportFragmentManager();
        FragmentTranscation transaction = fragmentManager.beginTransaction();
        transaction.replace(R.id.rightLayout, fragment);
        transaction.commit();
    }
}
```

#### Fragment和Activity之间进行通信

虽然Fragment都是嵌入在活动中显示的，可是实际上它们的关系并没有那么亲密，它们都各自存在于一个独立的类当中，为了方便Fragment和Activity之间进行通信，FragmentMananger提供了一个类似于findViewById()方法，专门用于从布局文件中获取Fragment的实例，代码如下

```java
RightFragmetn rightFragment = (RightFragment) getFragmentManager().findFragmentById(R.id.right_fragment);
```

在每个Fragment都可以通过调用getActivity()方法来得到和当前Fragment相关联的Activity实例，代码如下

```java
MainActivity activity = (MainActivity) getActivity();
```

#### Fragment的生命周期

1. Fragment拥有自己的生命周期，与Activity很相似，Fragment在生命周期能经历：

![图片](https://www.runoob.com/wp-content/uploads/2015/06/fragment.jpg)

- 运行状态

  当一个Fragment是可见的，并且它所关联的Activity正处于运行状态，该Fragment也处于运行状态。

- 暂停状态

  当一个Activity进入暂停状态时，与它相关联的可见Fragment就会进入到暂停状态。

- 停止状态

  当一个Activity进入停止状态时，与它相关联的Fragment就会进入到停止状态，或者通过调用FragmentTransaction的remove()、replace()方法将Fragment从Activity中移除，但如果在事务提交之前调用addToBackStack()方法，这时的Fragment也会进入到停止状态，总的来说，进入停止状态的Fragment对用户来说是完全不可见的，可能被系统回收。

- 销毁状态

  Fragment总是依附于Activity存在的，因此当Activity被销毁时，和它相关联的Fragment就会进入到销毁状态，或者通过调用FragmentTransaction的remove()、replace()方法将Fragment从Activity中移除，但在事务提交之前并没有调用addToBackStack()方法，这时的Fragment也会进入到销毁状态。

2. Fragment的回调方法

* onAttach()：当Fragment和Activity建立关联的时候调用；
* onCreateView()：为Fragment创建视图（加载布局）时调用；
* onActivityCreated()：确保与Fragment相关联的Activity一定已经创建完毕的时候调用；
* onDestoyView()：当与Fragment关联的视图被一出的时候调用；
* onDetach()：当Fragment和Activity解除关联的时候调用。

#### 动态加载布局的技巧

手机采用单页模式，平板采用双页模式，巧用借助限定符(Qualifiers)来实现程序自动判断使用双页模式还是单页模式。

Android中一些常见的限定符可以参考下表

| 屏幕特征 | 限定符 | 描述                                        |
| -------- | ------ | ------------------------------------------- |
| 大小     | small  | 提供给小屏幕设备的资源                      |
|          | normal | 提供给中等屏幕设备的资源                    |
|          | large  | 提供给大屏幕设备的资源                      |
|          | xlarge | 提供给超大屏幕的资源                        |
| 分辨率   | ldpi   | 提供给低分辨率设备的资源(120dpi以下)        |
|          | mdpi   | 提供给中等分辨率设备的资源(120dpi~160dpi)   |
|          | hdpi   | 提供给高分辨率设备的资源(160dpi~240dpi)     |
|          | xhdpi  | 提供给超高分辨率设备的资源(240dpi~320dpi)   |
|          | xxhdpi | 提供给超超高分辨率设备的资源(320dpi~480dpi) |
| 方向     | land   | 提供给横屏设备的资源                        |
|          | port   | 提供给竖屏设备的资源                        |

### Material Design

#### Material Design概述

Material Design是谷歌在2014年发明的一套全新界面设计语言，可以解决Android平台界面风格不统一的问题，原因是当各个公司都无法设计出比Material Design更出色的界面风格，那它们自然就会使用Material Design来设计界面，从而解决Android平台界面不统一的问题。

2015年谷歌推出了Design Support库，该库将Material Design中最具代表性的一些控件和效果进行了封装，使得开发者在不了解Material Design的情况下也能非常轻松地将自己的应用Material化。

#### Toolbar

Toolbar是用来替代Actionbar的，首先需要隐藏Actionbar，指定一个不带Actionbar的主题，通常有两种：

1. Theme.AppCompat.Light.NoActionBar 浅色主题
2. Theme.AppCompat.NoActionBar 深色主题

再在Activity_main中用Toolbar来替代Actinobar，代码如下

```
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <androidx.appcompat.widget.Toolbar
        android:id="@+id/toolbar"
        android:layout_width="match_parent"
        android:layout_height="?attr/actionBarSize"
        android:background="@color/colorPrimary"
        android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"
        app:popupTheme="@style/ThemeOverlay.AppCompat.Light" />
</FrameLayout>
```

再在MainActivity中获取Toolbar实例，代码如下

```
        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
        setSupportActionBar(toolbar);
```

Toolbar比较常用的功能：

#### 滑动菜单

滑动菜单就是将一些菜单选项隐藏起来，而不是放置在主屏幕上，然后通过滑动的方式将菜单显示出来：

1. DrawerLayout

   DrawerLayout首先是一个布局，在布局中允许放入两个直接子控件，第一个子控件是主屏幕显示的内容，第二个子控件是滑动菜单中显示的内容，代码如下

   ```
   <androidx.drawerlayout.widget.DrawerLayout 
       xmlns:android="http://schemas.android.com/apk/res/android"
       xmlns:app="http://schemas.android.com/apk/res-auto"
       android:id="@+id/drawerLayout"
       android:layout_width="match_parent"
       android:layout_height="match_parent">
   
       <FrameLayout
           android:layout_width="match_parent"
           android:layout_height="match_parent">
   
           <androidx.appcompat.widget.Toolbar
               android:id="@+id/toolbar"
               android:layout_width="match_parent"
               android:layout_height="?attr/actionBarSize"
               android:background="@color/colorPrimary"
               android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"
               app:popupTheme="@style/ThemeOverlay.AppCompat.Light" />
   
       </FrameLayout>
   
       <TextView
           android:layout_width="match_parent"
           android:layout_height="match_parent"
           android:layout_gravity="start"
           android:background="#FFF"
           android:text="This is menu"
           android:textSize="30sp" />
   
   </androidx.drawerlayout.widget.DrawerLayout>
   ```

2. NavigationView

#### 悬浮按钮和可交互提示

立面设计是Material Design中一条非常重要的设计思想，应用程序的界面不仅仅是一个平面，而应该是有立体效果的，而最具代表性的立面设计就是悬浮按钮。

1. FloatingActionButton

   在activity_main.xml中加入FloatingActionButton

   ```
           <com.google.android.material.floatingactionbutton.FloatingActionButton
               android:id="@+id/fab"
               android:layout_width="wrap_content"
               android:layout_height="wrap_content"
               android:layout_gravity="bottom|end"
               android:layout_margin="16dp"
               android:src="@drawable/ic_done" />
   ```

   再在MainAcivity中实例化FloatingActionButton

   ```
           FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab);
           fab.setOnClickListener(new View.OnClickListener() {
               @Override
               public void onClick(View v) {
                 //Toast方法，无用户交互
                 Toast.makeText(MainActivity.this,"FAB clicked",Toast.LENGTH_SHORT).show();
                 //Snackbar方法，有用户交互
                   Snackbar.make(v,"Data Deleted",Snackbar.LENGTH_SHORT).setAction("Undo", new View.OnClickListener() {
                          @Override
                          public void onClick(View v) {
                          Toast.makeText(MainActivity.this,"Data restored",Toast.LENGTH_SHORT).show();
                               }
                           }).show();
               }
           });
   ```

2. CoordinatorLayout

   CoordinatorLayout可以说是一个加强版的FrameLayout，在普通情况下与FrameLayout一致，但用有一些额外的Material能力

#### 卡片式布局

Material Design提出了一个新概念，可以让页面的元素看起来就像在卡片中一样，并且还能拥有圆角和阴影。

1. MaterialCardView



1. AppBarLayout

   解决RecycleView把Toolbar遮挡的情况

#### 下拉刷新

SwipeRefreshLayout是用于下拉刷新功能的核心实现类，使用RecycleView外面嵌套一层SwipeRefreshLayout，RV就有下拉刷新功能

```
    <androidx.swiperefreshlayout.widget.SwipeRefreshLayout
        android:id="@+id/swipeRefresh"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:layout_behavior="@string/appbar_scrolling_view_behavior">

        <androidx.recyclerview.widget.RecyclerView
            android:id="@+id/recyclerView"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            app:layout_behavior="@string/appbar_scrolling_view_behavior"/>

    </androidx.swiperefreshlayout.widget.SwipeRefreshLayout>
```

在MainActivity中实现下拉刷新功能

```
        private SwipeRefreshLayout swipeRefresh;
        swipeRefresh = (SwipeRefreshLayout) findViewById(R.id.swipeRefresh);
        swipeRefresh.setColorSchemeResources(R.color.colorPrimary);
        swipeRefresh.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {
            @Override
            public void onRefresh() {
                reFreshFruits();
            }
        });
        
    }
    private void reFreshFruits(){
        new Thread(new Runnable(){
            @Override
            public void run() {
                try{
                    Thread.sleep(2000);
                }catch (InterruptedException e) {
                    e.printStackTrace();
                }
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        initFruits();
                        adapter.notifyDataSetChanged();
                        swipeRefresh.setRefreshing(false);
                    }
                });
            }
        }).start();
```

#### 可折叠式标题栏

1. CollapsingToolbarLayout

   能实现可折叠式标题栏的效果

## 主要组件

### Activity

#### Activity是什么？

Activity是一种可以包含用户界面的组件，主要用于和用户进行交互，一个程序可以包含零个或多个Activity，但不包含任何Activity的应用程序相当少见，毕竟自己的应用程序为什么永远不希望被其他人看到。

#### Activity的基本用法

1. 手动创建，No Activity Project，Create New Project -> No Activity 

2. 手动创建Activity，包名 -> New -> Activity -> Empty Activity //Generate Layout File和Launcher Activity都不勾选，后续手动设置

3. 创建布局，res -> New -> Directory -> layout, layout -> New -> Layout resource file

4. 示例：添加控件，如一个Button

5. 加载布局：重新返回创建的Activity，在onCreate()方法调用setContentView(R.layout.first_layout)，可以调用first_layout.xml

6. 所有的Activity都要在AndroidManifest.xml中注册才能生效

   Android Studio会自动帮Activity在文件中注册，设为主Activity和主Activity名称及Launcher名称

   ```xml
           <activity android:name=".FirstActivity"
               android:label="This is FirstActivity">
               <intent-filter>//设为主Activity
                   <action android:name="android.intent.action.MAIN"/> 
                   <category android:name="android.intent.category.LAUNCHER"/>
               </intent-filter>
           </activity>
   ```

7. 在Activity中使用Toast，Toast是Android系统中非常好的提醒方式，在程序中可以使用它将一些短小的信息通知给用户，这些信息会在一段时间后自动消失，并且不占用任何屏幕空间。

   在onCreate()方法中定义一个弹出Toast的触发点：

   ````java
   Button button1 = findViewById(R.id.button1);
           button1.setOnClickListener(new View.OnClickListener() {
               @Override
                       public void onClick(View v){
                   Toast.makeText(FirstActivity.this,"You Clicked Button 1", Toast.LENGTH_SHORT).show();
               }
           });
   ````

8. 在Activity中使用Menu，手机屏幕空间有限，Android给我们提供了一种右上角“三点”菜单来展示，不占用屏幕空间：

   * res -> New -> Directory -> menu 
   * New -> Menu resource file -> main.xml
   * main.xml插入：

   ```xml
       <item
           android:id="@+id/add_item"
           android:title="Add"/>
       <item
           android:id="@+id/remove_item"
           android:title="Remove"/>
   ```

   * 回到FirstAcitivity重写onCreateOptionsMenu()和onOptionsItemSelected()方法：

   ```java
       @Override
       public boolean onCreateOptionsMenu(Menu menu) {
           getMenuInflater().inflate(R.menu.main,menu);//获取MenuInflater对象，并调用inflate方法创建菜单
           return true;
       }
   
       @Override
       public boolean onOptionsItemSelected(@NonNull MenuItem item) {
           switch(item.getItemId()){
               case R.id.add_item:
                   Toast.makeText(FirstActivity.this,"You Clicked Add", Toast.LENGTH_SHORT).show();
                   break;
               case R.id.remove_item:
                   Toast.makeText(FirstActivity.this,"You Clicked Remove", Toast.LENGTH_SHORT).show();
                   break;
               default:
           }
       return true;
       }
   ```

9. 销毁一个Activity，修改监听器中的代码，效果和按下Back一致

   ```java
   button1.setOnClickListener{
   	finish();
   }
   ```

#### Activity的生命周期

1. 返回栈

   Android中的Activity是可以层叠的，我们每启动一个新的Activity，就会覆盖在原Activity之上，然后点击back键会销毁最上面的Activity，下面的一个Activity就会重新显示出来。

   Android是使用任务(Task)来管理Activity的，一个任务就是一组存放在栈里的Activity的集合，这个栈也被称作返回栈(Back Stack)，返回栈是如何管理Activity入栈出栈的：

2. Activity状态

   每个Activity在其生命周期中最多可能会有4种状态：

   * 运行状态

   当一个Activity位于返回栈的栈顶时，这时活动就处于运行状态，系统最不愿意回收这种状态的Activity。

   * 暂停状态

   当一个Activity不再处于栈顶位置，但仍然可见，这时Activity就进入了暂停状态，系统也不愿意回收这种状态的Activity，只有在内存极低的情况下，系统才会回收这种状态的Activity。

   * 停止状态

   当一个Activity不再处于栈顶位置，并且不完全可见的时候，就进入了停止状态，系统仍然会为这种活动保存相应的状态和成员变量，当其他地方需要内存时，处于停止状态的Activity有可能会被系统回收。

   * 销毁状态

   当一个Activity从返回栈中移除后就变成了销毁状态，系统会最倾向于回收这种状态的活动，从而保证手机的内存充足。

3. Activity的生命周期

   ![图片](https://www.runoob.com/wp-content/uploads/2015/05/activity.jpg)

   - onCreate()：这是在活动第一次被创建的时候调用，需要在这个方法中完成活动的初始化操作，比如加载布局、绑定事件；
   - onStart()：这个方法在活动由不可见变为可见的时候调用；
   - onResume()：这个方法在活动准备好和用户进行交互的时候调用，此时活动一定位于返回栈的栈顶，并且处于运行状态；
   - onPause()：这个方法在系统准备去启动或者恢复另一个活动的时候调用，通常会在这个方法中将一些消耗CPU的资源释放掉；
   - onStop()：这个方法在活动完全不可见时调用，它和onPause()方法的主要区别在于，如果启动的新活动是一个对话框式的活动，那么onPause()方法会得到执行，而onStop()方法并不会执行；
   - onDestroy()：这个方法在活动被系统销毁之前调用，之后活动的状态变为注销状态；
   - onRestart()：这个方法在活动由停止状态变为运行状态之前调用，也就是活动呗重新启动了。

4. Activity的生存期

   * 完整生存期：Activity在onCreate()方法和onDestroy()方法之间所经历的，就是完整生存期；
   * 可见生存期：Activity在onStart()方法和onStop()方法之间所经历的，就是可见生存期，可见生存期内，Activity对于用户总是可见的，即便有可能无法和用户进行交互；
   * 前台生存期：Activity在onResume()方法和onPause()方法之间所经历的，就是前台生存期，前台生存期内的Activity总是处于运行状态，此时的Activity是可以和用户进行交互的。

#### Activity的启动模式

Activity的启动模式一共有4种，分别是standard、singleTop、singleTask和singleInstance，可以在AndroidManifest.xml中通过<activity>标签制定android:launchMode属性来选择启动模式。具体如下：

1. standard

   standard是Activity中默认的启动模式，在不进行显式指定的情况下，所有Activity都会自动使用这种启动模式。每当启动一个新的Activity时，它就会在返回栈中入栈，并处于栈顶的位置，对于使用standard模式的Activity，系统不会在乎这个Activity是否已经在返回栈中存在，每次启动都会创建该Activity的一个新实例，然后返回也需要逐个返回。示意图如下：

2. singleTop

   当Activity的启动模式指定为singleTop，在启动Activity是如果发现返回栈的栈顶已经是该Activity，则认为可以直接使用它，不会再创建新的Activity实例。示意图如下：

3. singleTask

   当Activity的启动模式指定为singleTask，在每次启动Activity时，系统首先会在返回栈中检查是否存在该Activity的实例，如果发现已经存在则直接使用该实例，并把在这个Activity之上的所有其他Activity统统出栈，如果没有发现就会创建一个新的Activity实例。示意图如下：

4. singleInstance

   指定为singleInstance模式的Activity会启用一个新的返回栈来管理这个Activity，不管哪个应用程序来访问这个Activity，都共用一个返回栈，也就解决了共享Activity实例的问题。示意图如下：

### BroadcastReceiver

#### Broadcast机制

Broadcast类型：

1. Normal Broadcast

   一种完全异步的Broadcast，Broadcast发出后，所有Broadcast Receiver都几乎在同一时刻接受到这条Broadcast，它们之间没有任何先后顺序可说，这样做效率比较高，但是无法被截断，示意图如下

2. Ordered Broadcast

   一种同步执行的Broadcast，Broadcast发出后，同一时刻只会有一个Broadcast Receiver能够收到这条Broadcast，当这个Broadcast的逻辑执行完毕后，Broadcast才会继续传递，此时的Broadcast Receiver是有先后顺序的，优先级高的Broadcast Receiver就可以先收到Broadcast，这样可以将Broadcast截断，示意图如下

#### 接收系统Broadcast



### ContentProvider

#### Content Provider简介

Content Provider主要用于在不同的应用程序之间实现数据共享的功能，它提供了一套完整的机制，允许一个程序访问另一个程序，同时还能保证被访数据的安全性。

#### Android运行权限

Android 6.0系统后加入了运行时权限功能，用户不需要在安装软件的时候一次性授权所有申请的权限，而是可以在软件的使用过程中再对某一项权限进行授权。当然不是所有权限都需要在运行时申请，用户不停地授权也很繁琐，Android现在将所有的权限归成了两类，一类是普通权限，另一类是危险权限。

1. 普通权限指的是那些不直接威胁到用户的安全和隐私权限，系统会自动帮我们进行授权，而不需要用户再去手动操作。
2. 危险权限指的是那些可能会触及用户隐私，或者对设备安全性造成影响的权限，这部分权限申请必须由用户手动点击授权才可以。

#### 在程序运行时申请权限



#### 访问其他程序中的数据



### Service

#### Service是什么

Service是Android中实现程序后台运行的解决方案，它非常适合执行那些不需要和用户交互而且还要求长期运行的任务，Service的运行不依赖于任何用户界面，即使程序被切换到后台，或者用户打开了另外一个程序，Service仍然能够保持正常运行。

Service并不是运行在一个独立的进程中，而是依赖于创建Service时所在的应用程序进程，当某个应用程序进程被杀掉时，所有依赖于该进程的Service也会停止运行。

不要被Service的后台概念所迷惑，实际上Service并不会自动开启线程，所有的代码都默认运行在主线程中，需要在Service的内部手动创建子线程。

#### Android多线程编程



#### Service基本用法

1. 定义一个Service

   新建ServiceTest项目，New -> Service -> Service，勾选Exported和Enabled，onBind()方法是Service中唯一的一个抽象方法，必须要在子类里实现，需要重写onCreate()、onStartCommand()、onDestroy()方法。

   ```java
       @Override
       public void onDestroy() {//Service销毁的时候调用
           super.onDestroy();
       }
   
       @Override
       public int onStartCommand(Intent intent, int flags, int startId) {//每次Service启动的时候调用
           return super.onStartCommand(intent, flags, startId);
       }
   
       @Override
       public void onCreate() {//Service创建的时候调用
           super.onCreate();
       }
   ```

2. 启动和停止Service

   启动和停止Service的方法主要借助于Intent来实现，增加start和stop service的button来实现

   ```xml
       <Button
           android:id="@+id/start_service"
           android:layout_width="match_parent"
           android:layout_height="wrap_content"
           android:text="Start Service"/>
       <Button
           android:id="@+id/stop_service"
           android:layout_width="match_parent"
           android:layout_height="wrap_content"
           android:text="Stop Service"/>
   ```

   修改Activity代码，分别用于启动和停止Service

   ```java
   public class MainActivity extends AppCompatActivity implements View.OnClickListener{
   
       @Override
       protected void onCreate(Bundle savedInstanceState) {
           super.onCreate(savedInstanceState);
           setContentView(R.layout.activity_main);
           Button startService = (Button) findViewById(R.id.start_service);
           Button stopService = (Button) findViewById(R.id.stop_service);
           startService.setOnClickListener(this);
           stopService.setOnClickListener(this);
       }
   
       @Override
       public void onClick(View v) {
           switch (v.getId()){
               case R.id.start_service:
                   Intent startIntent = new Intent(this,MyService.class);
                   startService(startIntent);
                   break;
               case R.id.stop_service:
                   Intent stopIntent = new Intent(this,MyService.class);
                   stopService(stopIntent);
                   break;
               default:
                   break;
           }
       }
   }
   ```

   启动Service会调用onCreate()和onStartCommand()方法，onCreate()方法是在Service第一次创建的时候调用的，而onStartCommand()方法则在每次启动Service的时候调用；

   停止Service会调用onDestroy()方法。

3. Activity和Service进行通信

   使用onBind()方法来进行通信，创建一个专门的Binder对象来对下载功能进行管理，修改代码如下

   ```xml
       <Button
           android:id="@+id/bind_service"
           android:layout_width="match_parent"
           android:layout_height="wrap_content"
           android:text="Bind Service"/>
   
       <Button
           android:id="@+id/unbind_service"
           android:layout_width="match_parent"
           android:layout_height="wrap_content"
           android:text="Unbind Service"/>
   ```

   在Activity代码增加Binder方法

   ```java
       private MyService.DownloadBinder downloadBinder;
   
       private ServiceConnection connection = new ServiceConnection() {
           @Override
           public void onServiceConnected(ComponentName name, IBinder service) {
               downloadBinder = (MyService.DownloadBinder) service;
               downloadBinder.startDownload();
               downloadBinder.getProgress();
           }
   
           @Override
           public void onServiceDisconnected(ComponentName name) {
   
           }
       };
       //Button实例
           Button bindService = (Button) findViewById(R.id.bind_service);
           Button unbindService = (Button) findViewById(R.id.unbind_service);
           bindService.setOnClickListener(this);
           unbindService.setOnClickListener(this);
           
   	//新增clickon cse
               case R.id.bind_service:
                   Intent bindIntent = new Intent(this,MyService.class);
                   bindService(bindIntent,connection,BIND_AUTO_CREATE);
                   break;
               case R.id.unbind_service:
                   Intent unbindIntent = new Intent(this,MyService.class);
                   unbindService(connection);
                   break;
   ```

#### Service生命周期

Service是一个后台运行的组件，执行长时间运行切不需要用户交互的任务，即使应用被销毁也依然可以工作，Service基本包括两种状态：

1. Started：Android的应用程序组件，如Activity，通过startService()启动了服务，则服务是Started状态，一旦启动，Activity可以在后台无限期运行，即使启动它的组件已经被销毁；
2. Bound：当Android的应用程序组件通过bindService()绑定了Activity，则服务是Bound状态，Bound状态的服务提供了一个客户服务器接口来允许组件与Activity进行交互，如发送请求，获取结果，甚至通过IPC来进行跨进程通信。

如图所示，左边展示了服务通过startService()被创建时的生命周期，右边展示了服务通过bindService()被创建时的生命周期：

### Application

#### 全局获取Context

Android程序中很多地方都需要用到Context，弹出Toast时需要，启动Activity时需要，发送Broadcast时需要，操作Database时需要，使用Notification时需要，所以全局获取Context很重要

Android提供了一个Application类，每当应用程序启动的时候，系统就会自动将这个类进行初始化，我们可以定制一个自己的Applicaiton类，以便于管理程序内一些全局的状态信息，比如说全局Context，代码如下：

```java
public class MyApplication extends Application {//创建MyApplication类继承Application类
    private static Context context;

    @Override
    public void onCreate() {//重写onCreate()方法并调用getApplicationContext()方法获得context
        context = getApplicationContext();
    }
    public static Context getContext(){//提供静态getContext()方法返回获得的context
        return context;
    }
}
```

设置系统程序启动时应初始化MyApplication类，而不是默认的Application类，在AndroidManifest.xml文件的<application>标签进行指定即可，代码如下：

```xml
<application
	andriod:name="com.example.networktest.MyApplication"
	…>
```

如果我们已经配置过自己的Application，与LitePal配置的LitepalApplication冲突了怎么办，LitePal提供了很简单的解决方案，即在我们自己的Application中调用LitePal的初始化方法，就不用配置LitePalApplication，代码如下

```java
public class MyApplication extends Application {//创建MyApplication类继承Application类
    private static Context context;

    @Override
    public void onCreate() {//重写onCreate()方法并调用getApplicationContext()方法获得context
        context = getApplicationContext();
      	LitePalApplication.initialize(context);
    }
    public static Context getContext(){//提供静态getContext()方法返回获得的context
        return context;
    }
}
```

### Intent

#### 使用Intent在Activity之间穿梭

从主Activity跳转到其他Activity，使用Intent可以在Android程序中各组件之间进行交互，它可以指明组件想要执行的动作，还可以在不同组件之间传递数据，Intent一般可以分为两种：显式、隐式。

1. 使用显式Intent

   修改FirstActivity中按钮的点击事件，代码如下：

   ```java
           button1.setOnClickListener(new View.OnClickListener() {
               @Override
               public void onClick(View v) {
                   Intent intent = new Intent(FirstActivity.this,SecondActivity.class);
                   startActivity(intent);
               }
           });
   ```

2. 使用隐式Intent

   相较于显式Intent，隐式Intent则含蓄了很多，它并不明确指出我们想要启动哪一个Activity，而是指定了一系列更为抽象的action和category等消息，然后交由系统去分析这个Intent，并帮我们找出合适的Activity去启动。

   通过在<activity>标签下配置<intent-filter>的内容，可以指定当前Activity能够响应的action和category，打开AndroidManifest.xml，添加如下代码：

   ```xml
           <activity android:name=".SecondActivity">
               <intent-filter>
                   <action android:name="com.example.activitytest.ACTION_START"/>
                   <category android:name="android.intent.category.DEFAULT"/>
                   <category android:name="com.example.activitytest.MY_CATEGORY"/>
               </intent-filter>
           </activity>
   ```

   只有<action>和<category>中的内容同时能够匹配上Intent中指定的action和category时，这个Activity才能响应该Intent。

   修改FirstActivity中按钮的点击事件，代码如下：

   ```java
           button1.setOnClickListener(new View.OnClickListener(){
               @Override
               public void onClick(View v) {
                   Intent intent = new Intent("com.example.activitytest.ACTION_START");
                   intent.addCategory("com.example.activitytest.MY_CATEGORY");
                   startActivity(intent);
               }
           });
   ```

3. 隐式Intent调用系统内浏览器

   使用隐式Intent，不仅可以启动自己程序内的Activity，还可以启动其他程序的Activity，如自己的应用程序中调用系统的浏览器来打开这个网页，修改FirstActivity中按钮点击事件的代码，如下：

   ```java
           button1.setOnClickListener(new View.OnClickListener(){
               @Override
               public void onClick(View v) {
                   Intent intent = new Intent(Intent.ACTION_VIEW);
                   intent.setData(Uri.parse("http://www.baidu.com"));
                   startActivity(intent);
               }
           });
   ```

4. 向下一个Activity传递数据

   Intent还可以在启动Activity的时候传递数据，Intent中提供了一系列putExtra()方法的重载，可以把我们想要传递的数据暂存在Intent中，启动另一个Activity后，只需要把这些数据再从Intent中取出就可以了，代码如下

   ```java
   button1.setOnClickListener(new View.OnClickListener(){
               @Override
               public void onClick(View v) {
                   String data = "Hello SecondActivity";
                   Intent intent = new Intent(FirstActivity.this,SecondActivity.class);
                   intent.putExtra("extra_data",data);
                   startActivity(intent);
               }
           });
   ```

   在另一个Activity中使用getStringExtra()方法来获取传递的数据，代码如下

   ```java
   Intent intent = getIntent();
           String data = intent.getStringExtra("extra_data");
           Log.d("SecondActivity",data);
   ```

5. 返回数据给上一个Activity

   既然可以传递数据给下一个Activity，也可以返回数据给上一个Activity，利用Activity中的startActivityForResult()方法，该方法接受两个参数，第一个参数是Intent，第二个参数是请求码，代码如下

   ```java
           button1.setOnClickListener(new View.OnClickListener(){
               @Override
               public void onClick(View v) {
                   Intent intent = new Intent(FirstActivity.this,SecondActivity.class);
                   startActivityForResult(intent,1);
               }
           });
   ```

   在另一个Activity中给按钮注册点击事件，并在点击事件中添加返回数据的逻辑，代码如下

   ```java
           Button button2 = (Button) findViewById(R.id.button2);
           button2.setOnClickListener(new View.OnClickListener() {
               @Override
               public void onClick(View v) {
                   Intent intent = new Intent();
                   intent.putExtra("data_return","Hello FirstActivity");
                   setResult(RESULT_OK,intent);
                   finish();
               }
           });
   ```

   由于我们使用startActivityForResult()方法来启动SecondActivity的，在SecondActivity被销毁后会回调上一个Activity的onActivityResult()方法，因此我们需要在FirstActivity中重写这个方法来得到返回的数据，代码如下

   ```java
       @Override
       protected void onActivityResult(int requestCode, int resultCode, Intent data) {
           switch (requestCode){
               case 1:
                   if(resultCode == RESULT_OK){
                       String returnedData = data.getStringExtra("data_return");
                       Log.d("FirstActivity",returnedData);
                   }
                   break;
               default:
           }
       }
   ```

#### 使用Intent传递对象

使用intent传递自定义对象，有以下方法

1. Serializable方法

   首先准备一个序列化类

   ```java
   public class Person implements Serializable{
       private String name;
       private int age;
   
       public int getAge() {
           return age;
       }
   
       public String getName() {
           return name;
       }
   
       public void setAge(int age) {
           this.age = age;
       }
   
       public void setName(String name) {
           this.name = name;
       }
   }
   ```

   FirstAactivity代码如下

   ```java
   Person person = new Person();
   person.setName("Tom");
   person.setAge(20);
   Intent intent = new Intent(FirstActivity.this,SecondActivity.class);
   intent.putExtra("person_data",person);
   startActivity(intent);
   ```

   接下来在SecondActivity中获取这个对象，代码如下

   ````java
   Person person = (Person) getIntent().getSerializableExtra("person_data");
   ````

2. Parcelable方法

   Parcelable比Serializable方法写法更复杂但效率高，推荐使用Parceable方法辅助Intent传递应用对象

   ```java
   public class Person implements Parcelable{
       private String name;
       private int age;
   
       public int getAge() {
           return age;
       }
   
       public String getName() {
           return name;
       }
   
       public void setAge(int age) {
           this.age = age;
       }
   
       public void setName(String name) {
           this.name = name;
       }
     	
         @Override
       public int describeContents() {
           return 0;
       }
   
       @Override
       public void writeToParcel(Parcel dest, int flags) {
           dest.writeString(name);//写出name
           dest.writeInt(age);//写出age
       }
       
       public static final Parcelable.Creator<Person> CREATOR = new Parcelable.Creator<Person>(){
           @Override
           public Person createFromParcel(Parcel source) {
               Person person = new Person();
               person.name = source.readString();//读取name
               person.age = source.readString();//读取age
               return person;
           }
   
           @Override
           public Person[] newArray(int size) {
               return new Person[size];
           }
       }
   }
   ```

   FirstAactivity代码如下

   ```
   Person person = new Person();
   person.setName("Tom");
   person.setAge(20);
   Intent intent = new Intent(FirstActivity.this,SecondActivity.class);
   intent.putExtra("person_data",person);
   startActivity(intent);
   ```

   接下来在SecondActivity中获取这个对象，代码如下

   ```java
   Person person = (Person) getIntent().getParcelableExtra("person_data");
   ```

## 多媒体API

### Notification

Notification是Android系统中比较有特色的一个功能，当某个应用程序希望向用户提出一些提示信息，而该应用程序又不在前台运行时，就可以借助Notification来实现，发出一条Notification后，手机最上方的状态栏中会显示一个通知的图标，下拉状态栏后可以看到通知的详细内容。Android 8.0系统引入通知渠道这一概念，用户可以控制通知的。

1. 创建通知渠道

   首先需要一个NotificationManager来对通知进行管理，可以调用Context的getSystemService()方法获取到。getSystemService()方法接收一个字符串参数用于确定获取系统的哪个服务，这里传入Context.NOTIFICATION_SERVICE即可。代码如下

   ```java
   NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
   ```

   接下来使用NotificationChannel类构建一个通知渠道，并调用NotificationManager的createNotificationChannel()方法完成创建

   ```java
   if(Build.Version.SDK_INT>=Build.VERSION_CODES.O){//判断是否版本大于8.0
   	NotificationChannel channel = new NotificationChannel(channelId,channelName,importance);
   	manager.createNotificationChannel(channel);
   }
   ```

2. 通知的基本用法

   使用NotficationCompat类构造Notification对象，就可以保证程序的Notification在所有系统版本都能正常工作，代码如下

   ````java
   Notification notification = new notificaitonCompat.Builder(context)
           .setContentTitle("This is content title")//指定通知的标题内容
           .setContentText("This is content text")//指定通知的正文内容
           .setSmallIcon(R.drawable.small_icon)//设置通知的小图标
           .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.drawable.large_icon))//设置通知的大图标
           .build()
   ````

   使用NotificationManager的notify()方法就可以让通知显现

   ```java
   manager.notigy(1,notification);
   ```

### Camera和Album



### MediaPlayer



## 数据存储

### SharedPreferences存储



### SQLite存储





## Android网络通信

### WebView的用法

在程序中展示一些网页，可以使用WebView控件

```xml
    <WebView
        android:id="@+id/web_view"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"/>
```

在Activity代码中获得WebView实例，并实现访问网页

```java
        WebView webView = (WebView) findViewById(R.id.web_view);
        webView.getSettings().setJavaScriptEnabled(true);
        webView.loadUrl("http://www.baidu.com");
```

再加入网络权限

````xml
    <uses-permission android:name="android.permission.INTERNET"/>
````

### 使用HTTP协议访问网络

1. 使用HttpURLConnection

新建一个Button和ScrollView来实现，代码如下

```xml
    <Button
        android:id="@+id/send_request"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Send Request"/>
    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="wrap_content">
        <TextView
            android:id="@+id/response_text"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"/>
    </ScrollView>
```

接着修改Activity里的代码

```java
ublic class MainActivity extends AppCompatActivity implements View.OnClickListener{

    TextView responseText;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button sendRequest = (Button) findViewById(R.id.send_request);
        responseText = (TextView) findViewById(R.id.response_text);
        sendRequest.setOnClickListener(this);
    }

    @Override
    public void onClick(View v) {
        if(v.getId() == R.id.send_request){

        }
    }

    private void sendRequestWithHttpURLConnection(){
        //开启线程来发起网络请求
        new Thread(new Runnable() {
            @Override
            public void run() {
                HttpURLConnection connection = null;
                BufferedReader reader = null;
                try {
                    URL url = new URL("http://www.baidu.com");
                    connection = (HttpURLConnection) url.openConnection();
                    connection.setRequestMethod("GET");
                    connection.setConnectTimeout(8000);
                    connection.setReadTimeout(8000);
                    InputStream in = connection.getInputStream();
                    //下面对获取的输入流进行读取
                    reader = new BufferedReader(new InputStreamReader(in));
                    StringBuilder response = new StringBuilder();
                    String line;
                    while((line = reader.readLine()) != null){
                        response.append(line);
                    }
                    showResponse(response.toString());
                }catch (Exception e){
                    e.printStackTrace();
                }finally{
                    if(reader != null){
                        try{
                            reader.close();
                        }catch (IOException e){
                            e.printStackTrace();
                        }
                    }
                    if(connection != null) {
                        connection.disconnect();
                    }
                }
            }
        }).start();
    }

    private void showResponse(final String response){
        runOnUiThread(new Runnable(){
            @Override
            public void run(){
                //在这里进行UI操作，将结果显示到界面上
                responseText.setText(response);
            }
        });
    }
}
```

2. OkHttp方法，以及其他开源方法

OkHttp是由Square公司开发，在使用之前先在项目中添加OkHttp库的依赖

```xml
implementation 'com.squreup.okhttp3.okhttp:4.9.0'
```

OkHttp具体用法

```java
    private void sendRequestWithOkHttp(){
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    OkHttpClient client = new OkHttpClient();
                  //实例化OkHttpClient实例
                    Request request = new Request.Builder().url("http://www.baidu.com").build();
                  //创建Request对象，调用Builder和url丰富，再build()构造；
                    Response response = client.newCall(request).execute();
                  //调用OkHttpClient的newCall()方法来创建一个Call对象，并调用execute方法来发送请求并获取服务器返回的数据
                    String responseData = response.body().string();
                  //获取response的数据，调用response.body并转为string类型；
                    showResponse(responseData);
                }catch (Exception e){
                    e.printStackTrace();
                }
            }
        }).start();
    }
```



### 解析XML格式数据

1. Pull解析方式

   

2. SAX解析方式



### 解析SAX格式数据

1. 使用JSONObject



2. 使用GSON





## 架构设计

### Jetpcak

#### Jetpack简介

Jetpack是一个开发组件工具集，不依赖于任何Android系统版本，通常定义在AndroidX库当中，拥有非常好的向下兼容性。



#### ViewModel

ViewModel应该可以说是Jetpack中最重要的组件之一，它的生命周期如下

#### Lifecycles



#### LiveData



#### Room



#### WorkManager



### MVVM架构

Model-View-ViewModel(MVVM)是一个软件架构设计模式，源自于经典的Modle-View-Controller(MVC)模式，MVVM的出现促进了GUI前端开发与后端业务逻辑的分离，极大地提高了前端开发效率，MVVM核心是ViewModel层，它就像一个中转站(value converter)，负责转换Model中的数据对象，让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与Model层通过接口请求进行数据交互，起承上启下作用，架构如下所示，当下流行的MVVM框架有Vue、Angular等。

![img](https://images2017.cnblogs.com/blog/882926/201711/882926-20171115175942921-775941263.png)

MVVM的各部分组成，如下：

![img](https://images2017.cnblogs.com/blog/882926/201711/882926-20171115175958671-1955710845.png)

1. View层

   View即是视图层，也就是用户界面，前端主要由HTML和CSS构建，为了方便地展现ViewModel或者Model层的数据，已经产生了各种各样的前后端模板语言，Vue和Angular也有自己用来构建用户界面的内置模板语言。

2. Model层

   Model是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，主要围绕数据库系统展开。

3. ViewModel层

   ViewModel是由前端开发人员组织生成和维护的视图数据层，在这一层，前端开发者从后端获取的Model数据进行转换处理，做二次封装，以生成符合View层使用预期的视图数据模型。

4. 总结

   - ViewModel所封装出来的数据模型包括视图状态和视图行为两部分，而Model层的数据模型是只包含展示状态的，即视图状态，而页面加载进来发生什么，如点击、滚动发生什么，都属于视图行为(交互)，这样的封装使得ViewModel可以完整地去描述View层。
   - 由于实现了双向绑定，ViewModel的内容会实时展现在View层，这样使得前端开发人员不必要麻烦滴通过操纵DOM去更新视图，MVVM已经把这些脏累活都做好了，只需要处理和维护ViewMode层即可，更新数据视图就会自动得到相应更新，真正实现数据驱动开发；
   - View层展现的不是Model层的数据，而是ViewModel的数据，由ViewModel负责与Model层交互，这样就完全解耦合了View层和Model层，是前后端分离实施重要的一环。

## Android进阶技巧

### Debug技巧

#### 空指针异常

java.lang.NullPointerException: Attempt to invoke virtual method ‘void android.view.View...

首先是查看报错的第一行（Androidstudio中打开run界面第一个可点击的地方），一般前几行都是比较关键的，我们一定要注意：

1. 检查我们的XML文件里面定义的id（这个很关键），看看有没有对应的id；
2. 检查代码中(对象，实例等）有没有初始化；
3. 检查我们对应的事件（比如点击事件）有没有设置监听器。

### 定制自己的日志工具

定制自己的日志工具，新建一个LogUtil类，代码如下

```java
public class LogUtil {
    public static final int VERBOSE = 1;
    public static final int DEBUG = 2;
    public static final int INFO = 3;
    public static final int WARN = 4;
    public static final int ERROR = 5;
    public static final int NOTHING = 6;
    public static int level = VERBOSE;//开发时将level指定成VERBOSE，上线时level指定成NOTHING即可

    public static void v(String tag,String msg){
        if(level <= VERBOSE){
            Log.v(tag,msg);
        }
    }
    public static void d(String tag,String msg){
        if(level <= DEBUG){
            Log.d(tag,msg);
        }
    }
    public static void i(String tag,String msg){
        if(level <= INFO){
            Log.i(tag,msg);
        }
    }
    public static void W(String tag,String msg){
        if(level <= WARN){
            Log.w(tag,msg);
        }
    }
    public static void E(String tag,String msg){
        if(level <= ERROR){
            Log.e(tag,msg);
        }
    }
}
```

### ButterKnife

ButterKnife是一个专注于Android系统的View注入框架，以前总是要写很多findViewById来找到View对象，有了ButterKnife可以很轻松的省去这些步骤，ButterKnife的优势：

1. 强大的View绑定和Click事件处理功能，简化代码，提升开发效率；
2. 方便的处理Adapter里的ViewHolder绑定问题；
3. 运行时不会影响APP效率，使用配置方便；
4. 代码清晰，可读性强。

ButterKnife的使用需要添加依赖

```xml
implementation 'com.jakewharton:butterknife:10.1.0'
annotationProcessor 'com.jakewharton:butterknife-compiler:10.1.0'
```

ButterKnife的使用

1. Activity中的使用

   ```java
   public class MainActivity extends AppCompatActivity {
   
       //获取插件
       @BindView(R.id.name)
       EditText name;
   
       @BindView(R.id.btn)
       Button btn;
   
       @BindView(R.id.txt)
       TextView txt;
   
       @Override
       protected void onCreate(Bundle savedInstanceState) {
           super.onCreate(savedInstanceState);
           setContentView(R.layout.activity_main);
       }
       //绑定处理
       ButterKnife.bind(this);
   }
   
       //按钮点击事件处理
       @OnClick(R.id.btn)
       public void onViewClicked(){
           
           if (TextUtils.isEmpty(name.getText().toString().trim())){
               return;
           }
           
           if(name.getText().toString().trim().length() < 6){
               return;
           }
           
           txt.setText(name.getText());
       }
   ```

2. Fragment中的使用

   ```java
   public class BlankFragment extends Fragment {
       
       @BindView(R.id.txt)
       TextView txt;
       
       @BindView(R.id.btn)
       Button btn;
       
       Unbinder unbinder;
   
   
       @Override
       public View onCreateView(LayoutInflater inflater, ViewGroup container,  Bundle savedInstanceState) {
           View inflate = inflater.inflate(R.layout.fragment_blank,container,false);
           unbinder = ButterKnife.bind(this,inflate);
           return inflate;
       }
   
       @Override
       public void onDestroyView() {
           super.onDestroyView();
           unbinder.unbind();
       }
       
       @OnClick(R.id.btn)
       public void onViewClicked() {
           
       }
   }
   ```

### 全定义Dialog

#### Dialog的生命周期

Dialog的生命周期一共用以下6个方法：
onCreate()，show()，onStart() ，cancel()，onDismiss()，Stop() 。

* onCreate()仅在Dialog第一次启动时会执行，之后无论Dialog执行onDismiss、cancel、stop方法都不会执行onCreate
* show()和onStart()方法在每次Dialog显示时都会依次执行
* onDismiss()和stop()在每次Dialog消失时都会执行
* cancel()是在点击Back键或者Dialog外部时触发，然后依次执行onDismiss和stop()

Dialog生命周期举例

点击显示按钮，第一次显示Dialog，然后按BACK键返回。
show() -> onCreate() -> onStart();
cancel() -> onDismiss() -> Stop();
再次点击显示按钮，然后点击Dialog外部。
show() -> onStart();
cancel() -> onDismiss() -> Stop();
再次点击显示按钮，然后执行Dialog.dismiss() 方法。
show() -> onStart();
onDismiss() -> Stop();

#### 全定义Dialog例子

Dialog就是一个弹窗，提示用户去选择，安卓自带的dialog有三种：

1. AlertDialog：普通的提示对话框；
2. ProgressDialog：进度条对话框；
3. DatePickerDialog/TimePickerDialog：日期对话框/时间对话框。

所有的对话框都是直接或间接继承自Dialog类，而AlertDialog直接继承自Dialog，其他的几个类均继承自AlertDialog。

全定义dialog步骤如下：

1. 在values/styles.xml新建一个样式MyDialog

   ```xml
   <style name="MyDialog" parent="android:Theme.Dialog">
       <!-- 背景颜色及透明程度 -->
       <item name="android:windowBackground">@android:color/transparent</item>
       <!-- 是否半透明 -->
       <item name="android:windowIsTranslucent">false</item>
       <!-- 是否没有标题 -->
       <item name="android:windowNoTitle">true</item>
       <!-- 是否浮现在activity之上 -->
       <item name="android:windowIsFloating">true</item>
       <!-- 是否背景模糊 -->
       <item name="android:backgroundDimEnabled">false</item>
       <!-- 设置背景模糊的透明度-->
       <item name="android:backgroundDimAmount">0.5</item>
   </style>
   ```

2. 新建一个MyDialog类继承Dialog类

   ```java
   public class MyDialog extends Dialog implements View.OnClickListener{    
   		//在构造方法里提前加载了样式
       private Context context;//上下文
       private int layoutResID;//布局文件id
       private int[] listenedItem;//监听的控件id
       public MyDialog(Context context,int layoutResID,int[] listenedItem){
           super(context,R.style.MyDialog);//加载dialog的样式
           this.context = context;
           this.layoutResID = layoutResID;
           this.listenedItem = listenedItem;
       }
   
       @Override
       protected void onCreate(Bundle savedInstanceState) {
           super.onCreate(savedInstanceState);
           //提前设置Dialog的一些样式
           Window dialogWindow = getWindow();
           dialogWindow.setGravity(Gravity.CENTER);//设置dialog显示居中
           //dialogWindow.setWindowAnimations();设置动画效果
           setContentView(layoutResID);
   
   
           WindowManager windowManager = ((Activity)context).getWindowManager();
           Display display = windowManager.getDefaultDisplay();
           WindowManager.LayoutParams lp = getWindow().getAttributes();
           lp.width = display.getWidth()*4/5;// 设置dialog宽度为屏幕的4/5
           getWindow().setAttributes(lp);
           setCanceledOnTouchOutside(true);//点击外部Dialog消失
           //遍历控件id添加点击注册
           for(int id:listenedItem){
               findViewById(id).setOnClickListener(this);
           }
       }
       private OnCenterItemClickListener listener;
       public interface OnCenterItemClickListener {
           void OnCenterItemClick(MyDialog1 dialog, View view);
       }
       //很明显我们要在这里面写个接口，然后添加一个方法
       public void setOnCenterItemClickListener(OnCenterItemClickListener listener) {
           this.listener = listener;
       }
   
   
       @Override
       public void onClick(View v) {
           dismiss();//注意：我在这里加了这句话，表示只要按任何一个控件的id,弹窗都会消失，不管是确定还是取消。
           listener.OnCenterItemClick(this,v);
       }
   }
   ```

3. 主Activity继承自己写的dialog接口，实现点击方法

   ```java
   //定义一个自己的dialog
    private MyDialog myDialog;
   //实例化自定义的dialog
     myDialog = new MyDialog(this,R.layout.dialog_2,new int[]{R.id.dialog_btn});
     //绑定点击事件
    myDialog.setOnCenterItemClickListener((MyDialog.OnCenterItemClickListener) this);
    //显示
     myDialog.show();
    //调用点击函数
    @Override
       public void OnCenterItemClick(MyDialog dialog, View view) {
           switch (view.getId()){
               case R.id.dialog_btn:
                   Toast.makeText(getApplicationContext(),"点击了",Toast.LENGTH_SHORT).show();
                   break;
               default:
                   break;
           }
       } 
   ```


#### 解决Dialog圆角不显示问题

首先在xml里面写一个圆角背景，由于dialog默认是白色的，故无法显示dialog圆角效果，必须在new dialog的时候加入以下代码：

```java
Window dialogWindow = dialog.getWindow();
dialogWindow.setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT));
```

### RxPermissions

#### Android权限分类

Android 6.0(API Level 23)中，将权限分成了两类：

* Install权限，即安装时权限，不给用户提示界面，系统自动决定权限的赋予；
* Runtime权限，即运行时权限，会显示明显的权限授予界面，让用户决定是否授予权限。

#### RxPermissions的优势

帮助开发者简化requestPermissions()相关的处理：

* 开发者不用担心Android运行环境的版本，RxPermissions内部已经对Android版本进行了判断；
* 将权限申请(`requestPermissions()`)和请求结果(`onRequestPermissionsResult()`)的代码放在一起管理，避免代码分散；
* RxPermissions具备Rx(RxJava)的特性，可以使用链式操作，可以执行filter操作，transform操作等等。

#### RxPermissions的使用

* build.gradle添加依赖

  ```xml
  dependencies {
      ...
      compile 'io.reactivex.rxjava2:rxandroid:2.0.1'
      compile 'io.reactivex.rxjava2:rxjava:2.0.5'
      compile 'com.tbruyelle.rxpermissions2:rxpermissions:0.9.3@aar'
      ...
  }
  ```

* AndroidManifest.xml中添加使用权限

  ```xml
  <!-- protection level is dangerous, need request runtime permission -->
  		<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
      <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
      <uses-permission android:name="android.permission.READ_PHONE_STATE"/>
      <uses-permission android:name="android.permission.READ_CALL_LOG"/>
      <uses-permission android:name="android.permission.RECORD_AUDIO"/>
      <uses-permission android:name="android.permission.CAMERA"/>
      <uses-permission android:name="android.permission.GET_ACCOUNTS"/>
      <uses-permission android:name="android.permission.READ_CONTACTS"/>
      <uses-permission android:name="android.permission.READ_CALENDAR"/>
      <uses-permission android:name="android.permission.SEND_SMS"/>
      <uses-permission android:name="android.permission.READ_SMS"/>
      <uses-permission android:name="android.permission.CALL_PHONE"/>
  ```

* 必须在Activity的onCreate()中申请权限

  ```java
  package com.galian.rxjavatest;
  
  import android.Manifest;
  import android.support.v7.app.AppCompatActivity;
  import android.os.Bundle;
  import android.util.Log;
  
  import com.tbruyelle.rxpermissions2.Permission;
  import com.tbruyelle.rxpermissions2.RxPermissions;
  
  import io.reactivex.functions.Consumer;
  
  public class RxPermissionTestActivity extends AppCompatActivity {
  
      private static final String TAG = "RxPermissionTest";
  
      @Override
      protected void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);
          setContentView(R.layout.activity_rx_permission_test);
  
          requestPermissions();
      }
  
      private void requestPermissions() {
          RxPermissions rxPermission = new RxPermissions(RxPermissionTestActivity.this);
          rxPermission
                  .requestEach(Manifest.permission.ACCESS_FINE_LOCATION,
                          Manifest.permission.WRITE_EXTERNAL_STORAGE,
                          Manifest.permission.READ_CALENDAR,
                          Manifest.permission.READ_CALL_LOG,
                          Manifest.permission.READ_CONTACTS,
                          Manifest.permission.READ_PHONE_STATE,
                          Manifest.permission.READ_SMS,
                          Manifest.permission.RECORD_AUDIO,
                          Manifest.permission.CAMERA,
                          Manifest.permission.CALL_PHONE,
                          Manifest.permission.SEND_SMS)
                  .subscribe(new Consumer<Permission>() {
                      @Override
                      public void accept(Permission permission) throws Exception {
                          if (permission.granted) {
                              // 用户已经同意该权限
                              Log.d(TAG, permission.name + " is granted.");
                          } else if (permission.shouldShowRequestPermissionRationale) {
                              // 用户拒绝了该权限，没有选中『不再询问』（Never ask again）,那么下次再次启动时，还会提示请求权限的对话框
                              Log.d(TAG, permission.name + " is denied. More info should be provided.");
                          } else {
                              // 用户拒绝了该权限，并且选中『不再询问』
                              Log.d(TAG, permission.name + " is denied.");
                          }
                      }
                  });
  
  
      }
  }
  ```

#### RxPermissions中的方法总结

| 方法                | 方法描述                                                     | 方法返回值                                                   |
| ------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| request             | 不支持返回权限名; 返回的权限结果:全部同意时值true,否则值为false | 申请结果:false                                               |
| requestEach         | 把每一个权限的名称和申请结果都列出来                         | 权限名称:android.permission.READ_CONTACTS,申请结果:false权限名称:android.permission.WRITE_CONTACTS,申请结果:false权限名称:android.permission.READ_SMS,申请结果:false权限名称:android.permission.ACCESS_FINE_LOCATION,申请结果:true权限名称:android.permission.ACCESS_COARSE_LOCATION,申请结果:true |
| requestEachCombined | 返回的权限名称:将多个权限名合并成一个; 返回的权限结果:全部同意时值true,否则值为false | 权限名称:android.permission.READ_CONTACTS, android.permission.WRITE_CONTACTS, android.permission.READ_SMS, android.permission.ACCESS_FINE_LOCATION, android.permission.ACCESS_COARSE_LOCATION,申请结果:false |
| ensureEach          | 必须配合rxjava,回调结果跟requestEach一样                     |                                                              |
| ensureEachCombined  | 必须配合rxjava,回调结果跟requestEachCombined一样             |                                                              |

### Bitmap

#### Bitmap的格式

Bitmap是位图，由很多个像素点组成

1. 存储格式：

   * ALPHA_8: 只存储透明度，不存储色值，1个像素点各占1个字节；
   * ARGB_4444：ARGB各用4位存储，1个像素点16位占2个字节；
   * ARGB_8888：ARGB各用8位存储，1个像素点32位占4个字节；
   * RGB_565：只存储色值，不存储透明度，RGB分别占5/6/5位，1个像素点16位占2个字节。

   一般情况下：

   * 用ARGB_8888格式存储Bitmap；
   * ARGB_4444格式画面惨不忍睹，已经被弃用；
   * 假如对图片没有透明度要求，可以使用RGB_565替代ARGB_8888，节省一半内存开销。

2. 压缩格式：

   按1024*768的屏幕大小计算全屏Bitmap图大小，每个像素32B，4个字节

   ````
   1024*768*32B = 25165824B = 24MB
   ````

   一张手机屏幕大小的Bitmap竟然要24M，非常耗内存，有必要使用枚举类Bitmap.CompressFormat进行压缩，分以下三种：

   * Bitmap.CompressFormat.JPEG：JPEG算法，有损压缩，得到文件较小，画质较差，不支持透明度，透明像素会以黑色背景填充；
   * Bitmap.CompressFormat.PNG：PNG算法，无损压缩，支持透明度；
   * Bitmap.CompressFormat.WEBP：WEBP算法同时提供有损压缩和无损压缩的图片文件格式，在14<=api<=17时，WEBP是一种有损压缩格式，而且不支持透明度，在api18及以后WEBP是一种无损压缩格式，而且支持透明度，有损压缩时，在质量相同的情况下，WEBP格式的图片体积比JPEG小40%，但是编码时间比JPEG长8倍。在无损压缩时，无损的WEBP图片比PNG压缩小26%，但是WEBP的压缩时间是PNG格式压缩时间的5倍。

#### Bitmap创建方法

1. Bitmap.Options

   这个参数作用非常强大，可以设置Bitmap的采样率，通过改变图片的宽度高度和缩放比例等，以达到减少图片像素数的目的，一言以蔽之，通过这几个参数我们可以很好地控制显示和使用Bitmap，避免OOM发生的概率。有几个重要的变量值：

   * **inJustDecodeBounds**:**boolean**类型，设为**true**时，无需要把图片加载入内存就可以获取图片的高度，宽度和图片的MIME类型。高度通过`options.outWidth`获取 宽度通过`options.outHeight`获取MIME通过`options.outMineType`获取
   * **inSampleSize**:这个字段表示采样率，打个比方说，设置为4，则是从原本图片的四个像素中取一个像素作为结果返回。其余的都被丢弃。可见，采样率越大，图片越小，失真越严重。 如何计算采样率呢？看一下这段代码你就会明白

   ```java
   public int getSampleSize(BitmapFactory.Options options , int dstWidth,int dstHeight){
           //dstWidth:表示目前ImageView的宽度
           //dstHeight:表示目标ImageView的高度
           //option中获取bitmap图片的信息
           int  rawWidth = options.outWidth;
           int  rawHeight = options.outHeight;
           int sampleSize=1;
           if(rawWidth>dstWidth||rawHeight>dstHeight){
               float ratioHeight = (float) (rawHeight/dstHeight);
               float ratioWidth = (float) (rawWidth/dstWidth);
               sampleSize = (int) Math.min(rawHeight, ratioWidth);
           }
           return sampleSize;
       }
   ```

   * **inScald**:这个参数表示，在可以缩放时，是否对当前文件进行放缩，如果设置为**false**就不放缩。设置为**true**，则会根据文件夹分辨率和屏幕分辨率进行动态缩放。
   * **inPreferredConfig**:这个参数是用来设置像素的存储格式的。

2. BitmapFactory

   BitmapFactory提供了很多种创建bitmap的静态方法

   ```java
   //从资源文件中通过id加载bitmap
   //Resources res:资源文件，可以context.getResources()获得
   //id:资源文件的id，如R.drawable.xxx
   public static Bitmap decodeResources(Resources res,int id)
   //第二种只是第一种的重载方法，多了个Options参数
   public static Bitmap decodeResources(Resources res,int id,Options opt)
   
   //传入文件路径加载，比如加载sd卡中的文件
   //pathName:文件的全路径名
   public static Bitmap decodeFile(String pathName);
   public static Bitmap decodeFile(String pathName,Options opt);
   
   //从byte数组中加载
   //offset:对应data数组的起始下标
   //length:截取的data数组的长度
   public static Bitmap decodeByteArray(byte[] data,int offset , int length);
   public static Bitmap decodeByteArray(byte[] data,int offset , int length,Options opt);
   
   //从输入流中加载图片
   //InputStream is:输入流
   //Rect outPadding:用于返回矩形的内边距
   public static Bitmap decodeStream(InputStream is);
   public static Bitmap decodeStream(InputStream is,Rect outPadding,Options opt);
   
   //FileDescriptor :包含解码位图的数据文件的路径
   //通过该方式从路径加载bitmap比decodeFile更节省内存，原因不解释了。
   public static Bitmap decodeFileDescriptor(FileDescriptor fd);
   public static Bitmap decodeFileDescriptor(FileDescriptor fd,Rect outPadding,Options opt);
   ```

3. Bitmap静态方法

   ```java
   //width和height是长和宽单位px,config是存储格式
   static Bitmap createBitmap(int width , int height Bitmap.Config config)
   // 根据一幅图像创建一份一模一样的实例
   static Bitmap createBitmap(Bitmap bm)
   //截取一幅bitmap，起点是（x，y）,width和height分别对应宽高
   static Bitmap createBitmap(Bitmap bm,int x,int y,int width,int height)
   //比上面的裁剪函数多了两个参数，Matrix:给裁剪后的图像添加矩阵 boolean filter:是否给图像添加滤波效果
   static Bitmap createBitmap(Bitmap bm,int x,int y,int width,int height，Matrix m,boolean filter);
   //用于缩放bitmap,dstWidth和dstHeight分别是目标宽高
   createScaledBitmap(Bitmap bm,int dstWidth,int dstHeight,boolean filter)
   
   ```

#### Bitmap创建方法总结

1. 加载图像可以使用BitmapFactory和Bitmap.create系列方法
2. 可以通过Options实现缩放图片，获取图片信息，配置缩放比例等功能
3. 如果需要裁剪或者缩放图片，只能使用create系列函数
4. 注意加载和创建bitmap事通过try catch捕捉OOM异常

#### Bitmap的内存占用获取方法

```java
    public static int getBitmapSize(Bitmap bitmap) {
        //API 19
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
            return bitmap.getAllocationByteCount();
        }
        //API 12,等同于Width*Height的像素乘积
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB_MR1) {
            return bitmap.getByteCount();
        }
        //earlier version,在低版本中用一行的字节x高度
        return bitmap.getRowBytes() * bitmap.getHeight();
    }
```

### Luban压缩算法

#### Android图片显示遇到的问题

在Android应用中加载图片，是一个需要消耗内存的一个动作，也是Android开发者在项目优化中比较头疼的一个问题，首先需要了解下加载图片是如何消耗内存的：

* ALPHA_8: 只存储透明度，不存储色值，1个像素点各占1个字节；
* ARGB_4444：ARGB各用4位存储，1个像素点16位占2个字节；
* ARGB_8888：ARGB各用8位存储，1个像素点32位占4个字节；
* RGB_565：只存储色值，不存储透明度，RGB分别占5/6/5位，1个像素点16位占2个字节。

#### Luban算法分析

1. 首先，判断图片的长宽比例值，是否处于以下区间：

   * [1,0.5625)即图片处于[1:1,9:16)比例范围内；
   * [0.5625,0.5)即图片处于[9:16,1:2)比例范围内；
   * [0.5,0)即图片处于[1:2,1: ∞)比例范围内。

2. 其次，判断图片最长边是否过边界值：

   * [1,0.5625)的边界值为：1664n(n=1)，4990n(n=2)，1280*pow(2,n-1)(n>=3)；
   * [0.5625,0.5)的边界值为：1280*pow(2,n-1)(n>=1)；
   * [0.5,0)的边界值为：1280*pow(2,n-1)(n>=1)。

3. 再次，计算压缩图片实际边长值，以第2步计算结果为准，超过某个边界值，则：

   * width/pow(2,n-1)；
   * height/pow(2,n-1)。

4. 接着，计算压缩图片实际文件大小值，以第2、3步计算结果为主，图片比例越大则文件越大：

   size = m x (newW x newH)/(width x height)

   * [1,0.5625)则width&height对应1664，4990，1280*n(n>=3)，m对应150，300，300；
   * [0.5625,0.5)则width=1440，height=2560，m=200；
   * [0.5,0)则width=1280，height=1280/scale，m=500，注：scale为比例值。

5. 跟着，判断第4步的size是否过小：

   * [1,0.5625)则最小size对应60，60，100；
   * [0.5625,0.5)则最小size都为100；
   * [0.5,0)则最小size都为100。

6. 最后，将前面的值压缩图片weight、height、size传入压缩流程，压缩图片直到满足以上数值。

### Cursor

光标，也称之为游标，一般情况下，我们通过Cursor获取每行的集合数据，代码如下：

```java
SQLiteDataBase db;
Cursor cursor = db.query(各种参数);//db每行参数的集合，即query方法传入的参数条件获取的每行的集合
```

![img](https://img-blog.csdn.net/20170305124655754?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYW5kcm9pZF96eWY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

在遍历Cursor内容的时候，如果不moveToFirst()，它默认的position值是-1，即在第一行(position值为0)之上闪动，所以必须执行**moveToFirst()**。

### Matrix方法进行图片处理

#### matrix.postScale

对图片进行缩放(Scale)处理：

```java
//sx、sy为x、y的缩放比例，（px,py）为缩放的参照点
matrix.postScale(float sx, float sy, float px, float py);
matrix.postScale(float sx, float sy);
matrix.postScale(2, 1);//两个参数为缩放比例。按比例缩放，宽为原来的2倍，1为正常所以高不变，但参考点事坐标原点
matrix.postScale(2, 2, 240-width/2,400-heigth/2);//以 （240-width/2,400-heigth/2）为缩放中心
```

#### matrix.postTranslate

对图片进行平移(Translate)处理：

```java
//dx、dy为x、y的平移距离
matrix.postTranslate(float dx, float dy);
matrix.postTranslate(240-width/2, 400-heigth/2);//参考点为坐标原点（0，0）移动到（240-width/2,400-heigth/2）
```

#### matrix.postRotate

对图片进行旋转(Rotate)处理

```java
//degrees旋转的角度，（px,py）为旋转的参照点
matrix.postRotate(float degrees, float px, float py);
matrix.postRotate(float degrees);
matrix.postRotate(30);//绕原点(0,0)旋转30度
matrix.postRotate(30, width/2, heigth/2);//绕某个点旋转30度，这里选择的原点是图片的中心点
```

#### matrix.postSkew

对图片进行倾斜(Skew)处理

```java
//kx、ky为相对x、y轴倾斜的角度，（px,py）为倾斜的参照点
matrix.postSkew(float kx, float ky, float px, float py);
matrix.postSkew(float kx, float ky);
```