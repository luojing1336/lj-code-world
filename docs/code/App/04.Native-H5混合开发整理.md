# Native-H5混合开发整理

## JSSDK的交互说明

![JSSDK.png](https://s2.loli.net/2025/08/12/CbkpDcnZJ2AiRBM.png)

## H5和Native双向通信机制

Native：APP壳端，提供H5的承载容器，通常是webview，而一些webview上面挂载的jssdk方法；

H5：H5页面端，在APP壳端提供的容器里展示单页面应用(Single Page Application)，可以调用jssdk方法；

最初，了解JSBridge应该是从WeiXinJSBridge(现在已经被封装成JSSDK)，各种web页面可以通过JSBridge调用微信原生APP的功能。

JSBridge是微信浏览器、微信小程序、各公司Hybrid方案主要基本原理，如图：

![H5:Native交互](https://s2.loli.net/2022/07/12/guEqjizbF3aRWdy.png)

## JSBridge原理

### JSBridge双向通道

JSBridge简单来讲，主要是**给JavaScript提供调用Native功能的接口**，让APP开发中的H5页面可以方便地使用地址、摄像头设置支付等Native功能，JSBridge就像其名称中的Bridge的意义一样，是Native和非Native之间的桥梁，它的核心是**构建Native和非Native间消息通信的通道**，而且该通道是**双向通道**。

![JSBridge双向通道](https://s2.loli.net/2022/07/12/EVZcLKiW6qPUtwb.png)

双向通道：

* H5向Native发送消息：调用相关功能、通知Native当前H5的相关状态；
* Native向H5发送消息：回溯调用结果、消息推送、通知H5当前Native的状态。

### JSBridge通信原理

#### H5调用Native

H5调用Native的方式，主要有两种：**注入API**和拦截**URL SCHEME**：

1. 注入API方式：主要是通过WebView提供的接口，向H5的Context(Window)中注入对象或者方法，让H5调用时，直接执行相应的Native代码逻辑，达到H5调用Native的目的。

Android实现：

```java
//封装WebView，并置于Activity/Frament/view中实现与H5交互
public class CommonTBS extends WebView {
    private JSInterfaceTBS jsInterfaceTBS;
    private Context mContext;
    private static final String JS_INTERFACE_NAME = "nativeBridge"; //可以定制这个名
  
    public CommonTBS(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        mContext = context;
        initView(mContext, null);
    }
  
  	public void initView(Context context, ProgressBar progressBar) {
    	//省略UI层操作
      initWebView(progressBar);
    }
	  
  	private void initWebView(ProgressBar progressBar) {
      //省略WebView的一些操作
      mWebView.addJavascriptInterface(getJSInterface(), JS_INTERFACE_NAME);
    }
  
  	public JSInterfaceTBS getJSInterface() {
        Activity activity = CommonUtils.scanForActivity(mContext);
        jsInterfaceTBS = new JSInterfaceTBS(activity, mContext, mWebView, new JSInterfaceCallback() {
            @Override
            public void sendJSResponse(String jsResponse) {
              //这里处理Native给H5发送信息，处理H5调用Native返回Response
              activity.runOnUiThread(new Runnable() {
                @Override
                public void run() {
                  if (mWebView == null) {
                    return;
                  }
                  String format = "bhfaeOpen.handleMessageFromNative(%s);";
                	String js = String.format(format, msg);
                	mWebView.evaluateJavascript(js, null);
            	}
        	});
        }

            @Override
            public void handleNative(String eventKey, JSONObject param, String responseId) throws JSONException {
                if (mOnWebviewListener != null) {
                    mOnWebviewListener.handleNative(eventKey, param, responseId);
                }
            }

            @Override
            public String getCurrentUrl() {
                return currentUrl;
            }
        });

        return jsInterfaceTBS;
    }
	}

//JSInterface类，封装了JSSDK的Native端各种方法的入口
public class JSInterfaceTBS {
  //JSInterfaceTBS的构造函数
  public JSInterfaceTBS(Activity activity, Context context, WebView webView, JSInterfaceCallback jsInterfaceCallback) {
      this.activity = activity;
      mContext = context;
      mWebView = webView;
      this.jsInterfaceCallback = jsInterfaceCallback;
    }
  //带有@JavaScriptInterface注解的postMessage()方法，接收H5调用JSBridge的入口Request
  @JavascriptInterface
  public String postMessage(String par) {
    //0. 入参String转JavaBean 略
    //1. 校验入参，JavaBean和EventKey是否为null？ 略
    //2. 校验域名是否合法
    String currentUrl = jsInterfaceCallback.getCurrentUrl();
    // 2.1 未获取到url的异常情况，默认域名合法
    if (null == currentUrl) { ... }
    // 2.2 非发布环境，即测试环境，默认域名合法
    if (!BHEnvironment.isDistribution()) { ... }
    // 2.3 file://协议的合法 http://和https://协议的不合法
    if (url.startsWith("file://")) { ... }
    if (!url.startsWith("http://") && !url.startsWith("https://")) { ... }
    // 2.4 校验url是否以"bhfae.com"结尾
    String host = new URI(currentUrl.split("\\?")[0]).getHost();
    if (host.endsWith("bhfae.com")) { ... }
    // 2.5 校验url是否在whiteList中
		for (int i = 0; i < whiteList.length(); i++) {
      if (host.endsWith(whiteList.getString(i))) { ... }}
    //3. 根据EventKey调用事件的具体Native方法，并返回回调给H5端
    handleJSSDK(String eventKey, String jsRequest) {
      getBhHandlerFactory().create(eventKey).handle(jsRequest, jsResponse -> 								jsInterfaceCallback.sendJSResponse(GsonUtils.toJson(jsResponse)));
    }
    return par; //return的这个par作用？
  }
}
```

前端调用：

```javascript
//Android调用方式
window.nativeBridge.postMessage(message);
```

iOS实现：

```objective-c
@interface WKWebViewVC ()<WKScriptMessageHandler>

@implementation WKWebVIewVC

- (void)viewDidLoad {
    [super viewDidLoad];

    WKWebViewConfiguration* configuration = [[WKWebViewConfiguration alloc] init];
    configuration.userContentController = [[WKUserContentController alloc] init];
    WKUserContentController *userCC = configuration.userContentController;
    // 注入对象，前端调用其方法时，Native 可以捕获到
    [userCC addScriptMessageHandler:self name:@"messageName"];

    WKWebView wkWebView = [[WKWebView alloc] initWithFrame:self.view.frame configuration:configuration];

    // TODO 显示 WebView
}

- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message {
    if ([message.name isEqualToString:@"messageName"]) {
        NSLog(@"前端传递的数据 %@: ",message.body);
        // Native 逻辑
    }
}
```

前端调用：

```javascript
// iOS 调用方式
window.webkit.messageHandlers.messageName.postMessage(message);
```

2. 拦截URL SCHEME方式：H5端通过某种方式(例如iframe.src)发送URL Scheme请求，之后Native的WebView拦截到请求，并根据URL SCHEME(包括所带的参数)进行相关的操作。

```java
mWebView.setWebViewClient(getWebViewClient());
    public WebViewClient getWebViewClient() {
        return new WebViewClient() {
            @Override
            public boolean shouldOverrideUrlLoading(WebView webView, String url) {
              //拦截bhfae://的scheme协议处理jssdk事件
                isBhfaeEvent = url.startsWith("bhfae://");
                if (url.startsWith(WebView.SCHEME_TEL)) { // 拨打电话
                    try {
                        Intent intent = new Intent(Intent.ACTION_DIAL);
                        intent.setData(Uri.parse(url));
                        (CommonUtils.scanForActivity(mContext)).startActivity(intent);
                        return true;
                    } catch (Exception e) {
                        Log.e(TAG, "Error dialing " + url + ": " + e.toString());
                    }

                } else if (url.startsWith("geo:") || url.startsWith(WebView.SCHEME_MAILTO) || url.startsWith("market:") || url.contains(WX_SCHEME) || url.contains("app.qq.com")) {
                    try {
                        Intent intent = new Intent(Intent.ACTION_VIEW);
                        intent.setData(Uri.parse(url));
                        (CommonUtils.scanForActivity(mContext)).startActivity(intent);
                        return true;
                    } catch (Exception e) {
                        Log.e(TAG, "Error with " + url + ": " + e.toString());
                    }

                } else if (isBhfaeEvent) {
                    String eventStr = url.substring("bhfae://".length());
                    String[] arr = eventStr.split("\\?");
                    if (arr[0].equals(EVENT_KEY_PHONE_CALL)) {
                        String phoneNumber = UrlUtils.getBhfaeQueryJsonObject(arr[1]).optString("tel");
                        callPhone(phoneNumber);
                    } else if ((arr[0].equals(EVENT_KEY_BHFAE_BROWSER) || arr[0].equals(EVENT_KEY_BHFAE_BROWSER_REPLACE)) && arr.length == 2) {
                        String urlStr = UrlUtils.getBhfaeQueryJsonObject(arr[1]).optString("url");
                        SecondPageUtils.getInstance().openBhfaeBrowser(CommonUtils.scanForActivity(mContext), urlStr, arr[0].equals(EVENT_KEY_BHFAE_BROWSER_REPLACE), SecondPageUtils.DisplayMode.NORMAL, SecondPageUtils.DisplayTheme.DARK);
                    } else if (arr[0].equals(EVENT_KEY_SYSTEM_BROWSER) && arr.length == 2) {
                        String urlStr = UrlUtils.getBhfaeQueryJsonObject(arr[1]).optString("url");
                        SecondPageUtils.getInstance().openSystemBrowser(mContext, urlStr);
                    } else if (arr[0].equals(EVENT_KEY_CHANGE_NAVIGATION) && arr.length == 2) {
                        if (mOnWebviewListener != null) {
                            mOnWebviewListener.onPageStarted(arr[1]);
                        }
                    } else if (arr[0].equals(EVENT_KEY_CLOSE_WEBVIEW)) {
                        if (CommonUtils.scanForActivity(mContext) instanceof BHActivity) {
                            CommonUtils.scanForActivity(mContext).finish();
                        }
                    }
                    return true;
                }
                boolean isHttpOrHttps = (url.startsWith("http://") || url.startsWith("https://"));
                if (isHttpOrHttps) {
                    currentUrl = url;
                }
                return !isHttpOrHttps;
            }

            @Override
            public WebResourceResponse shouldInterceptRequest(WebView view, String url) {
                WebResourceResponse response = null;
                if (url.startsWith(BHConstant.BH_FILE_SCHEME)) {
                    try {
                        String path = LocalIdUtils.localIdToAbsPath(url);
                        File file = new File(path);
                        if (file.exists()) {
                            InputStream localCopy = new FileInputStream(path);
                            response = new WebResourceResponse("image/jpeg", "UTF-8", localCopy);
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                return response;
            }
        };
    }

```



URL SCHEME的缺点：

* 使用iframe.src发送URL SCHEME会有url长度的隐患；
* 不使用location.href而使用iframe.src，是因为前者连续调用Native，很容易丢失一些调用；
* 创建请求时，一般需要一定的耗时，比注入API的方式调用同样的功能，耗时更长；

#### Native调用H5

Native调用H5比较简单，直接使用WebView的API即可

```java
// Android4.4之前
webView.loadUrl("javascript:" + javaScriptString); //！无法获取H5执行之后的回调
// Android4.4之后
webView.evaluateJavascript(javaScriptString, new ValueCallback<String>() {
    @Override
    public voidon ReceiveValue(String value){

    }
});

```

### JSBridge的实现

JSBridge主要由两个方法实现：

* H5向Native发送消息：`callHandler` - 调用Native(iOS和Android)的JSSDK方法；
* Native向H5发送消息：`handleFromNative` - Native(iOS和Android)处理H5的接口请求，调用JSBridge的该方法。

将`callHandler`和`handleMessageFromNative`两个函数都挂载在window对象上，H5项目引入该JS文件，就可以访问`callHandler`函数了，同理，Native(iOS和Android)也可以访问window上的方法。

```javascript
function callHandler(api, args, successCallback, errorCallback) {
  // 根据api调用对应的IOS和安卓的方法
  if(ios) {
    callBhfaeAppByIos(方法名称, 参数列表); // IOS
  }
  if(android) {
    callBhfaeAppByAndroid(方法名称, 参数列表); // 安卓
  }
}
```

```javascript
function handleMessageFromNative(api, messageCallback) {
  // 根据 api 将Native返回的消息反馈给 H5
}
```

这里存在一个问题，无法将H5请求和Native返回的信息关联起来，因为这是一个异步操作，应该将请求的信息保存并生成唯一标识(callbackId和responseId)，H5和Native之间的双向通信利用这个标识进行对应，而信息之间的传递也需要固定数据结构，具体如下：

```javascript
{ // 请求的数据结构
  eventKey: '',
  callbackId: '',
  messageType: '',
  params: {},
  successResponse,
  errorResponse
}

{ // 响应的数据结构
  eventKey: '',
  responseId: '', //同callbackId
  messageType: '',
  code: '',
  msg: '',
  body: {}
}
```

加入这两个设计，改造`callHandler`和`handleMessageFromNative`两个函数

```javascript
function callHandler(api, args, successCallback, errorCallback) {
  // 处理请求数据
  handlerRequest(requestData, successResponse, errorResponse)
  // 根据api调用对应的IOS和安卓的方法
  if(ios) {
    callBhfaeAppByIos(方法名称, 参数列表); // IOS
  }
  if(android) {
    callBhfaeAppByAndroid(方法名称, 参数列表); // 安卓
  }
}

// 处理请求数据，将请求数据以 callbackId 为主键保存在数组中
function handlerRequest(data, successResponse, errorResponse) {
    let callbackId = getCallbackId();
    // 根据 callbackId 保存成功的回调函数，和失败的回调函数
    saveCallbacks(callbackId, successResponse, errorResponse);
    let requestData = data;
    requestData = { ...requestData, callbackId };
    // 保存请求数据
    saveRequest(callbackId, requestData);
    return { ...requestData, callbackId };
} 
```

```javascript
function handleMessageFromNative(api, messageCallback) {
  // 根据 api 将Native返回的消息反馈给 H5
  // 根据 code 值调用对应的成功的回调 和 失败的回调
  if (isNotEmpty(responseData) && isNotEmpty(responseData.responseId)) {
        if (isResponseSuccess(responseData.code)) {
            handleResponseSuccess(responseData);
        } else {
            handleResponseError(responseData);
        }
    }
}
```

### JSSDK交互说明

![JSSDK交互说明](https://s2.loli.net/2022/07/14/9dH1TALUSFm38OC.png)

## JSBridge的引用比较

### 由Native端进行注入

将JSBridge.js文件置入APP壳子中：

* 优点：
  * JSBridge的版本容易与Native保持一致，Native端不用对不同版本的JSBridge进行兼容；
* 缺点：
  * xJSBridge注入的时机不确定，需要实现注入失败后重试的机制，保证注入的成功率，同时H5端在调用接口时，需要先判断JSBridge是否注入成功，容易造成大量的代码冗余；
  * APP壳子发版成本比较高，JSBridge的先期不稳定迭代不方便。

### 由H5端引入

将JSBridge.js文件在H5项目中引用：

* 优点：
  * H5端可以确定JSBridge是否存在，直接调用即可；
  * H5端发版成本较低。适合JSBridge的先期不稳定迭代；
* 缺点：
  * 如果JSBridge实现方式有更改，JSBridge需要兼容多版本的Native方法或者Native方法需要兼容多版本的JSBridge。
