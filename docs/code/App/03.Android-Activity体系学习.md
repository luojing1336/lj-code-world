# Android-Activity体系学习

## Activity的生命周期

### 典型情况下的生命周期分析

![1](https://s2.loli.net/2022/07/18/GIan3ck2QDetTCM.png)

1. **onCreate**: 表示Activity正在被创建，生命周期第一个方法，主要做一些初始化工作，如调用setContentView去加载界面布局资源、初始化Activity所需数据等；
2. **onRestart**：表示Activity正在重新启动，当当前Activity从不可见重新变为可见状态时，onRestart就会被调用，一般是由用户行为引起的，如按Home键从APP切换到桌面又切回APP，或者用户打开一个新的APP又回到本APP，在onRestart指向之前，也会按顺序执行onPause和onStop；
3. **onStart**：表示Activity正在被启动，即将开始，这时Activity已经可见了，但并没有出现在前台，还无法和用户交互，可以理解为Activity已经显示出来了，但是用户并不能看到；
4. **onResume**：表示Activity已经可见了，并且出现在前台并开始活动，与onStart相比，onStart和onResume都已经表示Activity可见，但是onStart的时候Activity在后台(用户不可见)，onResume的时候Activity才显示到前台(用户已可见)；
5. **onPause**：表示Activity正在停止，正常情况下，紧接着onStop就会被调用，在特殊情况下，如果这个时候快速地再回到当前Activity，那么onResume才会被调用，这种情况相当极端，用户操作很难实现这一场景，此时可以做一些存储数据、停止动画等工作，但是不能太过于耗时间，因为必然会影响到新的Activity的显示，onPause必须先执行完，新Activity的onResume才会执行；
6. **onStop**：表示Activity即将停止，可以做一些稍微重量级的回收工作，同样不能太过于耗时；
7. **onDestroy**：表示Activity即将被销毁，生命周期最后一个方法，可以做一些回收工作和最终资源的释放。

一个Activity的启动具体说明：

1. 针对一个特定的Activity，第一次启动，回调如下：onCreate -> onStart -> onResume
2. 当用户打开新的Activity或者切换到桌面的时候，回调如下：onPause -> onStop -> onDestroy, 注意，当新Activity采用了透明主题，那么就不会调用onStop；
3. 当用户再次回到原Activity时，回调如下：onRestart -> onStart -> onResume；
4. 当用户按back键回退时，回调如下：onPause -> onStop -> onDestroy；
5. 当Activity被系统回收后再次打开，生命周期方法回调过程如下：onCreate -> onStart -> onResume，但是过程并不是完全一样；
6. 生命周期方法的配对：
   * 从整个生命周期来说，onCreate和onDestroy是配对的，分别标识着Activity的创建和销毁，并且只能有一次调用；
   * 从Activity是否可见来说，onStart和onStop是配对的，随着用户的操作或者设备屏幕的点亮和熄灭，这两个方法可能被调用多次；
   * 从Activity是否在前台来说，onResume和onPause是配对的，随着用户操作或者设备屏幕的点亮和熄灭，这两个方法可能被调用多次。

### 异常情况下的生命周期分析

1. 情况1：资源相关的系统配置发声改变导致Activity被杀死并重新创建

   举例子，以图片资源来说，图片放在drawable目录下，当APP启动时，系统就会根据当前设备的情况去加载合适的Resourses资源，比如说横屏手机和竖屏手机会拿到不同图片(landscape或portrait)，如果当前Activity处于竖屏状态，突然旋转屏幕，由于系统配置发生了改变，在默认设置下，Acticity会被销毁并且重新创建，这时我们也可以阻止系统重新创建我们的Activity，大概如图下所示：

   ![2](https://s2.loli.net/2022/07/18/FZvPwKUglGVhYkn.png)

   当系统配置发生改变导致Activity被销毁，Activity的onPause、onStop和onDestroy均会被调用，同时由于Activity是在异常情况下终止的，系统会调用onSaveInstanceState来保存当前Activity的状态，这个方法调用时机是在onStop之前，与onPause没有时序关系，只有在Activity被异常终止的情况下调用，正好藏不会被调用，当次Activity被重新创建后，系统会调用onRestoreInstanceState，并把Activity销毁时onSaveInstanceState方法所保存的bundle对象最为参数同时传递给onRestoreInstanceState和onCreate方法，因此，我们可以通过onRestoreInstanceState和onCreate方法来判断Activity是否被重建了，如果被重建了，我们就可以取出之前保存的数据并恢复，从时序上来说，onRestoreInstanceState的调用时机再onStart之后。

   **onSaveInstanceState和onRestoreInstanceState方法不仅在Activity存在，在每个View都有这两个方法，用于由于异常销毁后再创建恢复之前保存的状态**。

2. 情况2：资源内存不足导致低优先级的Activity被杀死

   这种特殊情形不太好模拟，但是其数据存储和恢复过程和情况1完全一致，这里只描述Activity的优先级情况，Activity优先级从高到低分以下三种：

   * 前台Activity：正在和用户交互的Activity，优先级最高
   * 可见但非前台Activity：比如Activity中弹出了一个对话框，导致Activity可见，但是位于后台无法和用户直接交护
   * 后台Activity：已经被暂停的Activity，比如执行了onStop，优先级最低

   当系统内存不足时，系统就会安装上述优先级杀死目标Activity所在的进程，并在后续通过onSaveInstanceState和onRestoreInstanceState方法来储存和恢复数据，如果一个进程没有四大组件在执行，那么这个进程很快会被系统杀死，因此一些后台工作不适合脱离四大组件而独自运行在后台中，这样进程很容易被杀死，好的做法是将后台工作放入Service中从而保证进程有一定的优先级，这样就不会轻易地被系统杀死。

### 常见问题

1. 问：onStart和onResume、onPause和onStrop从描述上来看差不多，对我们来说有什么实质的不同？

   答：onStart和onStop是从Activity是否可见这个角度来回掉的，onResume和onPause是从Activity是否位于前台这个角度来回调的，除此区别外，没有任何区别。

2. 问：假设当前在Activity A，如果这时候用户打开一个新的Activity B，那么B的onResume和A的onPause哪个先执行？

   答：在Activity Stack中，栈顶的Activity A会先执行onPause，新的Activity才能启动，执行B的onResume。

## Activity的启动模式

### Activity的任务栈

当我们多次启动同一个Activity的时候，系统会创建多个实例并把它们一一压入任务栈，当我们单击back键，会发现这些Activity会一一从任务栈中弹出，如果任务栈中没有Activity存在，系统就会回收这个任务栈。但是，多次启动同一个Activity,系统重复创建多个实例，这样不是很傻吗？这样的确点傻，Android在设计的时候不可能不考虑到这个问题，所以它提供了启动模式来修改系统的默认行为。目前有四种启动模式：standard、singleTop、singleTask和singleInstance。

### Activity的LaunchMode

1. Standard：标准模式，也是系统Activity的默认模式，每次启动一个Activity都会重新创建一个新的实例，不管这个实例是否已经存在，这是一种典型的多实例实现，一个任务栈可以有多个实例，每个实例也可以属于不同的任务栈。在这种模式下，谁启动了这个Activity，那么这个Activity就运行在启动它的那个Activity所在的栈，比如Activity A启动了Activity B(Standard模式)，那么B就会进入A所在的栈中。
2. singleTop：栈顶复用模式，如果新Activity已经位于任务栈的栈顶，那么此Activity不会被重新创建，同时它的onNewIntent方法会被回调，这个Activity的onCreate、onStart不会被系统调用，因为它并没有发生改变；如果新Activity的实例已经存在但不位于栈顶，那么新Activity仍然会重新重建。
3. singleTask：栈内复用模式，这是一种单实例模式，在这种模式下，只要Activity在一个栈中存在，那么多次启动此Activity都不会重新创建实例，和singgleTop一样，系统也会回调其onNewIntent，当一个singleTask的Activity请求启动后，比如Activity A，系统会首先寻找是否存在A想要的任务栈，如果不存在，就重新创建一个任务栈，然后创建A的实例后把A放到栈中，如果存在A所需的任务栈，这时要看A是否在栈中有实例存在，如果有实例存在，系统会 把A调到栈顶并调用其onNewIntent方法，如果实例不存在，就创建A的实例并把A压入栈中。举例，任务栈S1中为ABC，这个时候D以singleTask模式请求启动，其所需要的任务栈为S2,由于S2和D的实例都不存在，所以系统会先创建S2，然后再创建D的实例并将其压入栈S2；如果D所需要的任务栈为S1，由于任务栈S1存在，系统会直接创建D的实例并将其压入栈S1。
4. singleInstance：单实例模式，这是一种加强的singleTask模式，它除了具有singleTask模式的所有特性外，还加强了一点，就是具有此模式的Activity只能单独地位于一个任务栈中，换句话说，比如Activity A是singleInstance模式，当A启动后，系统会为它创建一个新的任务栈，然后A独自在这个新的任务栈中，由于栈内复用的特性，后续的请求均不会创建新的Activity,除非这个独特的任务栈被系统销毁了。

### Activity的Flags

Activity的Flags有很多，主要分析常用的标记位Flags：

1. 影响Activity的启动模式：

   * FLAG_ACTIVITY_NEW_TASK: 指定Activity的启动模式为singleTask与在AndroidManifest.xml中指定效果一致
   * FLAG_ACTIVITY_SINGLE_TOP: 指定Activity的启动模式为singleTop与在AndroidManifest.xml中指定效果一致

2. 影响Activity的运行状态：

   * FLAG_ACTIVITY_CLEAR_TOP: 与FLAG_ACTIVITY_NEW_TASK配合使用，将栈中存在的Activity提升到顶，并Activity之上的Activity全部出栈，singleTask启动模式默认具有该标记

   * FLAG_ACTIVITY_EXCLUDED_FROM_RECENTS: 具有该标记的Activity不会出现历史Activity的列表中，当某些情况下我们不希望用户通过历史列表回到我们的Activity的时候比较有用，与在AndroidManifest.xml中指定Activity的属性android:excludeFromRecents="true"

### Activity的taskAffinity

taskAffinity表示Activity倾向于属于哪个任务栈，默认情况下，同一app中所有Activity彼此具有亲和性，因此在默认情况下，同一APP中所有Activity都倾向于同一任务栈，不过可以修改Activity的taskAffinity来修改Activity的亲和性。

亲和性在两种情况下发挥作用：

1. 当Activity启动的intetn包含flag为FLAG_ACTIVITY_NEW_TASK：

   默认情况下，新 Activity 会启动到调用 `startActivity()` 的 Activity 的任务栈中。它会被推送到调用方 Activity 所在的返回堆栈中。但是，如果传递给 `startActivity()` 的 intent 包含 `FLAG_ACTIVITY_NEW_TASK` 标记，则系统会寻找其他任务来容纳新 Activity。通常会是一个新任务，但也可能不是。如果已存在与新 Activity 具有相同亲和性的现有任务，则会将 Activity 启动到该任务中。如果不存在，则会启动一个新任务栈。

2. 当Activity的allowTaskReparenting属性为true时：

   在这种情况下，一旦和 Activity 有亲和性的任务进入前台运行，Activity 就可从其启动的任务转移到该任务。

   举例来说，一般都是其他APP的Activity调用本APP的Activity，假设一款旅行应用中定义了一个报告特定城市天气状况的 Activity。该 Activity 与同一应用中的其他 Activity 具有相同的亲和性（默认应用亲和性），并通过此属性支持重新归属。当您的某个 Activity 启动该天气预报 Activity 时，该天气预报 Activity 最初会和您的 Activity 同属于一个任务。不过，当旅行应用的任务进入前台运行时，该天气预报 Activity 就会被重新分配给该任务并显示在其中。

### 常见问题

1. 问：startActivity报错`android.util.AndroidRuntimeException: Calling startActivity() from outside of an Activity`

   答：standard模式下的Activity默认会进入启动它的Activity所属的任务栈中，但是由于非Activity类型的Context(ApplicationContext)并没有所谓的任务栈，所以就有问题，会抛出异常捕获，解决这个问题就是给待启动的Activity指定FLAG_ACTIVITY_NEW_TASK FLAG，以singleTask模式启动

   ```java
   intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
   ```

2. 问：当前Activity的任务栈的情况为ABCD，其中A位于栈底，D位于栈顶，D的启动模式为standard和singleTop，任务栈会的变化？

   答：standard：ABCDD、singleTop：ABCD

3. 问：当前任务栈S1的情况为ADBC，启动singleTask的Activity D，任务栈的变化？

   答：根据栈内复用的原则，D不会重新创建，系统会把D切换到栈顶并调用其onNewIntent方法，同时singleTask具有默认的**clearTop**效果，会导致D之上的Activity全部出栈，于是最终S1中的栈内情况应该为AD。

## Activity的调用方式

启动Activity的intent分为两种：

1. 显示调用

   通过Intent调用组件时，可以直接指定组件类，这种方式称为显式调用

   ```java
   Intent intent = new Intent(LoginActivity.this, HomeActivity.class);
   startActivity(intent);
   ```

2. 隐式调用

   隐式调用需要Intent能够匹配目标组件的IntentFilter中设置过滤信息，如果不匹配将无法启动目标Activity

   ```java
   Intent intent = new Intent();
   intent.setAction("com.practise.salary.hello.CALL");
   intent.addCategory("com.practise.salary.hell.VIEW");
   startActivity(intent);
   ```

3. IntentFilter

   IntentFilter中的过滤信息有action、category、data

   ```xml
   <activity
   		android:name="com.ryg.chapter_1.ThirdActivity" android:configChanges="screenLayout" 				android:label="@string/app_name" android:launchMode="singleTask"
   		android:taskAffinity="com.ryg.task1">
   		<intent-filter>
         		<action android:name="com.ryg.charpter_1.c"/>
         		<action android:name="com.ryg.charpter_1.d"/>
         		<category android:name="com.ryg.category.c"/>
         		<category android:name="com.ryg.category.d"/>
         		<category android:name="android.intent.category.DEFAULT"/>
         		<data android:mimeType="text/plain"/>
     	</intent-filter>
   </activity>
   ```