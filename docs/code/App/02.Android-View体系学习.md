# Android-View体系学习

## View基础知识

### View概述

View是Android中所有控件的基类，不管是简单的Button和TextView还是复杂的RelativeLayout和ListView，它们的共同基类都是View，所以说，View是一种界面层的控件的一种抽象，它代表了一个控件，除去View外，还有ViewGroup，从名字来看，ViewGroup可以被翻译为控件组，言外之意是ViewGroup内部包含了许多个控件，即一组View，在Android设计中，ViewGroup也继承自View，这就意味着View本身就可以是单个控件，也可以是由多个控件组成的一组控件。

### View和ViewGroup

View和ViewGroup：

* View是所有UI组件的基类
* ViewGroup是容纳这些UI组件的容器，其本身也是从View派生出来的

Android UI布局的树状结构：

![img](https://s2.loli.net/2022/08/02/QY1OTy9MJjGNwZo.png)

### View的位置参数

View的位置主要由它的四个顶点来决定，分别对应于View的四个属性：top、left、right、bottom，其中top是左上角纵坐标，left是左上角横坐标，right是右下角横坐标，bottom是右下角纵坐标，需要注意的是，这些坐标都是View相对于父容器的相对坐标。具体如下图：

![View的位置坐标和父容器的关系](https://s2.loli.net/2022/08/02/FXmpw7Tn9xSVqsY.png)

View还有额外的几个参数：x、y、translationX和translationY，其中x和y是View左上角的坐标，而translationX和translationY是View左上角相对于父容器的偏移量。

```java
getLeft(); //获取left
getTop(); //获取top
getRight(); //获取right
getBottom(); //获取bottom
width = getRight() - getLeft(); //获取width
height = getBottom() - getTop(); //获取height
x = getLeft() + translationX; //x,left,translationX
y = getTop() + translationY; //y,top,translationY
```

### MotionEvent和TouchSlop

1. MotionEvent是指在手指接触屏幕后所产生的一系列事件中，典型的事件类型有如下几种：

* ACTION_DOWN: 手指刚接触屏幕；
* ACTION_MOVE: 手指在屏幕上移动；
* ACTION_UP: 手机从屏幕上松开的一瞬间；

正常情况下，一次手指触摸屏幕的行为会触发一系列点击事件，考虑如下几种情况：

* 点击屏幕后离开松开，事件序列为DOWN -> UP;
* 点击屏幕滑动一会再松开，事件序列为DOWN -> MOVE -> … -> MOVE ->UP;

通过MotionEvent对象我们可以得到点击事件触发时的x和y坐标，系统提供了两组方法: getX/getY和getRawX/getRawY，它们的区别很简单，getX/getY返回的是相对于当前View左上角的x和y坐标，getRawX/getRawY返回的是相对于手机屏幕左上角的x和y坐标。

2. TouchSlop是指系统所能识别出的被认为是滑动的最小距离，换句话说，当手指在屏幕上滑动时，如果两次滑动之间的距离小于这个常量，那么系统就不认为你是在进行滑动操作，可以提高用户体验。

```java
ViewConfiguration.get(getContext()).getScaledTouchSlop();
```

### VelocityTracker、GestureDetector和Scroller

1. VelocityTracker

   VelocityTracker是指速度追踪，用于追踪手指在滑动过程中的速度，包括水平和竖直方向的速度，它的使用过程很简单：

   ```java
   //获取当前点击事件的速度
   VelocityTracker velocityTracker = VelocityTracker.obtain();
   velocityTracker.addMovement(event);
   //获取当前的速度
   velocityTracker.computeCurrentVelocity(1000);
   int xVelocity = (int) velocityTracker.getXVelocity();
   int yVelocity = (int) velocityTracker.getYVelocity();
   //重置并回收
   velocityTracker.clear();
   velocityTracker.recycle();
   ```

2. GestureDetector

   GestureDetector是指手势检测，用于辅助检测用户的单击、滑动、长按、双击等行为：

   ```java
   //0.创建GestureDetector对象并实现OnGestureListener接口
   GestureDetector mGestureDetector = new GestureDetector(this);
   //1.解决长按屏幕后无法拖动的现象
   mGestureDetector.setIsLongpressEnabled(false);
   //2.接管目标View的onTouchEvent方法，在待监听View的onTouchEvent事件
   boolean consume = mGestureDetector.onTouchEvent(event);
   return consume;
   //3. 之后就可以有选择地实现OnGestureListener和OnDoubleTapListener中方法
   //OnGestureListener接口
   onDown； //手指轻轻触摸屏幕的瞬间
   onShowPress; //手指轻轻触摸屏幕，尚未松开或拖动
   onSingleTapUp; //手指松开的瞬间，双击会触发两次
   onScroll; //手指按下屏幕并拖动
   onLongPress; //用户长久地按着屏幕不放，即长按
   onFling; //用户按下触摸屏、快速滑动后松开，快速滑动行为
   //OnDoubleTapListener接口
   onDoubleTap; //双击
   onSingleTapConfirmed; //严格地单击行为，不能是双击中的一次单击
   onDoubleTapEvent; //发生了双击事件，在双击期间，DOWN\MOVE\UP都会触发此回调
   ```

3. Scroller

   Scroller是指弹性滑动对象，用于实现View的弹性滑动，当使用scrollTo/scrollBy方法来进行滑动时，过程都是瞬间完成的，没有过度效果的方式是用户体验不好的，使用Scroller可以妥善解决这个问题

   ```java
   Scroller scroller = new Scroller(mContext);
   // 缓慢滚动到指定位置
   private void smoothScrollTo(int destX,int destY) {
     int scrollX = getScrollX(); 
     int delta = destX -scrollX; 
     // 1000ms内滑向destX，效果就是慢慢滑动
     mScroller.startScroll(scrollX,0,delta,0,1000); 
     invalidate();
   	} 
   @Override 
   public void computeScroll() {
   	if (mScroller.computeScrollOffset()) { 
     	scrollTo(mScroller.getCurrX(),mScroller.getCurrY());
     	postInvalidate();
   		}
   	}
   ```

## View的事件分发机制

### 事件分发的三个阶段

点击事件的分发过程中，我们主要接触的是ViewGroup和View两种视图类型，一次完整的事件分发过程会包括三个阶段，即事件的**发布**、**拦截**和**消费**，这三个过程分别对应声明在View和ViewGroup中的三个方法：

1. 发布

   ```java
   public boolean dispatchTouchEvent(MotionEvent ev)
   ```

   Android中的视图(View、ViewGroup、Activity等)接收到的触摸事件都是通过这个方法进行分发的，如果事件能够传递给当前视图，则此方法一定会被调用，即视图接收到的触摸事件都需要通过该方法来进行分发，该方法的返回值用于表明该视图或者内嵌视图是否消费了该事件，如果当前视图类型是ViewGroup，该方法内部调用`onInterceptTouchEvent(MotionEvent ev)`方法来判断是否拦截该事件。

2. 拦截

   ```java
   public boolean onInterceptTouchEvent(MotionEvent ev)
   ```

   ViewGroup包含该方法，View中不存在，该方法通过返回值来标明是否需要拦截对应的事件，返回true则表示拦截这个事件，不继续发布给子视图，并将事件交由自身的`onTouchEvent(MotionEvent ev)`方法来进行处理，返回false则表示不拦截事件，继续传递给子视图，如果ViewGroup拦截了某个事件，那么在同一个事件序列当中，此方法不会被再次调用。

3. 消费

   ```java
   public boolean onTouchEvent(MotionEvent ev) 
   ```

   该方法返回true表示当前视图已经处理对应的事件，事件将在这里完成消费，终止传递，返回false表示当前视图不处理这个事件，事件会被传递给其他视图。

### 事件分发的传递规则

ViewGroup完整包含**发布**、**拦截**和**消费**三个过程，而View只包含**发布**和**消费**两个过程，即View类不包含`onInterceptTouchEvent(MotionEvent ev)`方法，三个方法之间的联系可以用如下伪代码表示：

```java
public boolean dispatchTouchEvent(MotionEvent ev) { //0.先判断dispatchTouchEvent
  boolean consume = false;
  if (onInterceptTouchEvent(ev)) {  //1.1.如果被onInterceptTouchEvent拦截
    consume = onTouchEvent(ev); //2.a.当前View消费
  } else { //1.2.如果没被onInterceptTouchEvent拦截
    consume = child.dispatchTouchEvent(ev);  //2.b.传递到子View的dispatchTouchEvent事件
  } 
  return consume;
}
```

当触摸事件发生时，事件分发流程会按照如下执行：

1. 根ViewGroup最先接收到MotionEvent，其dispatchTouchEvent方法会被调用，该方法内部会调用onInterceptTouchEvent方法来判断是否要拦截事件；
2. ViewGroup的onInterceptTouchEvent方法如果返回true，则表示当前ViewGroup要拦截事件，否则就会去调用child(内嵌的ViewGroup或者是View)重复分发过程；
3. View和ViewGroup的onTouchEvent方法用来判断是否要消费该事件，如果返回true则表示事件已被消费，终止传递。

### Activity、ViewGroup和View的事件分发规则总结

1. Activity会早于各个ViewGroup和View接收到触摸事件，Activity可以通过主动拦截掉各个事件的下发使得ViewGroup和View接收不到任何事件，而如果ViewGroup和View接收到了ACTION_DOWN事件但没有消费掉，那么事件最终还是会交由Activity来消费；

2. 当触摸事件被触发时，系统会根据触摸点的坐标系找到根ViewGroup，然后向底层View下发事件，即事件分发流程先是从根 ViewGroup从上往下（从外向内）向内嵌的底层View传递的，如果在这个过程中事件没有被消费的话，最终又会反向传递从下往上（从内向外）进行传递；

3. ViewGroup 在接收到 ACTION_DOWN 事件时，其 dispatchTouchEvent 方法内部会先调用 onInterceptTouchEvent 判断是否要进行拦截，如果 onInterceptTouchEvent 方法返回了 false，则意味着其不打算拦截该事件，那么就会继续调用 child 的 dispatchTouchEvent 方法，继续重复以上步骤。如果拦截了，那么就会调用 onTouchEvent 进行消费；

4. 如果 ViewGroup 自身拦截且消费了 ACTION_DOWN 事件，那么本次事件序列的后续事件就会都交由其进行处理（如果能接收得到的话），不会再调用其 onInterceptTouchEvent 方法来判断是否进行拦截，也不会再次遍历 child，dispatchTouchEvent 方法会直接调用 onTouchEvent 方法。这是为了尽量避免无效操作，提高系统的绘制效率

5. 如果根 ViewGroup 和内嵌的所有 ViewGroup 均没有拦截 ACTION_DOWN 事件的话，那么事件通过循环传递就会分发给最底层的 View。对于 View 来说，其不包含 onInterceptTouchEvent 方法，dispatchTouchEvent 方法会调用其 onTouchEvent 方法来决定是否消费该事件。如果返回 false，则意味着其不打算消费该事件，事件将依次调用父容器的 onTouchEvent 方法；返回 true 的话则意味着事件被其消费了，事件终止传递

6. 而不管 ViewGroup 有没有拦截 ACTION_DOWN 事件，只要其本身和所有 child 均没有消费掉 ACTION_DOWN 事件，即 dispatchTouchEvent 方法返回了 false，那么此 ViewGroup 就不会再接收到后续事件，后续事件会被 Activity 直接消化掉

7. 而不管是 ViewGroup 还是 View，只要其消费了 ACTION_DOWN 事件，即使 onTouchEvent 方法在处理每个后续事件时均返回了 false，都还是可以完整接收到整个事件序列的消息。后续事件会根据在在处理 ACTION_DOWN 事件保留的引用链，从上往下依次下发

8. View 是否能接收到整个事件序列的消息主要就取决于其是否消费了 ACTION_DOWN 事件，ACTION_DOWN 事件是整个事件序列的起始点，View 必须消耗了起始事件才有机会完整处理整个事件序列

9. 处于上游的 ViewGroup 不关心到底是下游的哪个 ViewGroup 或者 View 消费了触摸事件，只要下游的 dispatchTouchEvent 方法返回了 true，上游就会继续向下游下发后续事件

10. ViewGroup 和 View 对于每次事件序列的消费过程是独立的，即上一次事件序列的消费结果不影响新一次的事件序列




## View的工作原理

### 概述

View是Android在视觉上的呈现，在界面上Android提供了一套GUI库，里面有很多控件，但是很多时候（应用界面的同质化严重）我们并不满足于系统提供的控件，这样就需要创建自定义View，为了更好地自定义View，就需要掌握View的底层工作原理，比如View的测量流程(measure)、布局流程(layout)和绘制(draw)流程。

### ViewRoot和DecorView解析

#### ViewRoot

ViewRoot对应于ViewRootImpl类，它是连接WindowManager和DecorView的纽带，View的三大流程均是通过ViewRoot来完成的，在ActivityThread中，当Activity对象被创建完毕后，会将DecorView添加到Window中，同时会创建ViewRootImpl对象，并将ViewRootImpl对象和DecorView建立关联：

```java
root = new ViewRootImpl(view.getContext(), display);
root.setView(view, wparams, panelParentView);
```

View的绘制流程是从ViewRoot的performTraversals方法开始的，它经过measure、layout和draw三个过程才能最终将一个View绘制出来，其中measure是用来测量View的宽和高，layout是用来确定View在父容器中的放置位置，而draw则负责将View绘制在屏幕上，大致如图：

![perfomTraversals的工作流程图](https://s2.loli.net/2022/08/01/OzqBms3fEh2xivj.png)

如图所示，performTraversals会依次调用performMeasure、performLayout和performDraw三个方法，这三个方法分别完成顶级View的measure、layout和draw这三大流程，其中在performMeasure中会调用measure方法，在measure方法中又会调用onMeasure方法，在onMeasure方法中则会对所有的子元素进行measure过程，这个时候measure流程就从父容器传递到子元素中了，这样就能完成一次measure过程，接着子元素会重复父容器的measure过程，如此反复就完成了整个View树的遍历。同理，performLayout和performDraw的传递流程和performMeasure是类似的，唯一不同的是，performDraw的传递过程是在draw方法中通过dispatchDraw来实现的，不过并没有本质区别。

* measure过程决定了View的宽/高，Measure完成以后，可以通过getMeasuredWidth和getMeasuredHeight方法来获取到View测量后的宽/高，在几乎所有的情况下它都等同于View最终的宽/高，但是特殊情况下除外；
* layout过程决定了View的四个顶点的坐标和实际的View的宽/高，完成以后，可以通过getTop、getBottom、getLeft和getRight来拿到View的四个顶点的位置，并可以通过getWidth和getHeight方法来拿到View的最终宽/高；
* draw过程则决定了View的显示，只有draw方法完成以后View的内容才能呈现在屏幕上。

#### DecorView

![DecorView结构](https://s2.loli.net/2022/08/01/M72rfoUQFbl8OYj.png)

如图所示，DecorView作为顶级View，一般情况下它内部会包含一个竖直方向的LinearLayout，在这个LinearLayout里面有上下两个部分，上面是标题栏，下面是内容栏，在Activity中我们通过setContentView所设置的布局文件其实就是被加到内容栏之中的，而内容栏的id是content，因此可以理解为Activity指定布局的方法不叫setView而是叫setContentView，因为我们的布局的确加到了id位content的FrameLayout中，如何得到content呢

```java
ViewGroup content = findViewById(R.android.id.content);
View view = content.getChildAt(0);
```

通过源码可以知道，DecorView其实是一个FrameLayout，View层的事件都经过DecorView，然后再传递到我们自己的View。

### MeasureSpec的理解

MeasureSpec代表一个32位int值，高2位代表SpecMode，低30位代表SpecSize，SpecMode是指测量模式，而SpecSize是指在某种测量模式下的规格大小：

```java
private static final int MODE_SHIFT = 30; 
private static final int MODE_MASK = 0x3 << MODE_SHIFT; 
public static final int UNSPECIFIED = 0 << MODE_SHIFT; 
public static final int EXACTLY = 1 << MODE_SHIFT; 
public static final int AT_MOST = 2 << MODE_SHIFT; 
	public static int makeMeasureSpec(int size,int mode) {
    if (sUseBrokenMakeMeasureSpec) { 
      return size + mode;
    } else {
      return (size & ~MODE_MASK) | (mode & MODE_MASK); 
    }
  } 
	
	public static int getMode(int measureSpec) {
    return (measureSpec & MODE_MASK); 
  } 

	public static int getSize(int measureSpec) {
    return (measureSpec & ~MODE_MASK); 
  }
```

MeasureSpec通过将SpecMode和SpecSize打包成一个int值来避免过多的对象内存分配，为了方便操作，其提供了打包和解包方法，SpecMode和SpecSize也是一个int值，一组SpecMode和SpecSize可以打包为一个MeasureSpec，而一个MeasureSpec可以通过解包的形式来得出其原始的SpecMode和SpecSize，需要注意的是这里提到的MeasureSpec是指MeasureSpec所代表的int值，而并非MeasureSpec本身。

SpecMode有三类：

* UNSPECIFIED: 父容器不对View有任何限制，要多大给多大，这种情况一般用于系统内部，表示一种测量的状态；
* EXACTLY: 父容器已经检测出View所需要的精确大小，这个时候View的最终大小就是SpecSize所指定的值，它对应于LayoutParams中的match_parent和具体数值的这两种模式；
* AT_MOST: 父容器指定了一个可用大小即SpecSize，View的大小不能大于这个值，具体是什么值要看不同View的具体实现，它对应于LayoutParams中的wrap_content。

### View工作流程

View的工作流程是指measure、layout、draw这三大流程，即测量、布局和绘制，其中measure确定View的测量宽/高，layout确定View的最终宽/高和四个顶点的位置，而draw则将View绘制到屏幕上。

#### measure过程

1. View的measure过程

View的measure过程由其measure方法来完成，measure方法是一个final类型的方法，这意味着子类不能重写此方法，在View的measure方法中会去调用View的onMeasure方法，因此只需要看onMeasure方法的实现即可，View的onMeasure方法如下所示：

```java
protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec) {
  setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(),widthMeasureSpec),getDe }
```

上述代码很简洁，但是简洁并不代表简单，setMeasuredDimension方法会设置View宽/高的测量值，因此我们只需要看getDefaultSize方法即可：

```java
public static int getDefaultSize(int size,int measureSpec) { 
  int result = size; 
  int specMode = MeasureSpec.getMode(measureSpec); 
  int specSize = MeasureSpec.getSize(measureSpec); 
  switch (specMode) {
    case MeasureSpec.UNSPECIFIED:
      result = size;
      break; 
    case MeasureSpec.AT_MOST: 
    case MeasureSpec.EXACTLY:
      result = specSize;
      break;
  }
  return result;
}
```

可以看出，getDefaultSize这个方法的逻辑很简单，对于我们来说，我们只要看AT_MOST和EXACTLY这两种情况，简单地理解，其实getDefaultSize返回的大小就是measureSpec中的specSize，而这个specSize就是View测量后的大小，这里多次提到测量后的大小，是因为View最终的大小是在layout阶段确定的，所以这里必须要加以区分，但是几乎所有情况下View的测量大小和最终大小是相等的。

至于UNSPECIFIED这种情况，一般用于系统内部的测量过程，在这种情况下，View的大小为getDefaultSize的第一个参数size，即宽/高分别为getSuggestedMinimumWidth和getSuggestedMinimunHeight这两个方法的返回值，看一下它们的源码：

```java
protected int getSuggestedMinimumWidth() { 
  return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth()); 
} 
                                                 
protected int getSuggestedMinimumHeight() {
  return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeigh()); 
}
```

2. ViewGroup的measure过程

对于ViewGroup来说，除了完成自己的measure过程以外，还会遍历去调用所有子元素的measure方法，各个子元素再递归去执行这个过程，和View不同的是，ViewGroup是一个抽象类，因此没有重写View的onMeasure方法，但是它提供了一个叫measureChildren的方法：

```java
protected void measureChildren(int widthMeasureSpec,int heightMeasureSpec) { 
  final int size = mChildrenCount; 
  final View[] children = mChildren;
  for (int i = 0; i < size; ++i) {
    final View child = children[i];
    if ((child.mViewFlags & VISIBILITY_MASK) != GONE) {
      measureChild(child,widthMeasureSpec,heightMeasureSpec); 
    }
  }
}
```

从源码来看，ViewGroup在measure时，会对每一个子元素进行measure，measureChild这个方法的实现也很好理解：

```java
protected void measureChild(View child,int parentWidthMeasureSpec, int parentHeightMeasureSpec) { 
  final LayoutParams lp = child.getLayoutParams();
  final int childWidthMeasureSpec = getChildMeasureSpec(parentWidth-MeasureSpec, mPaddingLeft + mPaddingRight,lp.width); 
  final int childHeightMeasureSpec = getChildMeasureSpec(parentHeight-MeasureSpec, mPaddingTop + mPaddingBottom,lp.height); child.measure(childWidthMeasureSpec,childHeightMeasureSpec);
}
```

显然，measureChild的思想就是取出子元素的LayoutParams，然后再通过getChildMeasureSpec来创建子元素的MeasureSpec，接着将MeasureSpec直接传递给View的measure方法来进行测量，getChildMeasureSpec的工作过程已经在上面进行了详细分析。

#### layout过程

layout的作用是ViewGroup用来确定子元素的位置，当ViewGroup的位置被确定后，它在onLayout中会遍历所有的子元素并调用其layout方法，在layout方法中onLayout方法又会被调用，layout过程和measure过程相比就简单多了，layout方法确定View本身的位置，而onLayout方法则会确定所有子元素的位置，先看View的layout方法：

```java
public void layout(int l,int t,int r,int b) {
  if ((mPrivateFlags3 & PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) {
    onMeasure(mOldWidthMeasureSpec,mOldHeightMeasureSpec);
    mPrivateFlags3 &= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
  } 
  int oldL = mLeft; 
  int oldT = mTop; 
  int oldB = mBottom; 
  int oldR = mRight; 
  boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l,t,r,b) : setFrame(l,t,r,b); 
  if (changed || (mPrivateFlags & PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) { 
    onLayout(changed,l,t,r,b);
    mPrivateFlags &= ~PFLAG_LAYOUT_REQUIRED;
    ListenerInfo li = mListenerInfo; 
    if (li != null && li.mOnLayoutChangeListeners != null) {
      ArrayList<OnLayoutChangeListener> listenersCopy = 
        (ArrayList<OnLayoutChangeListener>)li.mOnLayout-Change
      int numListeners = listenersCopy.size();
      for (int i = 0; i < numListeners; ++i) {
        listenersCopy.get(i).onLayoutChange(this,l,t,r,b,oldL,oldT,old
      }
    }
  }
     mPrivateFlags &= ~PFLAG_FORCE_LAYOUT;
     mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;
}
```

layout方法的大致流程如下：首先会通过setFrame方法来设定View的四个顶点的位置，即初始化mLeft、mRight、mTop和mBottom这四个值，View的四个顶点一旦确定，那么View在父容器中的位置也就确定了；接着会调用onLayout方法，这个方法的用途是父容器确定子元素的位置，和onMeasure方法类似，onLayout的具体实现同样和具体的布局有关，所以View和ViewGroup均没有真正实现onLayout方法

#### draw过程

draw过程就比较简单了，它的作用是将View绘制到屏幕上面，View的绘制过程遵循如下几步：

1. 绘制背景background.draw(canvas)
2. 绘制自己(onDraw)
3. 绘制children(dispatchDraw)
4. 绘制装饰(onDrawScrollBars)

通过draw方法源码可以明显看出来：

```java
public void draw(Canvas canvas) {
  final int privateFlags = mPrivateFlags; 
  final boolean dirtyOpaque = 
    (privateFlags & PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE && (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); 
  mPrivateFlags = (privateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; 
  /* 
  * Draw traversal performs several drawing steps which must be executed
  * in the appropriate order:
  * 
  * 1. Draw the background 
  * 2. If necessary,save the canvas' layers to prepare for fading 
  * 3. Draw view's content 
  * 4. Draw children 
  * 5. If necessary,draw the fading edges and restore layers 
  * 6. Draw decorations (scrollbars for instance) 
  
  */
  // Step 1,draw the background,if needed 
  int saveCount; if (!dirtyOpaque) {
    drawBackground(canvas);
  } 
  // skip step 2 & 5 if possible (common case) 
  final int viewFlags = mViewFlags; 
  boolean horizontalEdges = (viewFlags & FADING_EDGE_HORIZONTAL) != 0; 
  boolean verticalEdges = (viewFlags & FADING_EDGE_VERTICAL) != 0; 
  if (!verticalEdges && !horizontalEdges) {
    // Step 3,draw the content
    if (!dirtyOpaque) onDraw(canvas);
    // Step 4,draw the children
    dispatchDraw(canvas);
    // Step 6,draw decorations (scrollbars)
    onDrawScrollBars(canvas);
    if (mOverlay != null && !mOverlay.isEmpty()) {
      mOverlay.getOverlayView().dispatchDraw(canvas);
    }
    // we're done...
    return;
  }
  ...
}
```

View绘制过程的传递是通过dispatchDraw来实现的，dispatchDraw会遍历调用所有子元素的draw方法，如此draw事件就一层层地传递下去，View有一个特殊的方法setWillNotDraw：

```java
/** 
* If this view doesn't do any drawing on its own,set this flag to 
* allow further optimizations. By default,this flag is not set on 
* View,but could be set on some View subclasses such as ViewGroup.
* 
* Typically,if you override {@link #onDraw(android.graphics.Canvas)} 
* you should clear this flag.
* 
* @param willNotDraw whether or not this View draw on its own 
*/ 
public void setWillNotDraw(boolean willNotDraw) { 
  setFlags(willNotDraw ? WILL_NOT_DRAW : 0,DRAW_MASK); 
}
```

### 自定义View

#### 自定义View的分类

1. 继承View重写onDraw方法

   这种方法主要用于实现一些不规则的效果，即这种效果不方便通过布局的组合方式来达到，往往需要静态或者动态地显示一些不规则的图形，很显然这需要通过绘制的方式来实现，即重写onDraw方法，采用这种方式需要自己支持wrap_content，并且padding也需要自己处理。

2. 继承ViewGroup派生特殊的Layout

   这种方法主要用于实现自定义的布局，即除了LinearLayout、RelativeLayout、FrameLayout这几种系统的布局之外，我们重新定义一种新布局，当某种效果看起来很像几种View组合在一起的时候，可以采用这种方法来实现，采用这种方式稍微复杂一些，需要合适地处理ViewGroup的测量和布局这两个过程，并同时处理子元素的测量和布局过程。

3. 继承特定的View(比如TextView)

   这种方法比较常见，一般是用于扩展某种已有的View的功能，比如TextView，这种方式比较容易实现，这种方法不需要自己支持wrap_content和padding等。

4. 继承特定的ViewGroup(比如LinearLayout)

   这种方法也比较常见，当某种效果看起来很像几种View组合在一起的时候，可以采用这种方法来实现，采用这种方法不需要自己处理ViewGroup的测量和布局这两个过程，需要注意这种方法和方法2的区别，一般来说方法2能够实现的效果方法4也能实现，两者的主要区别在于方法2更接近于View的底层。

#### 自定义View须知

1. 让View支持wrap_content

   这是因为直接继承View或者ViewGroup的控件，如果不在onMeasure中对wrap_content做特殊处理，那么当外界在布局中使用wrap_content时就无法达到预期的效果。

2. 如果有必要，让你的View支持padding

   这是因为直接继承View的控件，如果不在draw方法中处理padding，那么padding属性是无法起作用的，另外，直接继承自ViewGroup的控件需要在onMeasure和onLayout中考虑padding和子元素的margin对其造成的影响，不然将导致padding和子元素的margin失效。

3. 尽量不要在View中使用Handler，没有必要

   因为View内部本身就提供了post系列方法，完全可以替代Handler的作用，当然除非你很明确地使用Handler来发送消息。

4. View中如果有线程或者动画，需要及时停止，参考View#onDetachedFromWindow

   如果有线程或者动画需要停止，那么onDetachedFromWindow是一个很好的时机，当包含此View的Activity退出或者当前View被remove时，View的onDetachedFromWindow方法会被调用，和此方法对应的是onAttachedToWindow，当包含此View的Activity启动时，View的onAttachedToWindow方法会被调用，同时，当View变得不可见时我们也需要停止线程或者动画，如果不及时处理这种问题，有可能造成内存泄漏。

5. View带有滑动嵌套情形时，需要处理好滑动冲突

​	如果有滑动冲突的话，那么要合适地处理滑动冲突，否则将严重影响View的效果。