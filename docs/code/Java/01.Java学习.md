# Java学习

## 1. Java基础概念与知识

### 1.1 Java语言特点

1. 简单易学；

2. 面向对象(封装、继承、多态) ；
3. 平台无关性(JVM实现) ；
4. 可靠性 ；
5. 安全性 ；
6. 支持多线程； 
7. 支持网络编程而且很方便； 
8. 编译与解释并存。

### 1.2 JVM、JDK和JRE

JVM(Java Virtual Machine)：Java虚拟机运行Java字节码的虚拟机；

JDK(Java Development Kit)：Java开发工具，能够创建和编译程序；

JRE(Java Runtime Environment)：Java运行环境，运行已编译Java程序所需内容的集合。

JRE是Java运行时候的环境，是运行已编译Java程序所需要所有内容，包括JVM，Java类库，Java命令和其他的一些基础构件；

JDK是功能齐全的SDK，他拥有JRE拥有的一切，还包括编译器(javac)和工具(如javadoc和jdb)

Java程序从源代码到运行一般分为以下三步：

### 1.3 Java和C++的区别

1. 都是面向对象的语言，都支持封装、继承和多态；
2. Java不提供指针来直接访问内存，程序内存更加安全；
3. Java的类是单继承的，C++支持多重继承；
4. Java的类是不可以多继承，但是Java的接口可以多继承；
5. Java有自动内存管理机制，不需要程序员手动释放无用内存；
6. C语言中，字符串或字符数组最后都有'\o'字符来表示结束，但是Java却没有。

### 1.4 Java程序的主类 应用程序和小程序的主类有何不同

1. 一个程序有多个类，但只能有一个类是主类，Java程序的主类是指包含main()方法的类；
2. Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类；
3. 应用程序的主类不一定要求是public类，但小程序的主类必须是public类；
4. 主类是Java程序执行的入口点。

### 1.5 Java应用程序与小程序之间有哪些差别

1. 应用程序是从主线程启动(也就是main()方法)；
2. applet小程序没有main()方法，主要是嵌在浏览器页面上运行(调用init()或者run()来启动)。

### 1.6 java和javax的区别

1. 实际上java和javax没有区别，这都是一个名字；
2. 刚开始，JavaAPI所必需的包是java开头的包，javax只是作为API扩展包，现在javax已经扩展为JavaAPI的组成部分。

### 1.7 为什么说Java语言“编译与解释并存”

1. Java语言既具有编译型语言的特征，也具有解释型语言的特征；
2. Java程序需要经过先编译后解释两个步骤，先编译生成字节码(*.class)，再由Java解释器解释。

## 2. Java基本语法

### 2.1 字符型常量和字符串常量的区别？

1. 形式上：字符常量是单引号引起的一个字符，字符串常量是双引号引起的若干个字符；

   ````java
   'a';字符常量
   "abcde";字符串常量
   ````

2. 含以上：字符常量是一个整型值(ASCII)，可以参加表达式运算，字符串常量代表一个地址值，即该字符串再内存中存在位置；

3. 占内存大小：占内存大小：字符常量只占2个字节，字符串常量占若干个字节。

### 2.2 关于注释？

Java中的注释分为三种：

1. 单行注释；注释少量代码和功能
2. 多行注释；注释多行代码和功能
3. 文档注释。注释类和方法功能及参数，返回值

```java
// 这是单行注释
/*
* 这是多行注释
*/
/**
* 这是文档注释
*/
```

### 2.3 标识符和关键字的区别？

1. 编写程序中，需要大量地为程序、类、变量、方法等取名字，于是就有了标识符；
2. Java语言将一些标识符赋予了特殊的含义，只能用于特定的地方，特殊标识符就是关键字。

### 2.4 Java中常见的关键字？

1. 访问控制：private/protected/public

   | 修饰符    | 当前类 | 同 包 | 子 类 | 其他包 |
   | --------- | ------ | ----- | ----- | ------ |
   | public    | √      | √     | √     | √      |
   | protected | √      | √     | √     | ×      |
   | default   | √      | √     | ×     | ×      |
   | private   | √      | ×     | ×     | ×      |

2. 类，方法和变量修饰符：abstract/class/extends/final/implements/interface/native/new/static/strictfp/sychronized/transient/volatile

3. 程序控制：break/continue/return/do/while/if/else/for/instanceof/switch/case/default

4. 错误处理：try/catch/throw/throws/finally

5. 包相关：import/package

6. 基本类型：boolean/byte/char/double/float/int/long/short/null/true/false

7. 变量引用：super/this/void

8. 保留字：goto/const

### 2.5 自增自减运算符

增运算符++和自减运算符--，符号在前就先加减后赋值，符号在后就先赋值后加减。

### 2.6 continue/break/return的区别？

均用于发生某种条件之后，提前终止循环：

1. continue：指跳出当前的这一次循环，继续下一次循环；
2. break：指跳出整个循环体，继续执行循环下面的语句。
3. return：指跳出所在方法，结束该方法的运行，分以下两种：
   - return；直接用return结束方法执行，用于没有返回值函数的方法
   - return value；return一个特定值，用于有返回值函数的方法

### 2.7 Java泛型？类型擦除？常用的通配符？

1. 泛型(generics)，是指在类定义时不指定类中信息的具体数据类型，而是暂时用一个标识符来替代，当外部实例化对象的时候再来指定具体的数据类型；
2. 泛型可以极大地提升程序灵活性，提升类的扩展性， 泛型可以指代类中成员变量的数据类型、方法的返回值类型以及方法的参数类型；
3. Java的泛型是伪泛型，这是因为Java在编译期间，所有的泛型信息都会被擦掉，也就是常说的类型擦除；
4. 泛型一般有三种使用方式：泛型类、泛型接口，泛型方法；
5. 常用的通配符为：T，E，K，V，?
   - ？表示不确定的java类型
   - T(type)表示具体的一个java类型
   - K V(key value)分别代表java键值中的Key Value
   - E(element)代表Element

### 2.8 ==和equals的区别

1. ==：它的作用是判断两个对象的地址是不是相等
   * 基本数据类型==比较的是值
   * 引用数据类型==比较的是内存地址
2. equals：它的作用也是判断两个对象是否相等，不能用于比较基本类型的变量，因为基本类型非对象
   * 类没有覆盖equals()方法，equals()等价于“==”比较这两个对象，也就是比较的引用数据类型的内存地址
   * 类覆盖了equals()方法，若比较的两个对象内容相等，则返回true

```java
public class test {
	public static void main(String[] args) {
	String a = new String("ab"); // a 为⼀个引⽤
	String b = new String("ab"); // b为另⼀个引⽤,对象的内容⼀样
	String aa = "ab"; // 放在常量池中
	String bb = "ab"; // 从常量池中查找
	if (aa == bb) // true
		System.out.println("aa==bb");
	if (a == b) // false，⾮同⼀对象,引用类型的内存地址不一致
		System.out.println("a==b");
	if (a.equals(b))//true,String类覆写了equals,方法只要比较两者内容相等,就返回true
		System.out.println("aEQb");
	if (42 == 42.0) { // true 比较的两者值的相等
		System.out.println("true");
    	}
    }
}
```

### 2.9 hashCode()与equals()

1. hashCode():

   - hashCode()的作用是获取哈希码，也称为散列码，也就是返回一个int整数；
   - 哈希码用于确定对象在哈希表中的索引位置；
   - hashCode()定义在JDK中Object类，意味着Java中任何类都含有hashCode()方法；
   - 键值对(key-value)利用哈希码("键")，快速检索出“值”。

2. 为什么要有hashCode？

   举例：HashSet如何检查重复，对象加入HashSet时，会计算HashCode值，并调用equals方法来检查hashcode相等的对象是否真的相同，可以减少equals方法的使用次数，大大提高了执行速度。

3. 为什么重写equals时必须重写hashCode方法？

   * 如果两个对象相等，则hashCode一定也是相同的

   * 如果两个对象有相同的hashCode值，它们不一定相等

4. 为什么两个对象有相同的hashcode值，它们也不一定是相等的？

   因为hashCode() 所使用的杂凑方法也许刚好会让多个对象传回相同的杂凑度，越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关( 所谓碰撞也就是指的不同对象得到相同的hashCode）。

## 3. Java基本数据类型

### 3.1 Java基本数据类型与其包装类

Java中共有8种基本数据类型：

1. 6种数字类型：byte1、short2、int4、long8、float4、double8
2. 1种字符类型：char2
3. 1种布尔类型：boolean(根据编译环境而定)

8种基本类型对应的包装类为：

	1. 6种数字包装类型：Byte、Short、Integer、Long、Float、Double
	2. 1种字符包装类型：Character
	3. 1种布尔包装类型：Boolean

注：

 	1. Java中long类型的数据一定要在数值后面加上L，否则将作为整形解析；
 	2. char a = 'h' (单引号)，String a = "hello" (双引号)。

题目：

```java
float f = 3.4 //是否正确？ false，java中不带小数点默认int，带小数点默认double，应为float f= 3.4f or (float)3.4
short s=1;s=s+1;//是否正确? false,1为int型，不能转换为short，会强转导致错误，s+=1进行了隐式类型转换
```

### 3.2 自动装箱与拆箱

​	基本类型与其对应引用类型的转换

1. 装箱：将基本类型用它们对应的引用类型包装起来；
2. 拆箱：将包装类型转换为基本数据类型。

### 3.3 8种基本类型的包装类和常量池

 Java基本类型的包装类大部分实现了常量池技术：

1. Byte、Short、Integer、Long等4种包装类默认创建了[-128,127]的相应类型的缓存数据；
2. Character创建了数值在[0,127]范围的缓存数据；
3. Boolean直接返回True或False；
4. 上述包装类如果超出对应范围仍会去创建新的对象；
5. 两种浮点数类型的包装类Float、Double并没有实现常量池技术。

```java
Integer i1 = 40;
Integer i2 = 40;
Integer i3 = 0;
Integer i4 = new Integer(40);
Integer i5 = new Integer(40);
Integer i6 = new Integer(0);
System.out.println("i1=i2 " + (i1 == i2));//true
System.out.println("i1=i2+i3 " + (i1 == i2 + i3));//true
System.out.println("i1=i4 " + (i1 == i4));//false
System.out.println("i4=i5 " + (i4 == i5));//false? 引用数据类型比较的是内存地址
System.out.println("i4=i5+i6 " + (i4 == i5 + i6));//true 因为+这个操作符不适用于Integer对象，首先i5和i6进行自动拆箱，进行数值相加，即i4==40，Intger对象无法与数值进行直接比较，所以i4自动拆箱为int值40，即40==40
System.out.println("40=i5+i6 " + (40 == i5 + i6));//true 同理 i4=i5+i6
```

## 4. Java方法(函数)

### 4.1 什么是方法的返回值？返回值在类的方法里的作用是什么？

1. 方法的返回值是指获取到某个方法中的代码执行后产生的结果(前提是该方法可能产生结果)；
2. 返回值的作用是接收出结果，使得它可以用于其他的操作。

### 4.2 为什么Java中只有值传递？

程序设计语言有关参数传递方法：

1. 按值调用(call by value):表示方法接收的是调用者提供的值；
2. 按引用调用(call by reference)表示方法接收的是调用者提供的变量地址。

**Java程序设计语言总是采用按值调用，即方法得到的是所有参数值的一个副本拷贝，即方法不能修改传递给它的任何基本类型参数变量的内容**。

Java程序设计语言对对象采用的不是引用调用，对象引用是按值传递的。

Java中方法参数的使用情况：

1. 一个方法不能修改一个基本数据类型的参数(即数值型和布尔型)；
2. 一个方法可以改变一个对象参数的状态；
3. 一个方法不能让对象参数引用一个新的对象。

### 4.3 重载(Overload)和重写(Override)的区别？

1. 重载：同样的一个方法能够根据输入数据的不同，做出不同的处理；

2. 重写：子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法。

3. 重载与重写的区别：

   | 区别点     | 重载       | 重写                                         |
   | ---------- | ---------- | -------------------------------------------- |
   | 发生范围   | 同一个类中 | 子类中                                       |
   | 参数列表   | 必须修改   | 一定不能修改                                 |
   | 返回类型   | 可修改     | 一定不能修改                                 |
   | 异常       | 可修改     | 可以减少或删除，一定不能抛出新的或更广的异常 |
   | 访问修饰符 | 可修改     | 一定不能作更严格的限制(可以降低限制)         |
   | 发生阶段   | 编译期     | 运行期                                       |

### 4.4 深拷贝和浅拷贝的区别？

1. 浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝；
2. 深拷贝：对基本数据类型进行值传递，对引用数据类型创建一个新的对象并复制其内容。

### 4.5 方法的四种类型

1. 无参数无返回值的方法

   ```java
   //无参数无返回值的方法(如果方法没有返回值，不能不写，必须些void，表示没有返回值)
   public void f1(){
       System.out.println("无参数无返回值的方法");
   }
   ```

2. 有参数无返回值的方法

   ```java
   //有参数无返回值的方法(参数列表由零组到多组"参数类型+形参名"组合而成，多组参数之间以英文逗号隔开，形参类型和姓形参名之间以英文空格隔开)
   public void f2(String a,String b,String c){
       System.out.println(a+"->"+b+"->"+c);
   }
   ```

   

3. 有返回值无参数的方法

   ````java
   //有返回值无参数的方法(返回值可以是任意的类型，在函数里面必须有return关键字返回对应的类型)
   public void f3(){
       System.out.println("有返回值无参数的方法");
       return 2;
   }
   ````

4. 有返回值有参数的方法

   ```java
   //有返回值有参数的方法
   public int f4(int a, int b){
   	return a*b;
   }
   ```

5. return在无返回值方法的特殊使用

   ```java
   //return在无返回值方法的特殊使用
   publiv void f5(int a){
   	if (a>10){
           return;//表示结束所在方法(f5)方法的执行，下方的输出语句不会执行
       }
       System.out.println(a);
   }
   ```

## 5. Java面向对象

### 5.1 面向对象和面向过程的区别？

1. 面向过程：面向过程性能比面向对象高，面向过程没有面向对象易维护、易复用、易扩展；
2. 面向对象：面向对象易维护、易复用、易扩展，面向对象性能比面向过程低。

### 5.2 构造器Constructor是否可以被override？

Constructor(构造函数)不能被override(重写)，但是可以overload(重载)，所以一个类中会有多个构造函数。

### 5.3 在Java中定义一个不做事且没有参数的构造方法的作用？

Java程序在执行子类的构造方法之前，如果没有super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”，若没有“没有参数的构造方法”在父类中，则编译时将发生错误，Java中定义一个不做事且没有参数的构造函数就是为了避免这种情况编译出错。

### 5.4 成员变量与局部变量的区别有哪些？

1. 从语法上看：成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；
2. 从修饰符看：成员变量可以被final、public、private、static修饰，局部变量可以被final、public、private修饰，不可以被static修饰；
3. 从变量在内存中的存储方式来看：如果成员变量使用static修饰，那么这个成员变量是属于类的，如果没有使用static修饰，那么这个成员变量是属于实例的；而对象存在于堆内存中，局部变量存在于栈内存；
4. 从变量在内存中的生存时间上看：成员变量是对象的一部分，随着对象的创建而存在，而局部变量随着方法的调用而自动消失；
5. 赋初值：成员变量如果没有被赋初值，则会自动以类型的默认值而赋值(例外：被final修饰的成员变量也必须显式地赋值)，而局部变量则不会自动赋值。

### 5.5 创建一个对象用什么运算符？对象实体与对象引用有何不同？

1. new运算符，new创建对象实例(对象实例在堆内存中)，对象引用指向对象实例(对象引用存放在栈内存中)；
2. 一个对象引用可以指向0个或1个对象(一根绳子可以不系气球，也可以系一个气球)，一个对象可以有n个引用指向它(可以用n条绳子系住一个气球)。

### 5.6 一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正常执行吗？

1. 一个类的构造方法是完成对类对象的初始化工作；
2. 一个类没有声明构造方法，也会有默认的不带参数的构造方法，可以正常执行；
3. 如果我们添加了类的构造方法(无论是否有参数)，Java就不会再添加默认的无参数构造方法了，所以这个时候就不能直接new一个对象而不传递参数了，所以我们一直在不知不觉地使用构造方法，这也就是为什么我们在创建对象的时候后面要加一个括号(因为要调用无参的构造方法)；
4. 如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来(无论是否用到)，因为这可以帮助我们在创建对象的时候少踩坑。

### 5.7 构造方法有哪些特性？

1. 名字与类名相同；
2. 没有返回值，但不能用void声明构造函数；
3. 生成类的对象时自动执行，无需调用。

### 5.8 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？

在调用子类构造方法之前会先调用父类没有参数的构造方法，目的是帮助子类做初始化

### 5.9 对象的相等与指向它们的引用相等这两者的区别？

1. 对象的相等比较的是内存中存放的内容是否相等；
2. 引用的相等比较的是它们指向的内存地址是否相等。

### 5.10 面向对象三大特征

1. 封装

   封装是指把一个对象的状态信息(也就是属性)隐藏在对象内部，不允许外部对象直接访问对象的内部信息，但是可以提供一些可以被外界访问的方法来操作属性。

2. 继承

   不同类型的对象，相互之间经常有一定数量的共同点，同时，每一个对象还定义了额外的特性；继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增减新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类；通过使用继承，可以快速地创建新的类，可以提高代码的重用和程序的可维护性，节省大量创建新类的时间，提高开发效率。

   关于继承有以下3点需要注意：

   * 子类拥有父类对象所有的属性和方法(包括私有属性和私有方法)，但是父类中的私有属性和方法子类是无法访问，**只是拥有**；
   * 子类可以拥有自己属性和方法，即子类可以对父类进行扩展；
   * 子类可以用自己的方式实现父类的方法。

3. 多态

   多态表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。

   关于多态，特点如下：

   * 对象类型和引用类型之间具有继承(类)/实现(接口)的关系；
   * 对象类型不可变，引用类型可变；
   * 方法具有多态性，属性不具有多态性；
   * 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；
   * 多态不能调用“只在子类存在但在父类不存在”的方法；
   * 如果子类重写了父类方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。

### 5.11 在一个静态方法内调用一个非静态成员为什么是非法的？

​	由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。

### 5.12 静态方法和实例方法有何不同？

1. 在外部调用静态方法时，可以使用“类名.方法名”的方式，也可以使用“对象名.方法名”的方式，而实例方法只能使用“对象名.方法名”的方式，也就是说，调用静态方法可以无需创建对象；
2. 静态方法在访问本类的成员时，只允许访问静态成员(即静态成员变量和静态方法)，而不允许访问实例成员变量和实例方法；实例方法则无此限制。

### 5.13 常见关键字总结

1. static：静态关键字用于以下四种使用场景
   * 修饰成员变量和成员方法；
   * 静态代码块；
   * 静态内部类(static修饰类的话只能修饰内部类)；
   * 静态导包(用来导入类中的静态资源，1.5之后的新特性)。
2. final：关键字
   * final修饰变量，成为常值，值不能再变化；
   * final修饰方法，不能被子类重写；
   * final修饰类，不能再有子类，如String类、StringBuffer、System；
   * final不能修饰构造方法；
   * static final修饰的变量是全局静态常量。
3. this：关键字
   * this表示的是当前对象本身，更准确地说，this代表当前对象的一个引用，可以调用该类的属性、方法、构造器；
   * 当在方法内需要用到调用该方法的对象时就可以使用this。
4. super：关键字
   * super关键字用于从子类访问父类的变量和方法

5. 使用this和super要注意的问题：
   * 在构造器中使用super()调用父类中的其他构造方法时，该语句必须处于构造器首行，否则编译器会报错，this调用本类中的其他构造方法时，也要放在首行；
   * this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西；
   * this、super不能用在static方法中。

### 5.14 接口和抽象类的区别是什么？

1. 接口的方法默认是public，所有方法在接口中不能有实现(Java 8开始接口方法可以有默认实现)，而抽象类有非抽象的方法；
2. 接口中除了static、final变量，不能有其他变量，而抽象类中则不一定；
3. 一个类可以实现多个接口，但只能实现一个抽象类，接口自己本身可以通过extends关键字扩展多个接口；
4. 接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符；
5. 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。

### 5.15 JDK7~JDK9中Java的接口概念变化

1. 在jdk7或更早版本中，接口里只能有常量变量和抽象方法，这些接口方法必须由选择实现接口的类实现；
2. jdk8的时候接口可以有默认方法和静态方法功能；
3. jdk9在接口中引入了私有方法和私有静态方法。

### 5.16 StringBuffer和StringBuilder的相同和区别是什么？

1. 对象可变不可变：
   * String中的对象是不可变的，也就可以理解为常量；
   * StringBuffer和StringBuilder的构造方法都是调用父类构造方法也就是AbstractStringBuilder实现的；
   * StringBuffer和StringBuilder都继承自AbstractStringBuilder类，在AbstractStringBuilder中是使用字符数组保存字符串char[] value但是没有用final修饰，所以这两种对象都是可变的；
2. 线程安全性：
   * String中的对象是不可变的，也就可以理解为常量，线程安全‘；
   * StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的；
   * StringBuilder并没有对方法加同步锁，所以是非线程安全的；
3. 性能：
   * String每次进行改变的时候，都会生成一个新的String对象，然后将指针指向新String；
   * StringBuffer每次都会对StringBuffer本身进行操作，而不生成新的对象并改变对象引用；
   * StringBuilder与StringBuffer一样，但是性能会有10%-15%的提升；
4. 总结：
   * 操作少量的数据：适用String；
   * 单线程操作字符串缓冲区下操作大量数据：适用StringBuilder；
   * 多线程操作字符串缓冲区下操作大量数据：适用StringBuffer。

### 5.17 String为什么是不可变的？

String类中使用final关键字修饰字符数组来保存字符串，private、final、char、value[]，所以String对象是不可变的。

### 5.18 Object类常见方法总结

Object类是Java所有类的基类，一共有13种方法：

1. Object():Object类的构造方法；
2. registerNatives():通过使用该方法，可以命名任何你想要的C函数；
3. clone():用来另存一个当前存在的对象，只有实现了Cloneable接口才可以调用该方法，否则抛出异常；
4. getClass():final方法，用于获得运行时的类型；
5. equals():equals用来比较两个对象的内容是否相等；
6. hashCode():用来返回其所在对象的物理地址(哈希码值)；
7. toString():用来返回该对象的字符串表示；
8. wait():导致当前的线程等待，直到其他线程调用此对象的notify()方法或notifyAll()方法；
9. wait(long timeout):导致当前的线程等待，直到其他线程调用此对象的notify()方法或notifyAll()方法，或者超过指定的时间量；
10. wait(long timeout, int nanos):导致当前的线程等待，直到其他线程调用此对象的notify()方法或notifyAll()方法，或者其他某个线程中断当前线程，或者已超过某个时间时间量；
11. notify():唤醒在此对象监视器上等待的单个线程；
12. notifyAll():唤醒在此对象监视器上等待的所有线程；
13. finalize():当垃圾回收器确定不存在该对象的更多引用时，由对象的垃圾回收器调用此方法。

注：有引申问题

- equals() 与 == 的区别是什么？
- hashCode() 和 equals() 之间有什么联系？

  1. 如果两个对象相等，则HashCode值一定也是相同的；
  2. 两个对象相等，对两个equals方法返回true；
  3. 两个对象有相同的HashCode值，它们也不一定是想的的；
  4. equals方法倍覆盖过，则HashCode方法也必须被覆盖；
  5. hashCode()的默认行为是对堆上的对象产生独特值，如果没有重写HashCode()，则该class的两个对象无论如何都不会相等。
- wait()方法与sleep()方法的区别
- 为什么重写了equals就必须重写hashCode
- HashMap的实现原理
- 谈谈类加载机制

### 5.19 Java序列化中如果有些字段不想进行序列化，怎么办？

1. transient关键字的作用是组织实例中那些用此关键字修饰的变量序列化；
2. 当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复；
3. transient只能修饰变量，不能修饰类和方法。

### 5.20 获取用键盘输入常用的两种方法

1. 通过Scanner：

   ```java
   Scanner input = new Scanner(system.in);
   String s = input.nextLine();
   input.close();
   ```

2. 通过BufferedReader

   ```java
   BufferedReader input=new BufferedReader(new InputStreamReader(System,in));
   String s = input.readLine();
   ```

### 5.21 Java中final,finally,finalize的区别与用法

1. final用于声明属性，方法和类，分别表示属性不可改变，方法不可覆盖，类不可继承；
2. finally是异常处理语句结构的一部分，表示总是执行；
3. finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，供垃圾收集时的其他资源回收，例如关闭文件等。

## 6. Java核心技术

### 6.1 异常(Exception)和错误(Error)

1. Error(错误)：是程序无法处理的错误；
2. Exception(异常)：是程序本身可以处理的异常；
3. 异常和错误的区别：异常能被程序本身处理，错误是无法处理。

### 6.2 Throwable类常用方法

1. getMessage()：返回异常发生时的简要描述；
2. toString()：返回异常发生时的详细信息；
3. getLocalizedMessage()：返回异常对象的本地化信息；
4. printStackTrace()：在控制台上打印Throwable对象封装的异常信息。

### 6.3 try-catch-finally

1. try块：用于捕获异常，其后可接零或多个catch块，如果没有catch块，则必须跟一个finally块；
2. catch块：用于处理try捕获到的异常；
3. finally块：无论是否捕获或处理异常，finally块里的语句都会被执行，当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。

在以下4种特殊情况下，finally块不会被执行：

1. 在finally语句块第一行发生了异常，因为在其他行，finally块还是会得到执行；
2. 在前面的代码中用了System.exit(int)已退出程序，exit是带参函数，若该语句在异常语句之后，finally会执行；
3. 程序所在的线程死亡；
4. 关闭CPU。

当try语句和finally语句种都有return语句时，在方法返回之前，finally语句的内容将被执行，并且finally语句的返回值将会覆盖原始的返回值，具体如下：

```java
public class Test {
	public static int f(int value) {
		try {
			return value * value;
		} finally {
			if (value == 2) {
				return 0;
			}
		}
	}
}//如果调用f(2)，返回值将是0，因为finally语句的返回值覆盖了try语句块的返回值。
```

### 6.4 使用try-with-resources来代替try-catch-finally

1. 面对必须要关闭的资源，总是优先使用try-with-resources而不是try-catch-finally，随之产生的代码更加简短，更清晰，产生的异常对我们也更有用；
2. 面对多个资源需要关闭的时候，使用try-with-resources实现起来也非常简单，如果还使用try-catch-finally可能会带来很多问题。

### 6.5 简述程序、进程、线程的基本概念，以及它们之间关系是？

​	关系：一个程序至少一个进程，一个进程至少一个线程。

1. 程序：是指含有指令和数据的文件，被存储在磁盘或其他的数据存储设备种，也就是说程序是静态的代码；
2. 进程：是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的；
3. 线程：线程与进程类似，但线程是一个比进程更小的执行单位，一个进程在其执行过程中可以产生多个线程；

进程和线程之间的区别：

1. 一个程序至少一个进程，一个进程至少一个线程；
2. 进程是计算机操作系统分配资源的最小单位，线程是程序执行的最小单位；
3. 线程的划分尺度小于进程，使得多线程程序的并发性能高；
4. 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，极大地提高了程序的执行效率；
5. 线程在执行过程中与进程还是有区别的，每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制；
6. 从逻辑的角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行，但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。

### 6.6 线程有哪些基本状态？

Java线程在运行的生命周期中的指定时刻只可能处于下面6种不同状态的其中一个状态：

1. 当线程执行wait()方法之后，线程进入WAITING(等待)状态，进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态；
2. 而TIME_WAITING(超时等待)状态相当于在等待状态的基础上增加了超时限制；
3. 通过sleep(long millis)方法或wait(long millis)方法可以将Java线程置于TIMED WAITING状态；
4. 当超时时间到达后Java线程将会返回到RUNNABLE状态；
5. 当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到BLOCKED(阻塞)状态；
6. 线程在执行Runnable的run()方法之后将会进入到TERMINATED(终止)状态。

### 6.7 Java中IO流分为几种？

1. 按照流的流向划分：可以分为输入流和输出流；
2. 按照操作单元划分：可以分为字节流和字符流；
3. 按照流的角色划分：可以分为节点流和处理流。

Java IO流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系，Java IO流的40多个类都是从下面4个抽象类基类中派生出来：

1. InputStream/Reader：所有输入流的基类，前者是字节输入流，后者是字符输入流；
2. OutputStream/Writer：所有输出流的基类，前者是字节输出流，后者是字符输出流。

### 6.8 既然有了字节流，为什么还要有字符流？

问题本质想问：不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么I/O流操作要分为字节流和字符流操作呢？

答：字符流是由Java虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时的，并且我们不知道编码类型就很容易出现乱码问题，所以I/O流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作，如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。

### 6.9 BIO/NIO/AIO有什么区别？

1. BIO(Blocking I/O): 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成，活动连接数小于1000情况下是可以的，但面对十万甚至百万级连接时，需要一种更高效的I/O处理模型来应对更多的并发量；
2. NIO(Non-blocking/NEW I/O):NIO是一种同步非阻塞I/O模型，阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好，非阻塞模式则相反；
3. AIO(Asynchronous I/O):AIO也就是NIO 2，是一种异步非阻塞I/O模型。

I/O阻塞模式选择：

1. 对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；
2. 对于高负载、高并发的网络应用，应使用NIO的非阻塞模式来开发。

## 7. Java集合框架

### 7.1 Java集合概览

Java中除了以Map结尾的集合类之外，其他类都实现了Collection接口，以Map结尾的类都实现了Map接口。

### 7.2 List、Set、Map三者之间的区别？

1. List(对付顺序的好帮手)：存储的元素是有序的、可重复的；
2. Set(注重独一无二的性质)：存储的元素是无序的、不可重复的；
3. Map(用key来搜索的专家)：使用键值对(key-value)存储，类似于y=f(x)，x代表key，y代表value，key是无序的、不可重复的，value是无序的、可重复的，即每个键最多映射到一个值。

### 7.3 无序性和不可重复性的含义

1. 无序性不等于随机性，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的；
2. 不可重复性是指添加的元素按照equals()判断时，返回false，需要同时重写equals()方法和HashCode()方法。

### 7.4 集合框架底层数据结构总结

1. Collection接口下面的集合：

   **List**：

   * ArrayList：Object[]数组；
   * Vector：Object[]数组；
   * LinkedList：双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环)。

   **Set**：

   * HashSet(无序、唯一)：基于HashMap实现的，底层采用HashMap来保存元素；
   * LinkedHashSet：LinkedHashSet是HashSet的子类，并且其内部是通过LinkedHashMap来实现的，有点类似于我们之前说的LinkedHashMap其内部是基于HashMap实现一样，不过还是有一点去别的；
   * TreeSet(有序、唯一)：红黑树(自平衡的排序二叉树)。

2. Map接口下面的集合：

   **Map**：

   * HashMap：JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的(“拉链法”解决冲突)，JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值(默认为8) (将链表转换成红黑树前会判断，如果当前数组的长度小于64，那么会选择先进行数组扩容，而不是转换为红黑树)，将链表转换为红黑树，以减少搜索时间；
   * LinkedHashMap：LinkedHashMap继承自HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成，另外，LinkedHashMap在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序，同时通过对链表进行相应的操作，实现了访问顺序相关逻辑；
   * HashTable：数组+链表组成的，数组是HashMap的主体，链表则是为了解决哈希冲突而存在的；
   * TreeMap：红黑树(自平衡的排序二叉树)。

### 7.5 如何选用集合？为什么要使用集合？

1. 需要根据键值获取元素值时就选用Map接口下集合：

   * 需要排序时选择TreeMap；
   * 不需要排序时就选择HashMap；
   * 需要保证线程安全就选择ConcurrentHashMap。

2. 只需要存放元素值时就选用实现Collection接口的集合：

   * 需要保证元素唯一时选择实现Set接口的集合比如TreeSet或HashSet；
   * 不需要保证元素唯一时就选择实现List接口的比如ArrayList或LinkedList；
   * 根据实现这些接口的集合的特点来选用。

3. 为什么要使用集合？

   当我们需要保存一组类型相同的数据的时候，我们应该是用一个容器来保存，这个容器就是数组，但是，使用数组存储对象具有一定的弊端，因为我们在实际开发中，存储的数据的类型是多种多样的，就出现了“集合”，集合同样也是用来存储多个数据的；

   数组的缺点是一旦声明之后，长度就不可变了，同时，声明数组时的数据类型也决定了该数组存储的数据类型，而且，数组存储的数据是有序的、可重复的，特点单一，但是集合提高了数据存储的灵活性，Java集合不仅可以用来存储不同类型不同数量的对象，还可以保存具有映射关系的数据。

### 7.6 Iterator迭代器

1. Iterator对象称为迭代器(设计模式的一种)，迭代器可以对集合进行遍历，但每一个集合内部的数据结构可能是不尽相同的，所以每一个集合存和取都很可能是不一样的，虽然我们可以人为地在每一个类中定义hasNext()和next()方法，但这样做会让整个集合体系过于臃肿，于是就有了迭代器；

2. 迭代器是将这样的方法抽取出接口，然后在每个类的内部，定义自己迭代方式，这样做就规定了整个集合体系的遍历方式都是hasNext()和next()方法，使用者不管怎么实现，会用即可；
3. 迭代器的定义是提供一种方法访问一个容器对象各个元素，而又不需暴露该对象的内部细节；
4. Iterator主要是用来遍历集合用的，它的特点是更加安全，因为它可以确保在当前遍历的集合元素被更改的时候，就会抛出ConcurrentModificationException异常。

### 7.7 集合的线程安全？

1. 常用的ArrayList、LinkedList、HashMap、HashSet、TreeSet、TreeMap、PriorityQueue都不是线程安全的，需要使用线程安全的集合来代替；
2. 线程安全：CopyOnWriteArrayList、ConcurrentLinkedQueue、 ConcurrentHashMap、BlockingQueue、ConcurrentSkipListMap。

### 7.8 Collection子接口List

**ArrayList和Vector的区别？**

1. ArrayList是List的主要实现类，底层使用Object[]存储，适用于频繁的查找工作，线程不安全；
2. Vector是List的古老实现类，底层使用Object[]存储，线程安全的。

**ArrayList与LinkedList的区别？**

​	**可衍生为数组和链表的区别**

1. **是否线程安全**：都是不同步的，也就是不保证线程安全；
2. **底层数据结构**：ArrayList底层用的是**Object数组**，LinkedList使用的是**双向链表**；
3. **插入和删除是否受元素位置的影响**：
   * ArrayList采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响；
   * LinkedList采用链表存储，所以插入和删除元素的时间复杂度不受元素位置的影响；
4. **是否支持快速速记访问**：ArrayList支持，LinkedList不支持高效的随机元素访问；
5. **内存空间占用**：
   * ArrayList的空间浪费主要体现在list列表的结尾会预留一定的容量空间
   * LinkedList的空间花费则体现在它的每一个元素都需要消耗更多的空间

**ArrayList的扩容机制？**

### 7.9 Collection子接口之Set

**comparable和Comparator的区别**

1. comparable接口实际上是出自java.lang包，它有一个compareTo(Object obj)方法用来排序；
2. Comparator接口实际上是初期java.util包，它有一个compare(Object obj1, Object obj2)方法用来排序。

### 7.10 比较HashSet、LinkedHashSet和TreeSet三者异同

1. HashSet是Set接口的主要实现类，HashSet的底层是HashMap，线程不安全，可存储null值；
2. LinkedHashSet是HashSet的子类，能够按照添加的顺序遍历；
3. TreeSet底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序；

### 7.11 Map接口

**HashMap和HashTable的区别**

1. **是否线程安全**：HashMap是非线程安全的，HashTable是线程安全的，因为HashTable内部的方法基本都经过synchronized修饰；
2. **使用效率**：因为线程安全的问题，HashMap要比HashTable效率高一些，另外，HashTable基本已被淘汰，不要再代码中使用它；
3. **对Null key和Null value的支持**：HashMap可以存储null的key和value，但null作为key只能由一个，null作为value可以有很多个，HashTable不允许有null value和null key，否则会抛出NullPointerException；
4. **初始容量大小和每次扩容大小的不同**：
   * 创建时如果不指定容量初始值，HashTable默认的初始大小为11，之后每次扩充，容量为原来的2n+1，HashMap默认的初始化大小为16，之后每次扩充，容量为原来的2倍；
   * 创建时如果给定了容量初始值，HashTable会直接使用你给定的大小，而HashMap会将其扩充为2的幂次方大小；
5. **底层数据结构**：JDK1.8以后的HashMap在解决哈希冲突时有了较大的变化，当链表长度大于阈值时，将链表转化为红黑树，以减少搜索时间，HashTable没有这样的机制。

**HashMap和HashSet的区别**

| HashMap                        | HashSet                                                      |
| ------------------------------ | ------------------------------------------------------------ |
| 实现了Map接口                  | 实现了Set接口                                                |
| 存储键值对                     | 仅存储对象                                                   |
| 调用put()向map中添加元素       | 调用add()方法向Set中添加元素                                 |
| HashMap使用键(key)计算HashCode | HashSet使用成员对象那来计算HashCode值，对于两个对象来说HashCode可能相同，所以equals()方法用来判断对象的相等性 |

**HashMap和TreeMap的区别**

TreeMap和HashMap都继承自AbstractMap，但是需要注意的是TreeMap实现了NavigableMap接口和SortedMap接口，TreeMap比HashMap主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索能力。

**HashSet如何检查重复**

当你把对象加入HashSet时，HashSet会计算对象的HashCode值来判断对象加入的位置，同时也会与其他加入对象的HashCode值作比较，如果没有相符的HashCode值，HashSet会假设对象没有重复出现，但是如果发现有相同HashCode值的对象，这时会调用equals()来检查HashCode值相等的对象是否真的相同，如果两者相同，HashSet就不会让加入操作成功。

**HashMap的底层实现**

JDK1.8之前HashMap的底层是**数组和链表**结合在一起使用也就是**链表散列**，HashMap通过key的HashCode值经过扰动函数处理过后得到哈希值，然后通过(n-1)&hash判断当前元素存放的位置(这里的n指的是数组的长度)，如果当前位置存在元素的话，就判断该元素与要存入的元素的hash值以及key是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突；JDK1.8以后的HashMap在解决哈希冲突时有了较大的变化，当链表长度大于阈值时，将链表转化为红黑树，以减少搜索时间。

**ConcurrentHashMap和HashTable的区别**

1. **底层数据结构**：JDK1.7的ConcurrentHashMap底层采用**分段的数组+链表**实现，JDK1.8采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。HashTable和JDK1.8之前的HashMap的底层数据结构类似都是采用**数组+链表**的形式，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。
2. **实现线程安全的方式**：在JDK1.7的时候，ConcurrentHashMap(分段锁)对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率，到了JDK1.8的时候已经摒弃了Segment的概念，而是直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用synchronized和CAS来操作，整个看起来就像是优化过且线程安全的HashMap；HashTable(同一把锁)使用synchronized来保证线程安全，效率非常低下，当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用put添加元素，另一个线程不能使用put添加元素，也不能使用get，竞争会越来越激烈。

**HashMap用对象做key的注意事项**

如果遇到对象作为HashMap结构的key，则一定要注意重写equals和hashCode两个方法

### 7.12 Collections工具类

Collections工具类常用方法：

1. 排序：

````java
void reverse(List list)//反转
void shuffle(List list)//随机排序
void sort(List list)//按⾃然排序的升序排序
void sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑
void swap(List list, int i , int j)//交换两个索引位置的元素
void rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前⾯。当distance为负数时，将 list的前distance个元素整体移到后⾯
````

2. 查找，替换操作：

```java
int binarySearch(List list, Object key)//对List进⾏⼆分查找，返回索引，注意List必须是有序的
int max(Collection coll)//根据元素的⾃然顺序，返回最⼤的元素。 类⽐int min(Collection coll)
int max(Collection coll, Comparator c)//根据定制排序，返回最⼤元素，排序规则由Comparatator类控制。类⽐int min(Collection coll, Comparator c)
void fill(List list, Object obj)//⽤指定的元素代替指定list中的所有元素。
int frequency(Collection c, Object o)//统计元素出现次数
int indexOfSubList(List list, List target)//统计target在list中第⼀次出现的索引，找不到则返回-1，类⽐int lastIndexOfSubList(List source, list target).
boolean replaceAll(List list, Object oldVal, Object newVal)//⽤新元素替换旧元素
```

3. 同步控制(不太推荐，需要线程安全的集合类型时请考虑使用JUC包下的并发集合)

```java
synchronizedCollection(Collection<T> c) //返回指定collection支持的同步（线程安全的）collection。
synchronizedList(List<T> list)//返回指定列表支持的同步（线程安全的）List。
synchronizedMap(Map<K,V> m) //返回由指定映射支持的同步（线程安全的）Map。
synchronizedSet(Set<T> s) //返回指定set支持的同步（线程安全的）set。
```

## 8. MySQL面试

### 8.1 关系型数据库介绍

关系型数据库就是一种建立在关系模型基础上的数据库，关系模型表明了数据库中所存储的数据之间的联系(一对一、一对多、多对多)。

### 8.2 常见的关系型数据库

MySQL、PostgreSQL、Oracle、SQL Server、SQLite

### 8.3 MyISAM和InnoDB引擎之间的区别

1. 是否支持行级锁：MyISAM只有表级锁(table-level locking)，而InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁；
2. 是否支持事务：MyISAM不提供事务支持，InnoDB提供事务支持，具有提交(commit)和回滚(rollback)事务的能力；
3. 是否支持外键：MyISAM不支持外键，而InnoDB支持外键；
4. 是否支持数据库异常崩溃后的安全恢复：MyISAM不支持，而InnoDB支持；
5. 是否支持MVCC：MyISAM不支持，而InnoDB支持。

### 8.4 数据库事务

数据库事务可以保证多个对数据库的操作(也就是多个SQL语句的执行)构成一个整体，构成这个逻辑上的整体这些数据库操作遵循：**要么全部执行成功，要么全部不执行**。

![img](https://camo.githubusercontent.com/d9c8448f21fb27f4565e846dc1b63077c01f3e27e03764940f4e1b8ec4731514/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f323032302d31322f3634302d32303230313230373136303535343637372e706e67)

```sql
# 开启一个事务
START TRANSACTION;
# 多条 SQL 语句
SQL1,SQL2...
## 提交事务
COMMIT;
```

### 8.5 关系型数据库ACID特性

​	关系型数据库(例如：MySQL、SQL Server、Oracle等)事务都有ACID特性：

1. **原子性(Atomicity)**：事务时最小的执行单位，不允许分割，事务的原子性确保动作要么全部完成，要么完全不起作用；
2. **一致性(Consistency)**：执行事务前后，数据保持一致，例如转账业务中，无论是否成功，转账者和收款人的总额应该是不变的；
3. **隔离性(Isolation)**：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
4. **持久性(Durability)**：一个事务被提交后，它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

### 8.6 数据库优化-SQL索引

1. 索引是帮助MySQL高效获取数据的数据结构，通俗来讲索引就好比书本的目录，加快数据库的查询速度。
2. 索引的优点是提高查询效率、消除数据分组和排序，避免“回表”查询，优化聚合查询，用于多表JOIN关联查询，利用唯一性约束，保证数据唯一性
3. 索引的副作用是增加I/O成本，增加磁盘空间，不合适的索引或索引过多，会降低增删改的效率

## 9. 数据结构和算法

### 9.1 线性数据结构

1. 数组

   **数组(Array)**是一种很常见的数据结构，它由相同类型的元素(element)组成，并且是使用一块连续的内存来存储，可以直接利用元素的索引(index)计算出该元素对应的存储地址。

   数组的特点是：**提供随机访问**，并且容量有限。

   ![数组](https://camo.githubusercontent.com/46f587fe2966892bbf19d0432c9793770e28f69a45a217428768b6912af7c606/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545362539352542302545372542422538342e706e67)

   假如数组的长度为n，时间复杂度：

   * 访问：O(1) //访问特定位置的元素；
   * 插入：O(n)//最坏的情况发生在插入发生在数组的首部并需要移动所有元素；
   * 删除：O(n)//最坏的情况发生在删除数组的开发并需要移动第一元素后面所有的元素时。

2. 链表

   **链表(LinkedList)**虽然是一种线性表，但是并不会按线性顺序存储数据，使用的不是连续的内存空间来存储数据，使用链表结构可以客服数组需要预先知道数据大小的缺点，但链表占用空间较大，不具有数组随机读取的优点。

   假如链表中有个n个元素，时间复杂度：

   * 访问：O(n)；
   * 插入：O(1)；
   * 删除：O(1)。

   **链表的分类**：

   2.1 **单链表**

   单向链表只有一个方向，结点只有一个后继指针next指向后面的节点，链表这种结构在物理内存上是不连续的，第一个结点叫作头节点，链表通常有一个不保存任何值的head节点(头结点)，通过头结点我们可以遍历整个链表，尾结点通常指向null。

   ![单链表](https://camo.githubusercontent.com/1d8bf245b30ede53ec1bcab9bd44708b70f880f174eb4f9d17af2dc3ee330d47/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f254535253844253935254539253933254245254538254131254138322e706e67)

​		2.2 **双向链表**

​		双向链表包含两个指针，一个prev指向前一个结点，一个next指向后一个结点。

​				![双向链表](https://camo.githubusercontent.com/d7fd1913224b9e4bb2ac5aff7ac57097b1876de11c1744b21cfe6dcc9d2c05d6/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352538462538432545352539302539312545392539332542452545382541312541382e706e67)

​		2.3 **循环链表**

​		循环链表是一种特殊的单链表，和单链表不同的是循环链表的尾结点不是指向null，而是指向链表的头结点。

​		![循环链表](https://camo.githubusercontent.com/3556e4a0b077e5cee95738f6b177929875f53d359b582af5e12b59188e8f5d8c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f254535254245254141254537253845254146254539253933254245254538254131254138322e706e67)

​		2.4 双向循环链表

​		双向循环链表最后一个结点的next指向head，而head的prev指向最后一个结点，构成一个环。

​		![双向循环链表](https://camo.githubusercontent.com/7e710661bccc541450e8726b61379a7b5bcc5bfdfb897bf8eb66568280fdcc9a/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352538462538432545352539302539312545352542452541412545372538452541462545392539332542452545382541312541382e706e67)

3. 数组VS链表
   * 数组支持随机访问，而链表不支持随机访问；
   * 数组使用的是连续内存空间对CPU的缓存机制友好，链表则相反；
   * 数组需要存储数据元素个数确定，链表需要存储数据元素个数不确定；
   * 数组适合不需要经常添加和删除数据，链表适合需要经常添加和删除数据；
   * 数组的大小固定，而链表则天然支持动态扩容，如果声明数组过小，需要另外申请更大的内存空间存放数组元素，然后将原数组拷贝进去，这个操作是比较耗时的。

4. 栈

   **栈(Stack)**只允许在有序的线性数据集合的一端(称为栈顶top)进行加入数据(push)和移除数据(pop)，因而按照**后进先出(LIFO, Last In First Out)**的原理运作，在栈中，push和pop的操作都发生在栈顶。栈通常用一维数组或链表来实现，用数组实现的栈叫作**顺序栈**，用链表实现的栈叫作**链式栈**。

   ![栈](https://camo.githubusercontent.com/6a7b6ad68765003b517ee559cf0b660f33ad97665ad317ce12de96cc692fbf5c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545362541302538382e706e67)

   假设栈中有n个元素，时间复杂度：

   * 访问：O(n) //最坏情况；
   * 插入：O(1) //顶端插入元素；
   * 删除：O(1) //顶端删除元素。

5. 队列

   **队列(Queue)**是**先进先出(FIFO, First In First Out)**的线性表，用数组实现的队列叫作**顺序队列**，用链表实现的队列叫作**链式队列**。队列只允许在后端(rear)进行插入操作也就是入队enqueue，在前端(front)进行删除操作也就是出队dequeue。

   ![队列](https://camo.githubusercontent.com/1cccc99cbd4ebea2d6052101ec02eeac55c4d69c70cca50724aec43f13d9b14d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545392539382539462545352538382539372e706e67)

   假设队列有n个元素，时间复杂度：

   * 访问：O(n) //最坏情况；
   * 插入：O(1) //后端插入元素；
   * 删除：O(1) //前端删除元素。

   **队列的分类**：

   5.1 单队列

   单队列就是常见的队列，每次添加元素时，都是添加到队尾。单队列包含两个指针，front指向队头元素，rear指向队列最后一个元素的下一个位置。

   ![顺序队列假溢出](https://camo.githubusercontent.com/2c7f7db9b67ac298f2a0fd7983fb4c3a5cf4ee11a2f6070fcc82af6f42fdf71c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f254539254131254241254535254241253846254539253938253946254535253838253937254535253831253837254536254241254132254535253837254241312e706e67)

   5.2 循环队列

   循环队列可以解决顺序队列的假溢出和越界问题，解决方法就是形成头尾相接的循环，这也就是循环队列名字的由来。

   ![循环队列](https://camo.githubusercontent.com/eb679149c00da98b44d7b5dbd1fa11fd17f80ecda9d3580d5dcffe9ceb2a2460/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352542452541412545372538452541462545392539382539462545352538382539372e706e67)

### 9.2 图

图是由顶点的有穷非空集合和顶点之间的边组成的集合，通常表示为：G(V,E)，其中，G表示一个图，V表示顶点的集合，E表示边的集合。

1. 图的基本概念
   * 顶点：图中的数据元素，称之为顶点，图至少有一个顶点(非空有穷集合)；
   * 边：顶点之间的关系用边表示；
   * 度：度表示一个顶点包含多少边，在有向图中，还分为出度和入度，出度表示从该顶点出去的边条数，入度表示进入该顶点的边数；
   * 无向图和有向图：边表示顶点之间的关系，有的关系是双向的，如同学关系，即无向图，有的关系是有方向的，如父子关系，即有向图；
   * 无权图和有权图：对于一个关系，只关心关系的有无而不关心关系的强弱则可以使用无权图，对于一个关系，既关心关系的有无也关心关系的强度就可以使用有权图。
2. 图的存储
   * 邻接矩阵存储：邻接矩阵将图用二维矩阵存储，是一种较为直观的表示方式，如果第i个顶点和第j个顶点之间有关系，且关系权值为n，则A[i] [j]=n；
   * 邻接表存储：邻接链表使用一个链表来存储某个顶点的所有后继相邻顶点，对于图中每个顶点Vi，把所有邻接于Vi的顶点Vj链成一个单链表，这个单链表称为顶点Vi的邻接表；
   * 邻接矩阵存储方式优点是简单直接(二维数组)，获取两个顶点之间关系也很高效，但是比较浪费空间；邻接表却比较节省空间。
3. 图的搜索
   * 广度优先搜索：**广度优先搜索的具体实现方式用到了之前所学过的线性数据结构——队列**；
   * 深度优先搜索：**深度优先搜索的具体实现用到了另一种线性数据结构——栈**。

### 9.3 图与树结构的区别？

图从数学领域进化而来，主要被用来描述一个从一个位置到另一个位置的路线模型，一个图包含一系列的点和一系列的边，边用来把点连接起来，路线是用来描述共用一条边的点的轨迹的术语；

树，和图一样也是一系列点的集合，有一个根节点，这个根节点有一些子节点，子节点也有它们自己的孙节点，不断重复直到所有的数据都被用树的数据结构表示。

树是没有环的图，在图里面，环的路线是开始和结束都是一样的点，一个子节点只有一个父节点，所以树不是一个递归的数据结构。

### 9.4 队列堆栈转换

1. 使用队列实现堆栈

   用队列实现栈就比较简单粗暴了，只需要一个队列作为底层数据结构，把队列前面的都取出来再加入队尾，让之前的队尾元素排到队头，这样就可以取出。

   ![preview](https://pic4.zhimg.com/v2-12ecb7d26fa6a1b051210d7ee77c3c03_r.jpg)

   ```java
   //删除栈顶的元素并返回
   public int pop() {
       int size = q.size();
       // 留下队尾 2 个元素
       while (size > 2) {
           q.offer(q.poll());
           size--;
       }
       // 记录新的队尾元素
       top_elem = q.peek();
       q.offer(q.poll());
       // 删除之前的队尾元素
       return q.poll();
   }
   //判断栈是否为空
   public boolean empty() {
       return q.isEmpty();
   }
   ```

   

2. 使用堆栈实现队列

   按道理队头元素应该是 1，但是在 `s1` 中 1 被压在栈底，现在就要轮到 `s2` 起到一个中转的作用了：当 `s2` 为空时，可以把 `s1` 的所有元素取出再添加进 `s2`，**这时候 `s2` 中元素就是先进先出顺序了**。

   ![preview](https://pic3.zhimg.com/v2-864f8633fc063ce1ed73c8065cede85a_r.jpg)

   ![preview](https://pic2.zhimg.com/v2-f477fc9e0b59b2aa6877acd72a65ff7d_r.jpg)

   ```java
   //使用两个栈实现一个队列功能
   class MyQueue {
       private Stack<Integer> s1, s2;
   
       public MyQueue() {
           s1 = new Stack<>();
           s2 = new Stack<>();
       }
   //添加元素到队尾
   	public void push(int x) {
       	s1.push(x);
   	}
   }
   //返回队头元素
   public int peek() {
       if (s2.isEmpty())
           // 把 s1 元素压入 s2
           while (!s1.isEmpty())
               s2.push(s1.pop());
       return s2.peek();
   }
   //删除队头的元素并返回
   public int pop() {
       // 先调用 peek 保证 s2 非空
       peek();
       return s2.pop();
   }
   //判断队列是否为空
   public boolean empty() {
       return s1.isEmpty() && s2.isEmpty();
   }
   ```

### 9.5 算法总结

1. 冒泡排序

   ````java
   import java.util.Arrays;
   public class bubbleSort{
       public static void main(String[] args){
           int[] arr = {13,2,31,52,18,26,35};
           for(int i=0;i<arr.length-1,i++){
               for(int j=0;j<arr.length-1;j++){
                   int temp;
                   if(arr[j]>arr[j+1]){
                       temp=arr[j];
                       arr[j]=arr[j+1];
                       arr[j+1]=temp;
                   }
               }
           }
           System.out.println(Arrays.toString(arr));
       }
   }
   ````
   
2. 快速排序

   ````java
   public class QuickSort{
       private void swap(int[] arr,int i,int j){
           int temp = arr[i];
           arr[i] = arr[j];
           arr[j] = temp;
       }	
       public void quickSort(int[] arr,int start,int end){
           if(start>=end)
               return;
           int k =arr[start];
           int i = start,j=end;
           while(i!=j){
               while(i<j&&arr[j]>=k)
                   --j;
               swap(arr,i,j);
               while(i<j&&arr[i]<=k)
                   ++i;
               swap(arr,i,j);
           }
           quickSort(arr,start,i-1);
           quickSort(arr,i+1,end);
       }
   
   	public static void main(String[] args){
       int[] arr = {5, 2, 6, 9, 1, 3, 4, 8, 7, 10};
       new QuickSort().quickSort(arr,0,arr.length-1);
       System.out.println(Arrays.toString(arr));
   	}
   }
   ````

   

3. 二分查找

   ````java
   public class BinarySearch {
       public static void main(String args){
       int[] arr = {1, 5, 26, 26, 26, 26, 68, 100, 235, 667, 896, 999};
           int index = binarySearch(arr,0,arr.length-1,26);
           if(index==-1){
               System.out.println("未找到");
           }else{
               System.out.println("下标为:"+index);
           }
       }
      	public static int binarySearch(int[] arr,int low,int high,int value){
           if(low>high){
               return -1;
           }
           int mid = (low+high)/2;
           int midValue = arr[mid];
           if(value > midValue){
               return binarySearch(arr,mid+1,high,value);
           }else if(value<midValue){
               return binarySearch(arr,low,mid-1,value)
           }else{
               return mid;
           }
       }
      }
   ````

4. 广度优先遍历(BFS)和深度优先遍历(WFS)

   搜索算法，只不过搜索的方式不同而已：

   广度优先遍历类似树的层次遍历，首先访问起始顶点V，然后选取与V邻接的全部顶点w1,w2,w3…wn，进行访问，再依次访问与W1,W2,W3…Wn连接的顶点，依次类推，直到所有顶点都被访问到为止，**从顶点一层层向外拓展和遍历，实现是需要用到队列**。

   ```java
   //通常用队列(先进先出，FIFO)实现
   初始化队列Q;
   Q={起点S};标记S为已访问;
   while(Q非空){
   	取Q队首元素u;u出队;
   	if(u == 目标状态){…}
   	所有与u相邻未被访问的点进入队列;
   	标记u为已访问;
   	}
   ```

   深度优先遍历首先访问出发结点V，将其标记为已访问过，然后选取与V连接的未被访问的任意一个顶点W，并访问它，再选取与W相邻的未被访问的任意一个顶点并访问，依次重复进行，**当一个顶点的所有邻接顶点都被访问过，则依次退回到最近被访问过的顶点**，如果该顶点还有其他邻接顶点未被访问，则这些未被访问的顶点中取一个重复上述访问过程，实现是需要用到**递归**。

   ```java
   DFS(dep,…)//dep代表目前DFS的深度
   {
   	if(找到解|走不下去了)
   	{
   		…
   		return;
   		枚举下一种情况,DFS(dep+1,…)
   }
   ```

## 10. Spring常见问题总结

### 10.1 什么是Spring框架？

Spring是一种轻量级开发框架，旨在提高开发人员的开发效率以及系统的可维护性。

### 10.2 列举一些重要的Spring模块

1. Spring Core：基础，Spring其他所有的功能都需要依赖此类库，主要提供IoC依赖注入；
2. Spring Aspects：该模块与AspectJ的集成提供支持；
3. Spring AOP：提供了面向切面的编程实现；
4. Spring JDBC：Java数据库连接；
5. Spring JMS：Java消息服务；
6. Spring ORM：用于支持Hibernate等ORM工具；
7. Spring Web：为创建Web应用程序提供支持；
8. Spring Test：提供JUnit和TestNG测试的支持。

### 10.3 @RestController VS @Controller

1. @Controller返回一个页面

   单独使用@Controller不加@ReponseBody的话一般使用在要返回一个视图的情况，这种情况属于比较传统的Spring MVC的应用，对应于前后端不分离的情况。

   ![SpringMVC 传统工作流程](https://camo.githubusercontent.com/5474972f83f61bc6d3a684ba73ff2cc2da80c55ee575a8dde270d79c6ef2d699/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d372f537072696e674d56432545342542432541302545372542422539462545352542372541352545342542442539432545362542352538312545372541382538422e706e67)

2. @RestController返回JSON或XML形式数据

   但@RestController只返回对象，对象数据直接以JSON或XML形式写入HTTP响应(Response)中，这种属于RESTful Web服务，这也是目前日常开发所接触的最常用的情况(前后端分离)。

   ![SpringMVC+RestController](https://camo.githubusercontent.com/55cbcce8007cbb1c408cd766178c91986498187ef1f9b4aba13c2741504b24c7/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d372f537072696e674d564352657374436f6e74726f6c6c65722e706e67)

3. @Controller+@ReponseBody返回JSON或XML形式数据

   如果你需要在Spring4之前开发RESTful Web服务的话，需要使用@Controller` +`@ResponseBody`= `@RestController

   ![Spring3.xMVC RESTfulWeb服务工作流程](https://camo.githubusercontent.com/99880ce9b9bb9fe245fec5362b09c597d8f2030ad2d14cba2790f2f63bbd601d/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d372f537072696e67332e784d56435245535466756c5765622545362539432538442545352538412541312545352542372541352545342542442539432545362542352538312545372541382538422e706e67)

   ### 10.4 Spring IoC和AOP

   1. IoC

   IoC(Inverse of Control：控制反转)是一种**设计理想**，也就是**将原本在程序中手动创建对象的控制权，交由Spring框架来管理**。IoC在其他语言中也有应用，并非Spring特有。**IoC容器是Spring用来实现IoC的载体，IoC容器实际上就是个Map(key,value)，Map中存放的是各种对象**。IoC容器就像是一个工厂一样，当我们需要创建要给对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。利用IoC，你只要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。

   Spring一般通过XML文件来配置Bean，Spring IoC的初始化过程：

   ![Spring IoC的初始化过程](https://camo.githubusercontent.com/f755b974ddea2dcc702d0b9b2a08710f779aff519a042e3b0340d92756835aef/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d372f537072696e67494f432545352538382539442545352541372538422545352538432539362545382542462538372545372541382538422e706e67)

   2. AOP

   AOP(Aspect Oriented Programming：面向切面编程)能够将那些与业务无关，**却为业务模块所共同调用的逻辑或责任(例如事务处理、日志管理、权限控制等)封装起来**，便于**减少系统的重复代码，降低模块间的耦合度**，并**有利于未来的可拓展性和可维护性**。

   Spring AOP是基于动态处理的，分为JDK Proxy和Cglib：

   ![SpringAOPProcess](https://camo.githubusercontent.com/2948f9b2b5c45eb208990afcac1bf5638783dc3ebc834d3d7d2d4f7cc050981c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f537072696e67414f5050726f636573732e6a7067)

### 10.5 Spring AOP和AspectJ AOP的区别？

1. **Spring AOP属于运行时增强**，**而AspectJ AOP是编译时增强**。Spring AOP基于代理(Proxying)，而AspectJ基于字节码操作(Bytecode Manipulation)；

2. Spring AOP集成了AspectJ，AspectJ相比于Spring AOP功能更加强大，但是Spring AOP相对来说更简单；

3. 如果切面太多的话，最好选择AspectJ，比Spring AOP块很多，如果切面比较少，两者性能差异不大。

### 10.6 Spring中的bean作用域有哪些？

1. singleton：唯一bean实例，Spring中的bean默认都是单例的；
2. prototype：每次请求都会创建一个新的bean实例；
3. request：每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效；
4. session：每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP session内有效；
5. global-session：全局session作用域，仅在基于portlet的web应用中才有意义，Spring5没有。

### 10.7 Spring中的单例bean的线程安全问题？

当多个线程操作同一个对象的时候，对这个对象的成员变量的写操作会存在线程安全问题，但是，一般常用的Controller、Service、Dao这些Bean是无状态的，无状态的Bean不能保存数据，因此是线程安全的。

### 10.8 @Component和@Bean的区别？

1. 作用对象不同：@Component注解作用于类，@Bean作用于方法；
2. @Component通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中，@Bean注解通常是我们在标有该注解的方法中定义产生这个Bean，@Bean告诉了Spring这是某个类的示例；
3. @Bean注解比@Component注解的自定义性更高，而且很多地方我们只能通过@Bean注解来注册Bean。

### 10.9 将一个类声明为Spring的Bean的注解有哪些？

1. @Component：通用的注解，可标注任意类为Spring组件，如果一个Bean不知道属于哪个层，可以使用@Component注解标注；
2. @Repository：对应持久层即Dao层，主要用于数据库相关操作；
3. @Service：对应服务层即Service层，主要涉及一些复杂的业务逻辑，需要用到Dao层；
4. @Controller：对应Spring MVC层，主要用于接受用户请求并调用Service层返回数据给前端。

### 10.10 Spring中的Bean生命周期

![Spring Bean 生命周期](https://camo.githubusercontent.com/88419f86f9217dc22d5e06d705ceed80523bd1fb6732c0bbaea83ec7dfbf7db7/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d31372f34383337363237322e6a7067)

![Spring Bean 生命周期](https://camo.githubusercontent.com/bc7d32ce0850ca343b1c3ef2ee28e702c468b34d1cde970b646facde6c5ff579/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d31372f353439363430372e6a7067)

### 10.11 Spring MVC简单原理

MVC是一种设计模式，Spring MVC是一款很优秀的MVC框架，Spring MVC可以帮助我们更简洁的Web层开发，并且与Spring框架集成，Spring MVC下我们一般把项目分为Service层(处理业务)、Dao层(数据库操作)、Entity层(实体类)、Controller层(控制层，返回数据给前台页面)。

![img](https://camo.githubusercontent.com/5c267204e931f978620a0873cd47174bede05467a038b56036dc9314d5d6094f/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31302d31312f36303637393434342e6a7067)

![SpringMVC运行原理](https://camo.githubusercontent.com/5286b702ca4eb9f100758317e237e853d9579f8f4984d5ad468636d6db89b782/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31302d31312f34393739303238382e6a7067)

**Spring MVC工作流程说明**：

1. 客户端(浏览器)发送请求，直接请求到DispatcherServlet；
2. DispatcherServlet根据请求信息调用HandlerMapping，解析请求对应的Handler；
3. 解析对应的Handler(也就是我们平常说的Controller控制器)后，开始由HandlerAdapter适配器处理；
4. HandlerAdapter会根据Handler来调用真正的处理器来处理请求，并处理响应的业务逻辑；
5. 处理器处理完业务后，会返回一个ModelAndView对象，Model是返回的数据对象，View是个逻辑上的View；
6. ViewResolver会根据逻辑View查找实际的View；
7. DispatcherServlet把返回的Model传给View(视图渲染)；
8. 把View返回给客户端(浏览器)。

### 10.12 Spring MVC模式的优缺点？

优点：提高了程序的可维护性、可移植性、可扩展性与可重用性，降低了程序的开发难度。

1. 可以为一个模型在运行时同时简历和使用多个视图，变化-传播机制可以确保所有相关的视图及时得到模型数据变化，从而使所有关联的视图和控制器做到行为同步；
2. 视图与控制器的可接插性，允许更换视图和控制器对象，而且可以根据需求动态的打开或关闭，甚至在运行期间进行对象替换；
3. 模型的可移植性，模型是独立于视图的，所以可以把一个模型独立地移植到新的平台工作，需要做的只是在新平台上对视图和控制器进行新的修改；
4. 潜在的框架结构，可以基于此模型建立应用程序框架，不仅仅是用在设计界面的设计中。

缺点：

	1. 增加了系统结构和实现的复杂性，可能产生过多的更新操作，降低运行效率；
 	2. 视图与控制器过于紧密的连接，视图与控制器是相互分离但确实联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了它们的独立重用；
 	3. 视图对模型数据的低效率访问，依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据，对未来变化数据的不必要频繁访问，也将损害操作性能；
 	4. 一般高级界面工具或构造器不支持MVC架构，改造成本使得使用MVC很困难。

### 10.13 Spring框架中用到了那些设计模式？

1. 工厂设计模式：Spring使用工厂模式通过 BeanFactory, ApplicationContext 创建 Bean 对象；
2. 代理设计模式：Spring AOP功能的实现；
3. 单例设计模式：Spring中的Bean默认都是单例的；
4. 模板方法模式：Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式；
5. 包装器设计模式： 不同项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库，这种模式让我们可以根据客户的需求能够动态切换不同的数据源；
6. 观察者模式：Spring 事件驱动模型就是观察者模式很经典的一个应用；
7. 适配器模式：Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller；
8. ……

### 10.14 Spring管理事务的方式有几种？

1. 编程式事务，在代码中硬编码；(不推荐使用)
2. 声明式事务，在配置文件中配置：(推荐使用)
   * 基于XML的声明式事务；
   * 基于注解的声明式事务。

### 10.15 Spring IoC

1. IoC(Inverse of Control：控制反转)是一种**设计理想**，也就是**将原本在程序中手动创建对象的控制权，交由Spring框架来管理**。
2. 为了解决对象之间的耦合度过高的问题，提出的IoC理论，也就是控制反转理论；
3. 通过引入IoC容器，利用依赖关系注入的方式，实现对象之间的解耦合；
4. 依赖注入就是底层类作为参数传入上层类，实现上层类对下层类的”控制“；
5. 控制反转容器(IoC Container)能自动对你的代码进行初始化，你只需要维护一个Configuration（可以是xml可以是一段代码），而不用每次初始化一辆车都要亲手去写那一大段初始化的代码，在创建实例的时候不需要了解其中的细节。

## 11. MyBatis常见问题总结

### 11.1 什么是MyBatis？

1. MyBatis是一个半ORM(Object Relational Mapping)框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动，创建连接，创建statement等繁杂的过程，程序员直接编写原生态sql，可以严格控制sql执行性能，灵活度高；
2. MyBatis可以使用xml或注解来配置和映射原生信息，将POJO映射成数据库中的记录，避免了几乎所有JDBC代码和手动设置参数以及获取结果集；
3. 通过xml文件或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射，生成最终执行的sql语句，最后由MyBatis框架执行sql并将结果映射为java对象并返回。

### 11.2 MyBatis的优缺点？

优点：

1. 基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除SQL与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用；
2. 与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；
3. 很好的与各种数据库兼容(因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持)；
4. 能够与Spring很好的集成；
5. 提供映射标签，支持对象与数据库的ORM字段关系映射，提供对象关系映射标签，支持对象关系组件维护。

缺点：

1. SQL语句的编写工作量大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定的要求；
2. SQL语句依赖于数据库，导致数据库移植性很差，不能随意更换数据库。

### 11.3 MyBatis整体架构

![img](https://pic2.zhimg.com/80/v2-e6b80a7021fad859a59c2368e9747a6d_720w.jpg)

1. API接口层，核心对象是SqlSession，SqlSession中定义了非常多的对数据库操作的方法，接口层在接受到调用请求时，会调用核心处理层的相应模块来完成具体的数据库操作；
2. 数据处理层：
   * 把接口中传入的参数解析并映射成JDBC类型；
   * 解析xml文件中的sql语句，包括插入参数和动态SQL的生成；
   * 执行SQL语句；
   * 处理结果集，并映射成Java对象。
3. 基础支撑层，提供最基础的功能支持，包括连接管理、事务管理、配置加载和缓存处理，这都是共用的东西，将他们抽取出来作为最基础的组件，为上层的数据处理层提供最基础的支撑。

### 11.4 #{}和${}的区别？

1. ${}是Properties文件中的变量占位符，它可以用于标签属性值和sql内部，属于静态文本替换，比如${driver}就会被静态替换为com.mysql.jdbc.driver；
2. #{}是sql的参数占位符，MyBatis会将sql中的#{}替换为？号，在sql执行前会使用PreparedStatement的参数设置方式，按序给？号占位符设置参数值，比如ps.setInt(0,parameterValue)，#{item.name}的取值方式为使用反射从参数对象中获取item对象的name属性值，相当于param.getItem().getName()。

### 11.5 xml映射文件中，除了常见的select、insert、update、delete标签外，还有哪些？

还有其他标签，如`<resultMap>`、`<parameterMap>`、`<sql>`、`<include>`、`<selectKey>`，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中为sql片段标签，通过`<include>`标签引入sql片段，`<selectKey>`为不支持自增的主键生成策略标签。

### 11.6 通常一个xml映射文件，都会写一个Dao接口与之对应，这个Dao接口的工作原理是什么？

Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement。

举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。

在MyBatis中，每一个`<select>`、`<insert>`、`<update>`、`<delete>`标签，都会被解析为一个`MappedStatement`对象。

### 11.7 Dao接口里的方法，参数不同时，方法能重载吗？ 

Dao接口里的方法可以重载，但是MyBatis的xml里面的ID不允许重复。

### 11.8 MyBatis是如何进行分页的，分页插件原理?

MyBatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页；分页插件的基本原理是使用MyBatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。