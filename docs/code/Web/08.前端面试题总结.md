# 前端面试题总结

## HTML

### 如何理解HTML语义化？

* **可读性高**，让人更容易读懂，已增加代码可读性;
* **有利于爬虫**，让搜索引擎更容易读懂，有助于爬⾍抓取更多的有效信息，爬⾍依赖于标签来确定上下⽂和各个关键词 的权重(SEO);
* **代码结构清晰**，在没有CSS样式下，页面也能呈现出很好地内容结构、代码结构。

### script标签中defer和async的区别？

* `<script>`: 会阻碍HTML解析，只有下载好并执行完脚本才会继续解析HTML；
* `<script async>`: 解析HTML过程中进行脚本的异步下载，下载成功立马执行，有可能会阻断HTML的解析；
* `<script defer>`: 完全不会阻碍HTML的解析，解析完成后再按照顺序执行脚本。

图解：

![image.png](https://s2.loli.net/2023/04/04/zUgXakPVf7cYopD.webp)

### 从浏览器地址栏输入url到请求返回发生了什么？

#### 简单回答

从浏览器地址栏中输入URL到请求返回的过程主要分为以下几个步骤：

1. DNS 解析：浏览器首先会从 URL 中获取主机名，然后向 DNS 服务器发送查询请求，将主机名转换为该主机的 IP 地址。 
1. 建立 TCP 连接：浏览器向目标服务器发起 TCP 连接（三次握手）。如果连接已经存在（HTTP 持久连接），则可以跳过此步骤。 
1. 发送 HTTP 请求：浏览器向服务器发送构建好的 HTTP 请求，请求中包含了请求方法（GET、POST 等）、请求头（Accept、User-Agent 等）和请求体（在 POST 请求中）等信息。 
1. 服务器处理请求：服务器接收到请求后会根据请求内容进行一系列的处理，例如读取请求头信息、获取请求资源等。 
1. 返回 HTTP 响应：服务器返回构建好的 HTTP 响应，响应中包含了状态码、响应头（Content-Type、Content-Length 等）和响应体等信息。 
1. 浏览器渲染页面：浏览器将接收到的响应数据进行解析，根据 HTML、CSS 等渲染规则将网页渲染出来。 
1. 断开 TCP 连接：浏览器和服务器之间完成数据传输后会断开 TCP 连接（四次挥手）。如果是 HTTP 持久连接，则可以保留连接，等待下一次请求。

#### url的组成

url主要由 `协议scheme`、`主机host`、`端口port`、`路径path`、`查询参数queryParams`、`锚点anchor`六部分组成；

![img](https://s2.loli.net/2023/04/04/eUY1gztl4VrsSqT.webp)

#### 解析url

在地址栏，输入url后，浏览器会解析出协议scheme、主机host、端口port、路径path等信息，并构造一个HTTP请求：

* 浏览器发送请求前，根据请求头的`expires`和`cache-control`判断是否命中（包括是否过期）强缓存策略，如果命中，直接从缓存获取资源，并不会发送请求。如果没有命中，则进入下一步。
* 没有命中强缓存规则，浏览器会发送请求，根据请求头的`If-Modified-Since`和`If-None-Match`判断是否命中协商缓存，如果命中，直接从缓存获取资源。如果没有命中，则进入下一步。
* 如果前两步都没有命中，则直接从服务端获取资源。

强缓存图解如下：

![img](https://s2.loli.net/2023/04/04/YFeGR5w48jEPDrL.webp)

#### 浏览器缓存须知

1. **Expires**

* 版本：HTTP/1.0
* 来源：存在于服务端返回的响应头中
* 语法：Expires: Wed, 22 Nov 2019 08:41:00 GMT
* 缺点：浏览器的时间和服务器的时间可能并不一致导致失效

2. **Cache-Control**

* 版本：HTTP/1.1
* 来源：响应头和请求头
* 语法：Cache-Control:max-age=3600
* 缺点：时间最终还是会失效

3. **请求头**

| 字段名称                  | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| no-cache                  | 告知(代理)服务器不直接使用缓存，要求向原服务器发起请求       |
| no-store                  | 所有内容都不会被保存到缓存或Internet临时文件中               |
| max-age=delta-seconds     | 告知服务器客户端希望接收一个存在时间不大于delta-secconds秒的资源 |
| max-stale[=delta-seconds] | 告知(代理)服务器客户端愿意接收一个超过缓存时间的资源，若有定义delta-seconds则为delta-seconds秒，若没有则为任意超出时间 |
| min-fresh=delta-seconds   | 告知(代理)服务器客户端希望接收一个在小于delta-seconds秒内被更新过的资源 |
| no-transform              | 告知(代理)服务器客户端希望获取实体数据没有被转换(比如压缩)过的资源 |
| noly-if-cached            | 告知(代理)服务器客户端希望获取缓存的内容(若有),而不用向原服务器发去请求 |
| cache-extension           | 自定义扩展值，若服务器不识别该值将被忽略掉                   |

4. **响应头**

| 字段名称                  | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| public                    | 表明任何情况下都得缓存该资源(即使是需要HTTP认证的资源)       |
| Private=[field-name]      | 表明返回报文中全部或部分(若指定了field-name则为field-name的字段数据)仅开放给某些用户(服务器指定的share-user，如代理服务器)做缓存使用，其他用户则不能缓存这些数据 |
| no-cache                  | 不直接使用缓存，要求向服务器发起(新鲜度校验)请求             |
| no-store                  | 所以内容都不会被保存到缓存或Internet临时文件中               |
| no-transform              | 告知客户端缓存文件时不得对实体数据做任何改变                 |
| noly-if-cached            | 告知(代理)服务器客户端希望获取缓存的内容(若有),而不用向原服务器发去请求 |
| must-revalidate           | 当前资源一定是向原方法服务器发去验证请求的，如请求是会返回504(而非代理服务器上的缓存) |
| proxy-revalidate          | 与must-revalidate类似，但仅能应用于共享缓存(如代理)          |
| max-age=delta-seconds告知 | 客户端该资源在delta-seconds秒内是新鲜的，无需向服务器发请求  |
| s-maxage=delta-seconds    | 同max-age，但仅能应用于共享缓存(如代理)                      |
| cache-extension           | 自定义扩展值，若服务器不识别该值将被忽略掉                   |

5. **协议缓存**

   协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程

   协议缓存图解：

![img](https://s2.loli.net/2023/04/04/inkT9ZY7EJGIAa3.webp)

#### DNS域名解析

在发起HTTP请求之前，浏览器首先要去获得我们想访问网页的IP地址，浏览器会发送一个UDP的包给DNS域名解析服务器

![img](https://s2.loli.net/2023/04/04/YDb5VXHyGBkdsW1.webp)

1. 递归查询

我们使用的浏览器、操作系统、路由器都会缓存一些URL对应的IP地址，统称为DNS高速缓存，这是为了加快DNS解析速度，使得不必每次都到根域名服务器中去查询。

![img](https://s2.loli.net/2023/04/04/IKo5HcJ7FRGtzux.webp)

2. 迭代查询

迭代查询的方式就是，局部的DNS服务器并不会自己向其他服务器进行查询，而是能够解析该域名的服务器地址返回给客户端，客户端会不断地向这些服务器进行查询，直到查询到了位置，迭代的话只会帮你找到相关的服务器，然后说我现在比较忙，你可以去相关的服务器寻找。

![img](https://s2.loli.net/2023/04/04/dEXTuZOz8WhPILF.webp)

3. DNS负载均衡

DNS还有负载均衡的作用，现在很多网站都有多个服务器，当一个网站访问量过大的时候，如果所有请求都请求在同一个服务器上，可能服务器就会崩掉，这时候就用到了DNS负载均衡技术，当一个网站有多个服务器地址时，在应答DNS查询的时候，DNS服务器会对每个查询返回不同的解析结果，也就是返回不同的IP地址，从而把访问引导到不同的服务器上去，来达到负载均衡的目的。例如可以根据每台机器的负载量，或者该机器距离用户的地理位置距离等等条件。

4. DNS预解析

大型网站，有多个不同服务器资源的情况下，都可采取DNS预解析，提前解析，减少页面卡顿

```html
<meta name="aplus-xplug"content="NONE">
<meta name="keywo rd"content:="淘宝，掏宝，网上购物，C2C,在线交易，交易市场，网上交易，交易市场，网上买，网上卖，供应，买卖信息，网店，一口价，拍卖，网上开店，网络购物，打折，免费开店，网购，频道，店辅">
<link rel="dns-prefetch"href="//g.alicdn.com">
<link rel="dns-prefetch"href="//img.alicdn.com">
<link rel="dns-prefetch"href="//tce.alicdn.com">
<link rel="dns-prefetch"href="//gm.mmstat.com">
<link ref="dns-prefetch"href="//tce.taobao.com">
<link rel="dns-prefetch"href="//log.mmstat.com">
<link rel="dns-prefetch"href="//tui.taobao.com">
<link rel="dns-prefetch"href="//ald.taobao.com">
<link rel="dns-prefetch"href="//gw.alicdn.com">
<link rel="dns-prefetch"href="//atanx.alicdn.com">
<link rel="dns-prefetch"href="//dfhs.tanx.com">
<link rel="dns-prefetch"href="//ecpm.tanx.com">
<link rel="dns-prefetch"href="//res.mmstat.com">
```

#### TCP/IP连接

1. **TCP/IP协议**

将应用层、表示层、会话层合并为应用层，物理层和数据链路层合并为网络接口层

![img](https://s2.loli.net/2023/04/04/32nPuXVtv8cw1EY.webp)

2. **三次握手**

客户端和服务端在进行http请求和返回的工程中，需要创建一个`TCP Connection`(由客户端发起)，`http`不存在连接这个概念，它只有请求和响应，请求和响应都是数据包，它们之间的传输通道就是`TCP Connection`

<img src="https://s2.loli.net/2023/04/04/y8b6saZ2VAqOhP3.webp" alt="img" style="zoom:50%;" />

位码即tcp标志位，有SYN(synchronous建立联机)、ACK(acknowledgement 确认)、PSH(push传送)、FIN(finish结束)、RST(reset重置)、URG(urgent紧急)共6种。

第一次握手：**（第一次握手，由浏览器发起，告诉服务器我要发送请求了）**主机A发送位码为`SYN＝1`，随机产生`Seq  number=1234567`的数据包到服务器，主机B由`SYN=1`知道，A要求建立联机；；

第二次握手：**（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）**主机B收到请求后要确认联机信息，向A发送`ack number=(主机A的seq+1)`，`SUN=1，ACK=1234567 + 1`，随机产生`Seq=7654321`的包；

第三次握手：**（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）**主机A收到后检查`ack number`是否正确，即第一次发送的`seq number+1`，以及位码`SYN`是否为1，若正确，主机A会再发送`ack number=(主机B的seq+1)`，`ack=7654321 + 1`，主机B收到后确认`Seq`值与`ACK=7654321+ 1`则连接建立成功。

3. **第三次握手的必要性**

总是要问：为什么需要三次握手，两次不行吗？其实这是由TCP的自身特点**可靠传输**决定的。客户端和服务端要进行可靠传输，那么就需要**确认双方的`接收`和`发送`能力**。第一次握手可以确认客服端的`发送能力`,第二次握手，服务端`SYN=1,Seq=Y`就确认了`发送能力`,`ACK=X+1`就确认了`接收能力`,所以第三次握手才可以确认客户端的`接收能力`。不然容易出现丢包的现象。

4. **三次握手过程中可以携带数据吗？**

第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据。

第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击（SYN攻击）了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病

#### HTTP请求

1. **HTTP协议特点**

* 支持客户、服务器模式；
* 简单快速客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于 HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
* 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记。
* 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
* 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快

2. **各协议与HTTP协议关系**

* DNS服务：解析域名至相应的IP地址
* HTTP协议：生成针对目标web服务器的HTTP请求报文
* TCP协议：将请求报文按序号分割成多个报文段
* IP协议：搜索对方的地址，一边中转一遍传送
* TCP协议：按序号以原来的顺序重组请求报文请求的处理结果也同样利用TCP/IP协议向用户进行回传

3. **HTTPS**

在HTTP的基础上再加一层TLS（传输层安全性协议）或者SSL（安全套接层），就构成了HTTPS协议。

HTTPS连接需要7次握手，3次TCP + 4次TLS。

HTTPS 默认工作在 TCP 协议443端口，它的工作流程一般如以下方式：

- TCP 三次同步握手
- 客户端验证服务器数字证书
- DH 算法协商对称加密算法的密钥、hash 算法的密钥
- SSL 安全加密隧道协商完成
- 网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。

#### 服务器处理请求并返回HTTP报文

每台服务器上都会安装处理请求的应用——Web Server。常见的Web Server 产品有 `apache`、`nginx`、`IIS` 或 `Lighttpd` 等。

HTTP请求一般可以分为两类，静态资源 和 动态资源。

1. **请求访问静态资源**，这个就直接根据url地址去服务器里找就好了。

2. **请求访问动态资源**，就需要web server把不同请求，委托给服务器上处理相应请求的程序进行处理（例如 CGI 脚本，JSP 脚本，servlets，ASP 脚本，服务器端 JavaScript，或者一些其它的服务器端技术等），然后返回后台程序处理产生的结果作为响应，发送到客户端。

3. 服务器在**处理请求**的时候主要有三种方式：

- 第一种：是用一个线程来处理所有的请求，并且同时只能处理一个请求，但是这样的话性能是非常的低的。
- 第二种：是每一个请求都给他分配一个线程但是当链接和请求比较多的时候就会导致服务器的cpu不堪重负。
- 第三种：就是采用复用I/O的方式来处理例如通过epoll方式监视所有链接当链接状态发生改变的时候才去分配空间进行处理。

#### 浏览器渲染页面

![img](https://s2.loli.net/2023/04/04/yR2bpiOd7UoXQDE.webp)

1. DOM树

   ```html
   <!DOCTYPE html>
   <html>
     <head>
       <meta name="viewport" content="width=device-width,initial-scale=1">
       <link href="style.css" rel="stylesheet">
       <title>Critical Path</title>
     </head>
     <body>
       <p>Hello <span>web performance</span> students!</p>
       <div><img src="awesome-photo.jpg"></div>
     </body>
   </html>
   ```

   字节 -> 字符 -> 令牌 -> 节点 -> 对象模型

   ![img](https://s2.loli.net/2023/04/04/g2L9ueOAW3j4lzm.webp)

   * 转换：浏览器从磁盘或网络读取HTML的原始字节，并根据文件的指定编码(例如UTF-8)将它们转换成各个字符；
   * 令牌化：浏览器将字符串转换成W3C HTML5标准规定的各种令牌，例如尖括号内的字符串，每个令牌都具有特殊含义和一组规则；
   * 词法分析：发出的令牌转换成定义其属性和规则的“对象”；
   * DOM构建：由于HTML标记不同标记之间的关系(一些标记包含在其他标记内)，创建的对象链接在一个树数据结构内，此结构也会捕获原始标记中定义的父项-子项关系，例如，HTML对象是body对象的父项，body是paragraph对象的父项，以此类推。

2. CSS对象模型(CSSOM)

   ```css
   body { font-size: 16px }
   p { font-weight: bold }
   span { color: red }
   p span { display: none }
   img { float: right }
   ```

   ![img](https://s2.loli.net/2023/04/04/9aZycXrRJjPz6Kv.webp)

3. 布局树(Layout Tree)

   - DOM 树与 CSSOM 树合并后形成渲染树。
   - 渲染树只包含渲染网页所需的节点。
   - 布局计算每个对象的精确位置和大小。
   - 最后一步是绘制，使用最终渲染树将像素渲染到屏幕上

   ![img](https://s2.loli.net/2023/04/04/lxI5Ls6JW2uZn7g.webp)

4. 渲染

   渲染流程：

   - 获取DOM后分割为多个图层
   - 对每个图层的节点计算样式结果		（Recalculate style--样式重计算）
   - 为每个节点生成图形和位置			（Layout--重排,回流）
   - 将每个节点绘制填充到图层位图中		（Paint--重绘）
   - 图层作为纹理上传至GPU
   - 组合多个图层到页面上生成最终屏幕图像	（Composite Layers--图层重组）

#### 断开连接

TCP四次分手

<img src="https://s2.loli.net/2023/04/04/DcN7XVkKIfJBpmQ.webp" alt="img" style="zoom:50%;" />

1. 刚开始双方都处于established状态，假如是客户端先发起关闭请求
2. **第一次挥手**：客户端发送一个FIN报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态
3. **第二次挥手**：服务端收到FIN之后，会发送ACK报文，且把客户端的序列号值+1作为ACK报文的序列号值，表明已经收到客户端的报文了，此时服务端处于CLOSE_WAIT状态
4. **第三次挥手**：如果服务端也想断开连接了，和客户端的第一次挥手一样，发送FIN报文，且指定一个序列号。此时服务端处于LAST_ACK的状态
5. 需要过一阵子以确保服务端收到自己的ACK报文之后才会进入CLOSED状态，服务端收到ACK报文之后，就处于关闭连接了，处于CLOSED状态。

**为什么需要四次挥手？**

因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。s

## CSS

### 盒模型

CSS3中的盒模型有以下两种：**标准盒模型**、**IE(替代)盒模型**

两种盒子模型都是由 `content + padding + border + margin` 构成，其大小都是由 `content + padding + border` 决定的，但是盒子内容宽/高度（即 `width/height`）的计算范围根据盒模型的不同会有所不同：

- 标准盒模型：只包含 `content` 。
- IE（替代）盒模型：`content + padding + border` 。

<img src="https://s2.loli.net/2023/04/06/yRboJiQ1PW7ecC6.webp" alt="img" style="zoom: 45%;" /><img src="https://s2.loli.net/2023/04/06/4hD6GKUkJHSNLmO.webp" alt="img" style="zoom: 45%;" />

可以通过 `box-sizing` 来改变元素的盒模型：

- `box-sizing: content-box` ：标准盒模型（默认值）。
- `box-sizing: border-box` ：IE（替代）盒模型。

### CSS选择器和优先级

#### CSS选择器列表

| 序号 | 选择器         | 语法                                  | 描述                                   | 例子                                             |
| ---- | -------------- | ------------------------------------- | -------------------------------------- | ------------------------------------------------ |
| 1    | 元素选择器     | `elementname { styles }`              | 通过元素名称选择元素。                 | `p {  color: red; }`                             |
| 2    | 类选择器       | `.classname { styles }`               | 通过类名选择元素。                     | `.my-class { color:blue;}`                       |
| 3    | ID选择器       | `#idname { styles }`                  | 通过ID选择元素。                       | `#my-id { color: green;}`                        |
| 4    | 属性选择器     | `[attribute=value] { styles }`        | 通过元素的属性选择元素。               | `input[type="text"] { border: 1px solid gray; }` |
| 5    | 后代选择器     | `ancestor descendant { styles }`      | 通过元素之间的嵌套关系选择元素。       | `div p {  font-size: 16px; }`                    |
| 6    | 子元素选择器   | `parent > child { styles }`           | 通过父元素与子元素的直接关系选择元素。 | `ul > li {  list-style: none; }`                 |
| 7    | 相邻兄弟选择器 | `element+sibling {styles }`           | 通过相邻兄弟元素之间的关系选择元素。   | `h1 + p {  margin-top: 0; }`                     |
| 8    | 通用选择器     | `* { styles }`                        | 选择所有元素。                         | `* {  box-sizing: border-box; }`                 |
| 9    | 伪类选择器     | `selector:pseudo-class { styles }`    | 在指定状态下选择元素。                 | `a:hover {  text-decoration: underline; }`       |
| 10   | 伪元素选择器   | `selector::pseudo-element { styles }` | 选择元素的特定部分。                   | `p::first-line {font-weight: bold; }`            |

#### CSS选择器优先级

1. CSS选择器优先级速记

   > 特殊(!important) > 内联(style) > id选择器(#id) > 类选择器(.class) > 标签选择器(h1, a, div)
   >
   > !important > style > id > class > div

2. CSS选择器优先级计算规则

   多个选择器同时选择，选择器优先级计算规则由(a, b, c, d)值来决定：

   a：如果存在**内联样式(style=)**，则a=1，否则，a=0；

   b：**id选择器(#id)**出现的次数；

   c：**类选择器(.class)**、**属性选择器(input[type="text"])**和**伪类选择器(a:hover)**出现的总次数；

   d：**标签选择器(h1,a,div)**和**伪元素选择器(::before,::after)**出现的总次数。

   ```css
   li                                  /* (0, 0, 0, 1) */
   ul li                               /* (0, 0, 0, 2) */
   ul ol+li                            /* (0, 0, 0, 3) */
   h1 + *[REL=up]                      /* (0, 0, 1, 1) */
   ul ol li.red                        /* (0, 0, 1, 3) */
   li.red.level                        /* (0, 0, 2, 1) */
   .a1.a2.a3.a4.a5.a6.a7.a8.a9.a10.a11  /* (0, 0, 11,0) */
   #x34y                               /* (0, 1, 0, 0) */
   li:first-child h2 .title            /* (0, 0, 2, 2) */
   #nav .selected > a:hover            /* (0, 1, 2, 1) */
   html body #nav .selected > a:hover  /* (0, 1, 2, 3) */
   ```

   比较规则是：从左至右比较，如果是样式优先级相等，取后面出现的样式。

3. CSS选择器优先级特殊情况

​	综上，已知内联样式的优先级是最高的，使用 `!important` ，让外部样式可以覆盖内联样式。因为一般情况下，很少会使用内联样式 ，所以 `!important` 也很少会用到！如果不是为了要覆盖内联样式，建议尽量不要使用 `!important` 。

#### 回流(reflow)/和重绘(repaint)的理解

1. 浏览器的渲染过程

![img](https://s2.loli.net/2023/04/04/yR2bpiOd7UoXQDE.webp)

由上图可知，浏览器渲染过程如下：

* 解析HTML，生成DOM树，解析CSS，生成CSSOM树；
* 将DOM树和CSSOM树结合，生成渲染树Render Tree；
* Reflow：回流，根据生成的渲染树，进行回流，得到节点的几何信息（位置、大小）；
* Painting：重绘，根据渲染树以及回流得到的几何信息，得到节点的绝对像素；
* Display：展示，将像素发送给GPU，展示在页面上。

2. 回流/reflow

当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为**回流**。

会导致回流的操作：

* 页面首次渲染
* 浏览器窗口大小发生改变
* 元素尺寸或位置发生改变
* 元素内容变化（文字数量或图片大小等等）
* 元素字体大小变化
* 添加或者删除可见的DOM元素
* 激活CSS伪类
* 查询某些属性或调用某些方法

一些常用且会导致回流的属性和方法：

- `clientWidth`、`clientHeight`、`clientTop`、`clientLeft`
- `offsetWidth`、`offsetHeight`、`offsetTop`、`offsetLeft`
- `scrollWidth`、`scrollHeight`、`scrollTop`、`scrollLeft`
- `scrollIntoView()`、`scrollIntoViewIfNeeded()`
- `getComputedStyle()`
- `getBoundingClientRect()`
- `scrollTo()`

3. 重绘/repaint

当页面中元素样式的改变并不影响它在文档流中的位置时，如(`color`、`background-color`、`visibility`等)，浏览器会将新样式赋予给元素并重新绘制它，这个过程叫**重绘**。

4. 回流与重绘的关系

* 回流必将引起重绘，但重绘不一定会引起回流

* 回流比重绘的代价更高，对性能影响要更大

5. 如何避免回流与重绘

CSS方面：

* 尽量避免使用`table`布局；
* 尽可能在`DOM`树的最末端改变`class`；
* 避免设置多层内联样式；
* 将动画效果应用到`position`属性为`absolute`或`fixed`的元素上；
* 避免使用`CSS`表达式，例如`calc()`。

JS方面：

* 避免频繁操作样式，最好一次性重写`style`属性，或者将样式列表定义为`class`并一次性更改`class`属性；
* 避免频繁操作`DOM`，创建一个`documentFragment`，在它上面进行所有`DOM`操作，最后再把它添加到文档中；
* 也可以先为设置元素`display:none`，操作结束后再把它显示出来，因为在`display`属性为`none`的元素上进行的`DOM`操作不会引发回流和重绘；
* 避免频繁读取会引发回流/重绘的属性，如果需要多次使用，就用一个变量缓存起来；
* 对具有复杂动画的元素使用`绝对定位`，使它脱离文档流，否则会引起父元素及后续元素频繁回流。

#### 常见的CSS定位方案

1. 普通流

* 元素按照其在HTML中的先后位置自上而下布局；
* 行内元素水平排列，直到当行被占满然后换行；
* 所有元素默认都是普通流定位。

2. 浮动

* 元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移。

3. 绝对定位

* 元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响。

#### 对BFC的理解

BFC，Block Formatting Context，全称为“块级格式化上下文”，是web页面中一个重要的概念，是指一个独立的渲染区域，具有一定的布局规则。根据盒模型可知，每个元素都被定义为一个矩形盒子，然而盒子的布局会受到**尺寸**、**定位**、**盒子的子元素**或**兄弟元素**、**视口的尺寸**等因素决定，所以这里有一个浏览器计算的过程，计算的规则就是由一个叫做**视觉格式化模型**的东西所定义的，BFC就是来自这个概念，它是CSS视觉渲染的一部分，**用于决定块级盒的布局及浮动相互影响范围的一个区域**。

简单来说，BFC是web页面的一块渲染区域，它有着自己的渲染规则，可以看做元素的一种属性，当元素拥有了BFC这个属性之后，这个元素就可以看作是隔离了的独立容器，容器里面的元素就不会在布局上影响到外面的元素。

创建BFC的方式：

1. 根元素（`<html>`）
2. 浮动元素（`float`属性不为`none`）
3. 绝对定位元素（`position`属性为`absolute`或`fixed`）
4. 行内块元素（`display`属性为`inline-block`）
5. 弹性盒子（`display`属性为`flex`或`inline-flex`）
6. 网格布局（`display`属性为`grid`或`inline-grid`）
7. 表格单元格（`display`属性为`table-cell`、`table-caption`、`inline-table`）
8. `overflow`属性值不为`visible`的块级容器
9. `contain`属性值为`layout`、`content`或`paint`的元素
10. 多列容器（元素的`column-count`或`column-width`不为`auto`，包括`column-count`为1）

BFC具有一些特性：

1. 块级元素会在垂直方向一个接一个的排列，和文档流的排列方式一致；
2. 在BFC中上下相邻的两个容器的`margin`会重叠，创建新的BFC可以避免外边距重叠；
3. 计算BFC的高度时，需要计算浮动元素的高度；
4. BFC区域不会与浮动的容器发生重叠；
5. BFC是独立的容器，容器内部元素不会影响外部元素；
6. 每个元素的左`margin`值和容器的左`border`相接触。

利用特性，可以解决以下问题：

1. 利用`特性4`和`特性6`，我们可以实现三栏（或两栏）自适应布局；

2. **外边距重叠**，利用`特性2`，我们可以避免`margin`重叠问题，也就是外边距重叠问题；

注意，包裹了container的div之后，container的`overflow:hidden;`属性触发BFC，所以两个BFC的子元素不影响外边距

<img src="https://s2.loli.net/2023/04/07/Ikeba81vc42dt7B.png" alt="image-20230407112020880" style="zoom:30%;" />

<img src="https://s2.loli.net/2023/04/07/Y6Vmu2z8BvQqeGF.png" alt="image-20230407112109400" style="zoom:30%;" />



3. 利用`特性3`，我们可以避免高度塌陷。

4. **清除浮动**，利用`特性3`，可以使浮动元素框定在BFC里浮动

由于cube元素设置了浮动属性，脱离了普通流，所以并没有被限制在container的元素中，container仅仅是高度为2px的border框，container的`overflow:hidden;`属性触发BFC，可以消除子元素的浮动在container外的影响，可以在container里浮动

<img src="https://s2.loli.net/2023/04/07/E49Af1vxbIRJmPL.png" alt="image-20230407112518145" style="zoom:30%;" />

<img src="https://s2.loli.net/2023/04/07/sGMZ3yp6jqEkUtc.png" alt="image-20230407113151294" style="zoom:30%;" />

5. **阻止元素被浮动元素覆盖**，利用`特性4`，可以阻止元素被浮动元素覆盖

floatDiv设置了浮动，而normalDiv没有，所以被覆盖，如果给normalDiv设置BFC，就会消除覆盖效果

<img src="https://s2.loli.net/2023/04/07/NaClcp2rFxKvLsX.png" alt="image-20230407113900907" style="zoom:30%;" />

<img src="https://s2.loli.net/2023/04/07/DvMq2zZpkUVIQbC.png" alt="image-20230407114000466" style="zoom:30%;" />

#### 实现两栏布局

两栏布局指的是左侧固定+右侧自适应布局

现在有以下DOM结构，请编写CSS样式实现两栏布局

```css
<div class="container">
    <div class="left"></div>
    <div class="right"></div>
</div>
```

1. 利用浮动，左边元素宽度固定 ，设置向左浮动。将右边元素的 `margin-left` 设为固定宽度 。注意，因为右边元素的 `width` 默认为 `auto` ，所以会自动撑满父元素。

```css
        .container {
            height:100px;
        }
        .left {
            float: left;
            width:200px;
            height:100%;
            background: red;
        }
        .right {
            margin-left: 200px;
            height: 100%;
            background: green;
        }
```

2. 利用浮动，左边元素宽度固定，设置向左浮动。将右边元素设置为`overflow:hidden;`，右边即可触发`BFC`，`BFC`的区域不会与浮动元素发生重叠，所以左右两侧就不会发生重叠。

```css
        .container {
            height:100px;
        }
        .left {
            float: left;
            width:200px;
            height:100%;
            background: red;
        }
        .right {
            overflow:hidden;
            height: 100%;
            background: green;
        }
```

3. 利用flex布局，左边元素宽度固定，右边的元素设置为`flex:1;`

```css
        .container {
            display: flex;
            height:100px;
        }
        .left {
            float: left;
            width:200px;
            height:100%;
            background: red;
        }
        .right {
            flex: 1;
            height: 100%;
            background: green;
        }
```

4. 利用绝对布局，父级元素设为相对定位，左边元素设为`position:absolute;`定位，并且宽度固定，右边元素的`margin-left`值设为左边元素的宽度值。

```css
        .container {
            position:relative;
            height:100px;
        }
        .left {
            position: absolute;
            width:200px;
            height:100%;
            background: red;
        }
        .right {
            margin-left: 200px;
            height: 100%;
            background: green;
        }
```

#### 实现圣杯布局和双飞翼布局

圣杯布局和双飞翼布局就是经典的三分栏布局，其目的是：

* 三栏布局，中间一栏最先加载和渲染（这部分内容最重要，这也就是为什么要了解这种布局的原因）；
* 两侧内容固定，中间内容随着宽度自适应；
* 一般用于PC网页。

1. 圣杯布局

HTML结构

```html
    <div class="container">
        <div class="main-content">主要内容</div>
        <div class="left-sidebar">左侧栏</div>
        <div class="right-sidebar">右侧栏</div>
    </div>
```

CSS布局

```css
        /* 无论三列的高度如何变化，中间栏都会自动填充空白 */
				.container {
            display: flex; /* 父容器弹性布局 */
            justify-content: space-between; /*将子元素分别放置左、中、右*/
            width: 100%;
        }

        .main-content {
            flex: 1; /* 将中间栏设置为自适应宽度 */
            order: 2;
            background: red;
        }

        .left-sidebar {
            width: 200px;
            order: 1;
            background: green;
        }

        .right-sidebar {
            width: 200px;
            order: 3;
            background: blue;
        }
```

2. 双飞翼布局

HTML结构：

```html
<div class="container">
  <div class="main-content"> <!-- 使用一个float:left的中间栏，让它先展示在页面上，同时里面再包裹一个子元素作为实际内容 -->
    <div class="inner">主要内容</div>
  </div>
  <div class="left-sidebar">左侧栏</div>
  <div class="right-sidebar">右侧栏</div>
</div>
```

CSS布局

```css
        .container {
            width: 100%;
        }

        .main-content {
            float: left;
            width: 100%;
            background: red;
        }

        .main-content .inner {
            margin: 0 200px 0 200px; /*0 左栏宽度 0 右栏宽度*/
        }

        .left-sidebar { /*使用负的margin-left来将左侧栏向左移动，腾出与中间栏相对应的空间，margin值为固定宽度。*/
            float: left;
            width: 200px;
            margin-left: -100%; /* margin-left相对的是父元素的content，不包括padding和border */
            background: green;
        }

        .right-sidebar { /*使用负的margin-left来将右侧栏向左移动，腾出与中间栏相对应的空间，margin值为它宽度加中间栏的宽度。*/
            float: left;
            width: 200px;
            margin-left: -200px;
            background: blue;
        }
```

#### 水平垂直居中多种实现方式

1. 使用flex布局

```css
        .father {
            display: flex; /* 设置flex布局 */
            justify-content: center; /* 水平居中 */
            align-items: center; /* 垂直居中 */
        }
```

2. 使用grid布局

```css
        .father {
            display: grid; /* 设置grid布局 */
            place-items: center; /* 水平、垂直居中 */
        }
```

3. 使用绝对定位和transform，该方法可以不定宽高

```css
        .father {
            position: relative; /* 设置父元素相对布局 */
        }
        .son {
            position: absolute; /* 设置子元素绝对布局 */
            top: 50%; /* 将子元素的左上角移到父元素的垂直中心位置 */
            left: 50%; /* 将子元素的左上角移到父元素的水平中心位置 */
            transform: translate(-50%, -50%); /* 将子元素的中心点移到父元素的中心位置 */
        }
```

4. 使用绝对定位和子元素所有方向为0，`margin:auto;`，该方法必须定宽高

```css
        .father {
            position: relative; /* 设置父元素相对布局 */
        }
        .son {
            position: absolute; /* 设置子元素绝对布局 */
            top: 0; /* 所有方向都为0 */
            right: 0;
            bottom: 0;
            left: 0;
            margin: auto; /* 将margin设置为auto，由于宽高固定，对应方向实现评分 */
            height: 100px;
            width: 100px;
        }
```

5. 使用绝对定位和负margin，该方法必须定宽高

```css
        .father {
            position: relative; /* 设置父元素相对布局 */
            width: 500px; /* 设置父元素宽高固定 */
            height: 500px;
        }

        .son {
            position: absolute; /* 设置子元素绝对布局 */
            top: 50%; /* 将子元素的左上角移到父元素的垂直中心位置 */
            left: 50%; /* 将子元素的左上角移到父元素的水平中心位置 */
            width: 200px; /* 设置父元素宽高固定 */
            height: 200px;
            margin-left: -100px; /* 子元素自己的一半宽高进行负值赋值，将子元素的左上角移到父元素的水平中心位置 */
            margin-top: -100px;
        }
```

6. 使用table-cell

```css
        .father {
            display: table-cell; /* 设置父元素table-cell布局 */
            text-align: center; /* 设置子元素水平居中 */
            vertical-align: middle;  /* 设置子元素垂直居中 */
        }
```

#### flex布局

1. 定义

flex布局是flexible box的缩写，意为“弹性布局”，用来为盒装模型提供最大的灵活性

```css
display: flex; /* 弹性盒子 */
display: inline-flex; /* 行内弹性盒子 */
display: -webkit-flex; /* webkit内核浏览器弹性盒子，如safari */
```

2. 容器属性

* flex-direction：属性决定主轴的方向，即项目的排列方向

```css
flex-direction: row | row-reverse | column | column-reverse; /* 垂直方向|逆垂直方向|水平方向|逆水平方向 */
```

* flex-wrap：属性决定，如果主轴线一条轴线排不下，如何换行

```css
flex-wrap: nowrap | wrap | wrap-reverse; /* 不换行 | 换行，第一行在上方 | 换行，第一行在下方 */ 
```

* flex-flow：属性为flex-direction属性和flex-wrap属性的简写形式

```css
flex-flow: <flex-direction> || <flex-wrap>;
flex-flow: row nowrap; /* 默认值 */
```

* justify-content: 属性决定了项目在主轴的对齐方式

```css
justify-content: flex-start | flex-end | center | space-between | space-round;
/* row情况：左对齐|右对齐|居中|两端对齐，项目之间间隔均等|项目两侧的间隔相等，并且项目之间的间隔是项目两端的间隔两倍 */
```

* align-items：属性决定了项目在交叉轴的对齐方式

```css
align-items: flex-start | flex-end | center | baseline | stretch;
/* column情况：顶对齐|底对齐|中点对齐|项目第一行文字基线对齐|如果项目未设置高度或设为auto，项目将拉伸为整个容器高度 */
```

* align-content：属性定义了多根轴线的对齐方式，**如果项目只有一条轴线，该属性不起作用**

```css
align-content: flex-start | flex-end | center | space-between | space-around | stretch;
/*与交叉轴的起点对齐|与交叉轴的终点对齐|与交叉轴的中点对齐|与交叉轴两端对齐，轴线之间的间隔平均分布|每根轴线两侧的间隔都相等，轴线之间的间隔比轴线与边框的间隔大一倍|轴线占满整个交叉轴*/
```

3. 项目的属性

* order：属性定义项目的排列顺序，数值越小，排列越靠前，默认为0

<img src="https://s2.loli.net/2023/04/10/CQZWJsOh9vYzjfR.png" alt="img" style="zoom:50%;" />

* flex-grow：属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大

<img src="https://s2.loli.net/2023/04/10/1OCsKmiTl2PXWfk.png" alt="img" style="zoom:50%;" />

* flex-shrink：属性定义项目的缩小比例，默认为1，如果空间不足，项目将缩小，如果所有项目的`flex-shrink`属性都为1，当空间不足时，都将等比例缩小。如果一个项目的`flex-shrink`属性为0，其他项目都为1，则空间不足时，前者不缩小

<img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg" alt="img" style="zoom:50%;" />



* flex-basis：属性定义了在分配多余空间之前，项目占据的主轴空间
* flex：属性是flex-grow、flex-shrink、flex-basis的简写，后两个属性可选

```css
flex:flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]
/* 默认值 0 1 auto， auto(1 1 auto)， none(0 0 auto) */
```

* align-self：属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性，默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch

```
 align-self: auto | flex-start | flex-end | center | baseline | stretch;
```

<img src="https://s2.loli.net/2023/04/10/M7YvseqNG8IPhfR.png" alt="img" style="zoom:50%;" />

#### line-height如何继承

```css
line-height: 30px; /* 写明具体数值，则子元素继承该数值 */
line-height: 1.5; /* 写明具体比例，则子元素继承该比例 */
line-height: 200%; /* 写明百分比，则子元素继承的是父元素font-size * 百分比 */
```

## JS
### 数据类型
1. 基本数据类型
    JS中共有8种数据类型，分别为`Undefined`、`Null`、`Boolean`、`Number`、`Stirng`、`Object`、`Symbol`、`BigInt`；

  除`Object`为引用数据类型(存在在heap堆内存中)外，其余七个数据类型都是基本数据类型(存储在stack栈内存中)。

  其中，`Symbol`和`BigInt`是ES6新增的数据类型，可能会被单独提问：
* Symbol代表独一无二的值，最大的用法是用来定义对象的唯一属性名；
* BigInt可以表示任意大小的整数。
2. 值类型的赋值变动
```js
let a = 100;
let b = a;
a = 200;
console.log(b);//100
```
<img src="https://s2.loli.net/2023/04/11/6VBEtx73hZqLlAK.webp" alt="图片 1.png" style="zoom:50%;" />
值类型是直接存储在**栈(stack)**中的简单数据片段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。

3. 引用类型的赋值变动
```js
let a = { age:20 };
let b = a;
b.age = 30;
console.log(a.age);//30  
```
<img src="https://s2.loli.net/2023/04/11/7vzjoLB8abrI9X4.webp" alt="图片 2.png" style="zoom:50%;" />
引用类型存储在**堆(heap)**中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能。

### 数据类型的判断

1. `typeof`：能判断所有**值类型和函数**，不可对**null、object、数组**进行精确判断，并都会返回object

```js
console.log(typeof undefined); // undefined
console.log(typeof 2); // number
console.log(typeof true); // boolean
console.log(typeof "str"); // string
console.log(typeof Symbol("foo")); // symbol
console.log(typeof 2172141653n); // bigint
console.log(typeof function () {}); // function
// 不能判别
console.log(typeof []); // object
console.log(typeof {}); // object
console.log(typeof null); // object
```

2. `instanceof`：能判断**对象**类型，不能判断基本数据类型，其内部运行机制是**判断在其原型链中能否找到该类型的原型**

```js
class People {}
class Student extends People {}
const vortesnail = new Student();
console.log(vortesnail instanceof People); // true
console.log(vortesnail instanceof Student); // true
```

### 深拷贝和浅拷贝

1. 定义

* 浅拷贝：拷贝对象的引用，对象之间仍然有引用关系；

```js
let obj1 = {
  a: 1,
  b: {
    c: 2
  }
}
let obj2 = obj1;  // 浅拷贝,obj2 和 obj1 指向同个对象的引用地址
obj2.a = 2;
console.log(obj1.a); // 2
```

* 深拷贝：拷贝对象的实际值，对象之间没有任何引用关系。

```js
let obj1 = {
  a: 1,
  b: {
    c: 2
  }
}
let obj2 = JSON.parse(JSON.stringify(obj1));  // 深拷贝,obj2和obj1指向不同对象的引用地址
obj2.a = 2;
console.log(obj1.a); // 1
obj2.b.c = 3;
console.log(obj1.b.c); // 2
```

2. 深拷贝实现

* JSON.parse(JSON.stringfy(obj))

```js
let obj1 = {
  a: 1,
  b: {
    c: 2
  }
}
let obj2 = JSON.parse(JSON.stringfy(obj1)) //最简单深拷贝，但是无法拷贝函数、正则表达式
```

* 序列化后再反序列化，与JSON序列化反序列化同理

```js
let obj1 = {
  a: 1,
  b: {
    c: 2
  }
}
let obj2 = eval('(' + obj1.toSource() + ')') //原理同上，但是效率稍低
```

* 手动遍历对象属性进行深拷贝

```js
function deepClone(obj) {
  if (typeof obj !== 'object' || obj === null) { // 如不是object或object为null，直接返回obj
    return obj;
  }
  let result = Array.isArray(obj) ? [] : {}; //根据obj类型，初始化result类型
  for (const key in obj) {
    result[key] = deepClone(obj[key]); //递归调用deepClone
  }
} 

```

* 第三方库lodash的_.cloneDeep()方法

```js
let obj1 = {
  a: 1,
  b: {
    c: 2
  }
}
let _ = require("lodash");
let obj2 = _.cloneDeep(obj)
```

### JS解释0.1+0.2！==0.3问题，讲讲IEEE 754，如何使其相等？

1. IEEE 754是一种二进制浮点数算数标准，它包括了单精度和双精度浮点表示等多种形式的数字编码，它可以解决一些精度问题，由于二进制无法完全准确地表示一些小数，例如0.1和0.2，可能会导致舍入误差，也就导致了在JS中`0.1+0.2!==0.3`的问题。
2. 解决方案：

* 使用`toFixed()`方法，该方法可以将一个数字四舍五入为一个指定小数位数的字符串，从而解决舍入误差问题

```js
const sum = (0.1 + 0.2).toFixed(1);
console.log(sum === '0.3'); //true
```

* 使用`Number.EPSILON`，用于表示1和大于1的最小浮点数之间的差，它可以用来比较两个浮点数的差是否在可接受范围内

```js
function isEqual(num1, num2) {
  return Math.abs(num1 - num2) < Number.EPSILON;
}
console.log(isEqual(( 0.1 + 0.2 ), 0.3)); //true
```

* 使用第三方库方法，如lodash，BigDecimal等

```js
const _ = require("lodash");
const sum = 0.1 + 0.2;
const target = 0.3;
console.log(_.isEqual(sum, target)); // true
```

### 原型和原型链

1. 原型、原型链相等关系理解

* JS分为**函数对象**和**普通对象**，它有两个属性，`constructor`和`__proto__`；
* Object、Function都是js内置的**函数**，类似的还有我们常用到的Array、RegExp、Date、Boolean、Number、String等；
* 属性`__proto__`是一个对象，它有两个属性，`constructor`和`__proto__`；
* 原型对象prototype有一个默认的constructor属性，用于记录实例是由哪个构造函数创建。

2. 原型对象(prototype)、构造函数(constructor)、对象实例(instance)三者之间的关系

   ```js
   // 1. 声明构造函数
   function Man(name) {
     this.name = name;
   }
   // 2. 打印Man的原型对象看一下
   console.log(Man.prototype); // Object类型的空对象
   // 3. 在Man的原型对象上添加getName方法
   Man.prototype.getName = function() {
     console.log(this.name);
   }
   // 4. 使用构造函数创建对象实例
   var d = new Man('张三');
   d.getName(); // 张三
   console.log(d); // d对象如下
   ```

   <img src="https://s2.loli.net/2023/05/03/TJgq1KHVZBD635W.webp" alt="img" style="zoom:50%;" />

通过以上的代码例子和结果进行分析，我们可以得出原型对象(prototype)、构造函数(constructor)、对象实例(instance)三者之间的关系

<img src="https://s2.loli.net/2023/05/03/h4q512ia7GFUZE6.webp" alt="img" style="zoom:50%;" />

得出结论如下：

* 构造函数`Man`可以通过`prototype`属性访问到它的原型对象；
* 通过构造函数`Man`实例化出来的`d`可以通过`__proto__`属性访问到`Man`的原型对象；
* `Man`的原型对象可以通过`constructor`属性访问其关联的构造函数。

我们可以通过三种方式来访问原型对象：

* 构造函数`prototype`；
* 实例对象`__proto__`；
* `object.getPrototypeof`(实例对象)。

3. JS之父在设计JS原型、原型链的时候遵从以下两个准则

* 准则1：原型对象的constructor指向构造函数本身；
* 准则2：实例的`__proto__`原型对象指向同一个地方。

```js
function Person(name, age) {
	this.name = name;
	this.age = age;
}
let person01 = new Person('小明', 18);
Person.prototype.constructor == Person; //准则1：原型对象（即Person.prototype）的constructor指向构造函数本身
person01.__proto__ == Person.prototype; //准则2：实例（即person01）的__proto__和原型对象指向同一个地方
```

3. 原型和原型链的意义：原型对象的作用，是用来存放实例中共有的那部分属性和方法，可以大大减少内存消耗
4. 总结：

* 原型：每一个js对象(null除外)，在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型“继承”属性，其实就是prototype对象；
* 原型链：由相互关联的原型组成的**链状结构**就是原型链。

最好利用一段代码和一张图把原型和原型链讲清楚

```js
//1. 从图上方function Foo()分析
function Foo() {}
let f1 = new Foo();
let f2 = new Foo();
f1.__proto__ = Foo.prototype;
f2.__proto__ = Foo.prototype;
Foo.prototype.__proto__ = Object.prototype;
Object.prototype.__proto__ = null;
Foo.prototype.constructor = Foo;
Foo.__proto__ = Function.prototype;
Function.prototype.__proto__ = Object.prototype;
Object.prototype.__proto__ = null;
//2. 从图中间function Object()分析
function Object() {}
let o1 = new Object();
let o2 = new Object();
o1.__proto__ = Object.prototype;
o2.__proto__ = Object.prototype;
Object.prototype.__proto__ = null;
Object.prototype.constructor = Object;
Object.__proto__ = Function.prototype;
Function.prototype.__proto__ = Object.prototype;
Object.prototype.__proto__ = null;
//3. 从图下方function Function()分析
function Function() {}
Function.__proto__ = Function.prototype;
Function.prototyep.constructor = Function;
// 总结：除了Object.prototype.__proto__指向null，其他内置和自定义构造的函数都指向Object.prototype
Object.prototype.__proto__ = null;
Array.prototype.__proto__ = Object.prototype;
Foo.prototype.__proto__  = Object.prototype;
```



![WechatIMG114.jpeg](https://s2.loli.net/2023/04/11/hF7bIDfnzu1iGrA.webp)

### 作用域与作用域链

1. 作用域：在JS中，作用域是指变量和函数可以被访问的区域；JS中拥有两种作用域：**全局作用域**和**局部作用域**；在函数中，变量和函数的作用域定义了它们被访问的**位置**和**时机**。

* 全局作用域：指在代码中任何位置都可以访问的变量和函数，在浏览器中，全局作用域指的是window对象，在Node.js中指的是global对象；
* 局部作用域：指在函数内部定义的变量和函数，只能在函数内部访问，局部作用域可以避免函数和全局作用域中的变量和函数名冲突。

2. 作用域链：指从当前作用域向上查找变量和函数的过程，在JS中，每个函数都有一个作用域链，由当前函数的变量对象和外部函数的活动对象组成；当访问一个变量或函数时，JS引擎会从当前函数的变量对象开始查找，如果在当前作用域中找到了相应的变量或函数，直接返回该变量或函数，如果没有找到，则沿着作用域链向上查找，直到找到全局作用域为止。

```js
//innerFunction() 可以访问全局作用域中的 globalVar 变量、外部函数 outerFunction() 的变量 outerVar，以及自身的局部变量 innerVar。在访问这些变量时，JavaScript 引擎会沿着作用域链向上查找，直到找到相应的变量或函数为止。
var globalVar = "Hello, world!";
function outerFunction() {
  var outerVar = "Hello from outer function!";
  function innerFunction() {
    var innerVar = "Hello from inner function!";
    console.log(globalVar, outerVar, innerVar);
  }
  return innerFunction;
}
var fn = outerFunction();
fn(); // 输出 "Hello, world!" "Hello from outer function!" "Hello from inner function!"
```

### 执行上下文

每次执行JS代码时，都会创建一个对应的执行上下文，执行上下文指的是JS引擎用来跟踪代码执行流的一种机制，它由三个部分组成：

- 变量对象(Variable Object，VO)
- 作用域链(Scope Chain)
- this

1. 执行上下文栈：当JS执行一个函数时，会进行准备工作，这个准备工作就是创建 执行上下文(Execution Context)，如果JS执行多个函数，如何管理创建的那么多个执行上下文，所以JS引擎创建了执行上下文栈(Execution Context Stack, ECS)来管理执行上下文。

```js
/* 当JS开始要解释执行代码时，最先遇到就是全局代码，所以初始化的时候回向ECS压入一个globalContext*/
ECStack = [ globalContext ];
/* 例子：使用ECS解释执行JS代码 */
function fun3() {
    console.log('fun3')
}
function fun2() {
    fun3();
}
function fun1() {
    fun2();
}
fun1();
/* 伪代码解释 */
//执行fun1()
ECStack.push(<fun1> functionContext);
//调用执行fun2()
ECStack.push(<fun2> functionContext);
//调用执行fun3()
ECStack.push(<fun3> functionContext);
//fun3执行完毕
ECStack.pop();
//fun2执行完毕
ECStack.pop();
//fun1执行完毕
ECStack.pop();
// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext
```

2. 执行上下文中的变量对象：变量对象是与执行上下文相关的数据作用域，存储了在执行上下文中定义的变量和函数声明；由于不同执行上下文下变量对象稍有不同，这里主要解释全局上下文的变量对象和函数上下文的变量对象

* 全局上下文中的变量对象就是全局对象

```js
//1. 通过this应用全局对象，在客户端JS中，全局对象就是window对象
console.log(this); //window对象
//2. 全局对象是由Object构造函数实例化的一个对象
console.log(this instanceof Object); //true
//3. 全局对象中预定义了很多函数和属性
console.log(Math.random()); //均可生效
console.log(this.Math.random());//均可生效
//4. 全局变量是作为所有变量的宿主
var a = 1；
console.log(this.a); //1
//5. 在客户端JS中，全局对象有window属性指向本身
var a = 1;
console.log(window.a); //1
this.window.b = 2;
console.log(this.b); //2
```

* 函数上下文的变量对象就是用活动对象(Activation Object, AO)来表示，活动对象是在进入函数上下文时被创建的，只包括Arguments对象

```js
//举例说明,首先处理函数声明，然后处理变量声明，还需要给AO添加形参
function foo(a) {
  var b = 2;
  function c() {}
  var d = function() {};
  b = 3;
}
foo(1);
//进入函数执行上下文后，AO为
AO = {
  arguments: {//函数的入参...arguments
    0: 1,
    length: 1
  },
  a: 1,
  b: undefined,
  c: reference to function c(){},
  d: undefined
}
//执行完函数后，AO为
AO = {
  arguments: {//函数的入参...arguments
    0: 1,
    length: 1
  },
  a: 1,
  b: 3,
  c: reference to function c(){},
  d: reference to FunctionExpression 'd'
}
```

3. 执行上下文中的作用域链：当JS执行解释代码时，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级执行上下文的变量对象中查找，一直找到全局上下文的变量对象，就是全局对象，这样由多个执行上下文的变量对象构成的链表就叫做作用域链。

```js
//举例说明
function foo() {
    function bar() {
        ...
    }
}
//函数创建时，各自的[[scope]]
foo.[[scope]] = [
  globalContext.VO
];
bar.[[scope]] = [
    fooContext.AO,
    globalContext.VO
];
```

4. 使用例子总结一下函数执行上下文中作用域链和变量对象的创建过程

```js
var scope = "global scope";
function checkscope(){
    var scope2 = 'local scope';
    return scope2;
}
checkscope();
//1. checkscope函数被创建，保存作用域链到内部属性[[scope]]
checkscope.[[scope]] = [
    globalContext.VO
];
//2. 执行checkscope函数，创建checkscope函数执行上下文，checkscope函数执行上下文被压入执行上下文栈
ECStack = [
    checkscopeContext,
    globalContext
];
//3. checkscope函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链
checkscopeContext = {
    Scope: checkscope.[[scope]],
}
//4. 第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明
checkscopeContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope2: undefined
    }，
    Scope: checkscope.[[scope]],
}
//5. 第三步：将活动对象压入 checkscope 作用域链顶端
checkscopeContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope2: undefined
    },
    Scope: [AO, [[Scope]]]
}
//6. 准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值
checkscopeContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope2: 'local scope'
    },
    Scope: [AO, [[Scope]]]
}
//7. 查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出
ECStack = [
    globalContext
];
```

### JS的this原理

1. 问题的由来

学懂JavaScript语言，一个标志就是理解下面两种写法，可能有不一样的结果

```js
var obj = {
	foo: function() { console.log(this.bar) },
	bar: 1
};
var foo = obj.foo;
var bar = 2;
obj.foo(); //写法一，1
foo(); //写法二，2
```

这种差异的原因就在于函数体内部使用了`this`关键词，`this`指的是函数运行时所在的环境：

* 对于`obj.foo()`来说，`foo`运行在`obj`环境中，`this`指向`obj`；
* 对于`foo()`来说，`foo`运行在全局环境中，`this`指向全局环境。

但是函数的运行环境到底是如何决定的，会影响到this的指向，接下来就会讲述清楚这些东西。

2. JavaScript的数据结构

```js
var obj = { foo:5};
```

上面的代码将一个对象赋值给变量`obj`，JS引擎会先在内存里面，生成一个对象`{foo:5}`，然后把这个对象的内存地址赋值给变量`obj`，具体如下：

| 栈内存stack |          | 堆内存heap |         |
| ----------- | -------- | ---------- | ------- |
| key         | value    | key        | value   |
| obj         | 内存地址 | 内存地址   | {foo:5} |

也就是说，变量`obj`是一个内存地址的reference，如果要读取`obj.foo`，JS引擎先从obj拿到内存地址，再从内存地址读出原始的对象，然后返回原始对象的`foo`属性。

而原始的对象以字典结构保存，每一个属性名都对应一个属性描述的对象，具体如下

```js
{
  foo : {
    [[value]] : 5 //foo属性的值保存在属性描述对象的value里面
    [[writeable]] : true
    [[enumerable]] : true
    [[configurable]] : true
  }
}
```

3. 对象的属性是一个函数

这样的结构本来是十分清晰的，但问题在于属性的值可能是一个函数

```js
var obj = {
  foo : function() {}
};
```

这时的数据结构为

| 栈内存stack |          | 堆内存heap |                  |
| ----------- | -------- | ---------- | ---------------- |
| key         | value    | key        | value            |
| obj         | 内存地址 | 内存地址   | {foo:函数的地址} |

```js
{
  foo : {
    [[value]] : 函数的地址 //foo属性的值保存在属性描述对象的value里面，此时保存的是函数的内存地址
    [[writeable]] : true
    [[enumerable]] : true
    [[configurable]] : true
  }
}
```

由于函数是一个单独的值，所以可以在不同的环境(上下文)中执行：

```js
var f = function() {};
var obj = { f : f };
//单独执行，全局环境
f()
//obj环境执行
obj.f()
```

4. 环境变量的影响

JS允许在函数体内部，引用当前环境的其他变量，比如下面的代码中，函数体里使用了变量`x`，该变量由运行环境提供，由于函数可以在不同运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境，所以`this`就出现了，它的设计目的就是在函数体内部，代指函数当前的运行环境。

```js
var f = function () {
  console.log(this.x); //this.x 就是指当前运行环境的x
}
var x = 1;
var obj = {
  f: f,
  x: 2,
};
// 单独执行，this指向全局，this.x =》 1;
f() // 1 单独找到函数的内存地址？
// obj 环境执行 this指向obj, this.x =》 obj.x =》 2
obj.f() // 2
```

<img src="https://s2.loli.net/2023/04/12/O4zg8WV7frICTPA.png" alt="image-20230412150805517" style="zoom:50%;" />

### JS闭包

在某个内部函数的执行上下文创建时，会将父级函数的**活动对象(Activiation Object, AO)**加到内部函数的`[[scope]]`中，形成作用域链，所以即使父级函数的执行上下文销毁(即执行上下文栈弹出父级函数的执行上下文)，但是因为其**AO**还是实际存储在内存中可被内部函数访问到，从而实现了闭包。

面试必考的闭包题

```js
//未改闭包之前
var data = [];
for (var i = 0; i < 3; i++) {
  data[i] = function () {
    console.log(i);
  };
}
data[0](); //3
data[1](); //3
data[2](); //3
//改闭包之后
var data = [];
for (var i = 0; i < 3; i++) {
  data[i] = (function (i) {
    return function() {
      console.log(i);
    }
  })(i);
}
data[0](); //0
data[1](); //1
data[2](); //2
```

未改闭包前分析：

当执行到`data[0]`函数之前时，此时全局上下文的VO为：

```json
globalContext = {
  VO: {
    data: [...],
    i: 3       
  }
}
```

当执行`data[0]`函数的时候，`data[0]`函数的作用域链为：

```js
data[0]Context = {
  Scope: [A0, globalContext.VO]
}
```

`data[0]Context`的AO并没有i值，所以会从`globalContext.VO`中查找，i为3，所以打印结果就是3；同理`data[1]`、`data[2]`一样

改闭包之后分析：

当执行到`data[0]`函数之前时，此时全局上下文的VO为：

```json
globalContext = {
  VO: {
    data: [...],
    i: 3       
  }
}
```

当执行`data[0]`函数的时候，`data[0]`函数的作用域链为：

```js
data[0]Context = {
  Scope: [A0, 匿名函数Context.AO,globalContext.VO]
}
```

匿名函数执行上下文的AO为：

```js
匿名函数Context = {
	AO: {
		Arguments: {
			0: 0,
			length:1
		},
		i=0
	}
}
```

`data[0]Context`的AO并没有i值，所以会沿着作用域链从`匿名函数Context.VO`中查找，这时就会找到i为0，找到了就不会往`globalContext.VO`中查找，即使`globalContext.VO`也有i的值(i为3)，所以但打印的也会是0，同理，`data[1]`会打印1、`data[2]`会打印2。

### call/apply/bind的实现

call/apply/bind的实现还是必须掌握的，就算工作中不会自己手写，但是说不准面试会问，知道原理也可以拓宽我们编写代码的思路。

1. call方法，在使用一个指定的this值和若干个指定的参数值的前提下调用某个函数或方法；

举例说明，通过call方法我们做到了两点：

* call改变了this的指向，指向到了`obj`;
* 执行了`fn`函数。

```js
var obj = {
  value: 'vortesnail',
};
function fn() {
  console.log(this.value);
}
fn.call(obj);

```

手写call方法:

```js
//改变fn函数的this指向传入的context，并以args为入参列表执行fn函数
Function.prototype.myCall = function(context, ...args) {
  // 0. 判断调用对象是否为函数
  if (typeof this !== 'function') {
    throw new Error('TypeError');
  }
  // 1. 首先获取参数
 	context = context || window; //有传入的context就是用context，没有就默认为window
  // 2. 将函数本身作为context的一个属性
  context.fn = this;
  // 3. 执行要被调用的方法，并赋给返回参数
  const result = context.fn(...args);
  // 4. 手动删除增加的属性方法，避免影响context
  delete context.fn;
  // 5. 将执行结果返回
  return result;
}
```

2. apply方法，与call方法类似，就是传参不同

```js
Function.prototype.myApply = function (context, ...args) {
  // 0. 判断调用对象是否为函数
  if (typeof this !== 'function') {
    throw new Error('TypeError');
  }
  // 1. 首先获取参数
 	context = context || window; //有传入的context就是用context，没有就默认为window
  // 2. 创建一个独一无二的Symbol值，防止覆盖原有属性
  const fn = Symbol('fn');
  // 3. 将函数本身作为context的一个属性
  context[fn] = this;
  // 4. 执行要被调用的方法，并赋给返回参数
  const result = context[fn](...args);
  // 5. 手动删除增加的属性方法，避免影响context
  delete context.[fn];
  // 6. 将执行结果返回
  return result;
}
```

3. bind方法，返回的是一个函数

```js
Function.prototype.myBind = function (context, ...args1) {
  // 0. 判断调用对象是否为函数
  if (typeof this !== 'function') {
    throw new Error('TypeError');
  }
  // 1. 首先获取参数
 	context = context || window; //有传入的context就是用context，没有就默认为window
  // 2. 将函数本身作为context的一个属性
  context.fn = this;
  // 3. 将一个函数返回出去
  return function Fn(...args2) {
    return fn.apply(this instanceof Fn? this : context, args1.concat(...args2) );
  };
}
```

### new的实现

```js
function myNew(constructor, ...args) {//传入的constructor为一个类的构造函数
  // 1. 首先创建一个空对象，继承自构造函数的原型
  const obj = Object.create(constructor.prototype);
  // 2. 调用构造函数，并将obj绑定到this上
  const res = constructor.apply(obj, ...args);
  // 3. 如果构造函数返回的是对象，则返回对象，否则返回obj
  return typeof res === 'objcet' ? res : obj;
}
// 应用myNew，以下为构造函数
function Person(name, age) {
  this.name = name;
  this.age = age;
}
const p = myNew(Person, ['Tom', 30]);
console.log(p.name);  // Tom
console.log(p.age);  // 30
```

### JS异步

#### Event Loop

事件循环(Event Loop)是JavaScript的一种机制，用于管理任务和基于时间的触发器，它允许我们在主线程运行任务的同时，将其他任务加入事件队列。

主线程运行的任务如果将执行控制权放回主线程(例如，通过调用回调函数)，主线程将继续处理事件队列中的下一个任务。这个过程会一直持续，以此来管理多个等待调用的任务。

事件循环包含以下步骤：

1. 执行一段同步任务代码；
2. 对事件队列中是否待处理的事件或回调函数进行检查；
3. 如果有，执行队列中的第一个事件，然后跳转到第2步，如果没有，跳转到第1步。

一个简单的事件循环示例：

```js
console.log('Hi');
setTimeout(function cb() {
  console.log('cb'); //cb即callback
}, 5000);
console.log('Bye');
```

这里发生了：

1. 执行同步代码`console.log('Hi')`
2. 加入定时器回调函数到事件队列
3. 执行同步代码`console.log('Bye')`
4. 事件队列中有回调，执行`cb`并打印
5. 事件队列清空，循环结束

![屏幕录制 2021-07-19 15.01.09.gif](https://s2.loli.net/2023/04/19/D36j5Cwulbio7O4.webp)

Web APIs会创建对应的线程，比如`setTimeout`会创建定时器线程，`ajax`请求会创建http线程，这是由js的运行环境决定的，比如浏览器。

1.Call Stack调用栈空闲 -> 2.尝试DOM渲染 -> 3.触发EventLoop

即每次Call Stack清空(即每次轮询结束)，即同步任务执行完都是DOM重新渲染的机会，DOM机构有改变则重新渲染，然后再去触发下一次Event Loop。

#### 宏任务和微任务

在JavaScript的事件循环中，有两种任务：

1. 宏任务：需要在DOM渲染后触发，如`setTimeOut`、`setInterval`、`DOM事件`、`script`；

2. 微任务：DOM渲染前触发，如`Promise.then`、`MutationObserver`、Node环境下的`process.nextTick`。

这两种任务在事件循环的不同阶段执行：

1. 执行栈清空时，会检查微任务队列，如果存在微任务，就执行它们，直到微任务队列清空；
2. 如果微任务队列为空或执行完毕，就会从宏任务队列中取出第一个任务执行。

一个简单的例子：

```js
console.log('Start');
setTimeout(() => { //宏任务
  console.log('Timeout');
}, 0);
Promise.resolve().then(() => { //微任务
  console.log('Promise'); 
});
console.log('End');
// 依次输出
// Start
// End 
// Promise
// Timeout
```

执行顺序：

1. 同步代码`Start`
2. 加入Promise微任务和setTimeout宏任务
3. 同步代码`End`
4. 微任务队列有Promise，执行`Promise`
5. 微任务队列清空
6. 宏任务队列有setTimeout，执行`Timeout`
7. 宏任务队列清空，循环结束

#### JavaScript异步编程

在JavaScript的世界中，所有代码的都是在主线程这个线程单线程执行的，由于这个设计，所有操作将运行在一个线程中，无需考虑线程同步和资源竞争的开销，避免了线程之间的频繁切换和竞争问题，降低了开销，但是会导致JS所有网络操作、浏览器事件等，都必须是异步操作的。

JavaScript的异步执行可以用回调函数实现，回调函数嵌套会形成函数回调地狱，即一个函数执行完再执行内部的一个，层层嵌套。

```js
function callback() {
  console.log('Done');
}
console.log('before setTimeout()');
setTimeout(callback, 1000); //1s后调用callback函数
console.log('after setTimeout()');
/* 打印
before setTimeout()
after setTimeout()
(等待1秒后)
Done
*/
```

#### Promise

![promise](https://s2.loli.net/2023/04/24/u8nw26GcgDQ3AU7.png)

```js
// 定义Promise
const promise = new Promise((resolve, reject) => {
  // 未调用resolve和reject，Promise则一直处于pending状态
  if (true) {
    resolve(value); // 状态从pending -> fulfilled
  } else {
    reject(error); // 状态从pending -> rejected
  }
});
// 执行Promise
promise.then((value) => {
  //success, Promise fulfilled状态
})
promise.then((error) => {
  //fail, Promise rejected状态
})
// 定义Promise
function test(value) {
  return new Promise((resolve, reject) => {
    if(value>0) {
      resolve("大于0");
    } else {
      reject("小于0");
    }
  })
}
//执行Promise，then
test(1).then( value => {
  console.log('------', value);
})
//执行Promise，catch
test(-1).catch( value => {
  console.log('=======', value);
})
```

Promise A+规范例子

```js
// 5. 手写Promise A+规范，实现读取文件并进行粉刺统计
const fs = require('fs');
const getText = () => {
  return new Promise((resolve, reject) => {
    fs.readFile('./text.txt', (err, data) => {
      if (err) reject(err);
      resolve(data.toString);
    });
  })
}
const countWords = text => {
  return new Promise((resolve, reject) => {
    const words = text.split(' ');
    const count = words.length;
    resolve(count);
  })
}
getText()
.then( text => countWords(text))
.then(count => console.log(count))
.catch(err => {console.log(err)})
```

#### async/await

可以使用关键字`async`配合`await`调用`Promise`，实现异步操作，但代码却和同步写法类似：

```js
//async function定义一个异步函数，在async function内部，用await调用另一个异步函数，写起来和同步代码没有区别
async function get(url) {
  try {
    let res = await fetch(url);
  	return res.json();
  } catch ( e =>{ //async用try catch捕获错误
    
	})
}
//await调用
let res = await fetch(url);
//用promise实现
let promise = fetch(url);
promise.then((res) => {
  //拿到res
}).catch(e=>{
  //出错，拿到e
})
```

`await`调用必须在`async function`中，不能在传统的同步代码中调用，如何在用同步`function`中调用`async function`

```js
async function get(url) {
  let res = await fetch(url);
  return res.json();
}

function doGet() {
  //同步function中调用async function会返回一个promise
  let promise = get('/api/categories'); 
  promise.then(data=>{
    //拿到data
  })
}
```

#### async/await和Promise的关系

1. async函数会隐式返回一个Promise对象，可以用`.then()`和`.catch()`来处理它；
2. await函数只能在async函数内部使用，它会暂停async函数的执行，等待Promise解决，并返回解析值；
3. 如果await后的Promise被reject，则await会抛出错误，需要通过try/catch来捕获；
4. 任何一个await后的promise被reject，那么整个async函数都会被中断执行。

### 浏览器的垃圾回收机制

#### 浏览器垃圾回收策略

1. **标记清除**：标记阶段即为所有活动对象做上标记，清楚阶段则把没有标记(也就是非活动对象)销毁。
2. **引用计数**：把对象是否不再需要简化定义为对象有没有其他对象引用到它。如果没有引用指向该对象(引用计数为0)，对象被垃圾回收机制回收。

#### 标记清除的缺点

1. 缺点一：**内存碎片化**，内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块。
2. 缺点二：**分配速度慢**，因为即便是使用First-fit策略，其操作仍是一个O(n)的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢。

#### 引用计数的缺点

1. 缺点一：需要一个计数器，所占空间内存大，因为无法知道被引用数量的上限。
2. 缺点儿：无法解决循环引用导致的无法回收问题。

### 实现一个EventEmitter类

EventEmitter就是发布订阅模式的典型应用：

```js
// 0. 创建一个类
export class EventEmitter {
  // 1. 创建一个构造函数用来存放注册的事件与回调函数
  constructor() {
    this.events = {}
  }
  // 2. 实现增加监听某事件的on方法
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = [];
    } else {
      this.events[eventName].push(callback);
    }
  }
  // 3. 实现触发某事件的emit方法
  emit(eventName, ...args) {
    if (this.events[eventName]) {
      this.events[eventName].forEach(callback => {
        callback(...args);
      });
    }
  }
  // 4. 实现移除某事件的某个监听回调的off方法
  off(eventName, callback) {
    if (this.events[eventName]) {
      this.events[eventName] = this.events[eventName].filter(cb => cb !== callback);
    }
  }
  // 5. 实现移除某事件的全部监听回调的removeAllListeners方法
  removeAllListeners(eventName) {
    if (this.events[eventName]) {
      delete this.events[eventName];
    }
  }
}
```

## JS常见面试手写题

### typeof类型判断

```js
const myTypeOf = (data) => Object.prototype.toString.call(data).slice(8, -1).toLowerCase()
// 测试
console.log(myTypeOf(1)) //--> number
console.log(myTypeOf('1')) //--> string
console.log(myTypeOf(true)) //--> boolean
console.log(myTypeOf([])) //--> array
console.log(myTypeOf({})) //--> object
console.log(myTypeOf(/^/)) //--> regexp
console.log(myTypeOf(new Date())) //--> date
console.log(myTypeOf(Math)) //--> math
console.log(myTypeOf(() => {})) //--> function
```

### instanceof类型判断

```js
function myInstanceOf(left, right) {
  // 获取左边的原型链__proto__
  let proto = left.__proto__;
  // 获取右边的prototype
  let prototype = right.prototype;
  while(true) {
    if (proto === null) return false;
    if (proto === prototype) return true;
    //遍历原型链，看是否能找到prototype
    proto = proto.__proto__;
  }
}
```

### 数组去重

```js
const myUnique = array => [...new Set(array)]
// 测试
console.log(myUnique([1, 1, 2, 3])) //--> [1, 2, 3]
```

### 手写Ajax的GET方法

```js
function myAjaxGET(url) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    // 新建一个http请求
    xhr.open('GET', url, true);
    // 设置响应的数据类型
    xhr.setRequestHeader('Accept', 'application/json');
    // 设置状态的监听函数
    xhr.onreadystatechange = () => {
      if (this.readyState !== 4) return;
      // 当请求成功或失败时，改变Promise的状态
      if (this.status === 200) { 
        //业务层成功
        resolve(this.response);
      } else { 
        //业务层失败
        reject(new Error(this.statusText));
      }
      xhr.onerror = () => {
        //网络层失败
        reject(new Error(this.statusText));
      }
      // 发送http请求
      xhr.send(null)
    }
  }) 
}
```

### 防抖

在事件被触发n秒后再执行回调，如果在这n秒内事件又被触发，则重新计时，通常用于搜索框搜索、点击提交等。

```js
function debounce(fn, wait) {
  let timer = null
  return function(...args) {
    const ctx = this
    // 如果此时存在定时器的话，则取消之前的定时器重新记时
    if (timer) {
      clearTimeout(timer)
      timer = null
    }
    // 设置定时器，使事件间隔指定事件后执行
    timer = setTimeout(() => {
      fn.apply(ctx, args)
    }, wait)
  }
}
// 测试
const testFn = debounce(() => {
  console.log('函数防抖测试 - fn 执行了')
}, 2000)
// 定时器每 1000 毫秒执行一次 testFn 函数，等待时间未大于 2000 毫秒，所以 fn 永远不会执行
setInterval(testFn, 1000)
// 定时器每 3000 毫秒执行一次 testFn 函数，等待时间大于 2000 毫秒，所以 fn 会隔 3000 执行一次
setInterval(testFn, 3000) //--> 函数防抖测试 - fn 执行了
```

### 节流

规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效，通常用于窗口resize，scroll，输入框input，频繁点击等。

```js
const throttle = (fn, delay = 1000) => {
  // 上一次执行 fn 的时间
  let prevTime = 0

  // 将 throttle 处理结果当作函数返回
  return function(...args) {
    // 获取当前时间，转换成时间戳，单位毫秒 ms
    const nowTime = Date.now()
    // 将当前时间和上一次执行函数的时间进行对比
    // 大于间隔时间就把 prevTime 设置为当前时间并执行函数 fn
    if (nowTime - prevTime > delay) {
      prevTime = nowTime
      fn.apply(this, args)
    }
  }
}
// 测试
const testFn = throttle(() => {
  console.log('函数节流测试 - fn 执行了')
}, 1000)
// 定时器每 100 毫秒执行一次 testFn 函数，但是只有间隔时间差大于 1000 毫秒时才会执行 fn
setInterval(testFn, 100) //--> 函数节流测试 - fn 执行了
```

### call、apply、bind

call、apply和bind都适用来改变函数的this指向的，主要区别是接收参数的方式不同：

1. call，接收多个参数为入参

```js
Function.prototype.myCall = function(context = window, ...args) {
  // 将函数绑定到context上
  context.fn = this;
  // 执行该函数并构造返回值
  const result = context.fn(...args);
  // 删除绑定的函数
  delete context.fn;
  return result;
}
```

2. apply，接受数组参数为入参

```js
Function.prototype.myApply = function(context = window, args) {
  // 将函数绑定到context
  context.fn = this;
  // 执行该函数并构造返回值
  const result = context.fn(...args);
  // 删除绑定的函数
  delete context.fn;
  return result;
}
```

3. bind，不调用函数，但会返回一个新函数，称为绑定元素。当这个绑定函数被调用时，this指向bind的第一个参数，之后的一系列参数将会在传递的实参钱传入作为它的参数

```js
Function.prototype.myBind = function(context = window, ...args1) {
  const fn = this;
  // 返回一个新的函数，调用该新函数时绑定当前函数的this指向和传入的参数，通过apply实现
  return function(...args2) {
    return fn.apply(context, [...args1, ...args2]);
  }
}
```

### 浅拷贝和深拷贝

1. 浅拷贝

```js
function shallowCopy(object) {
  // 只拷贝对象类型的数据
  if (!object || typeof object !== 'object') return
  // object 如果是数组类型就新建一个空数组，否则新建空对象
  const newObject = Array.isArray(object) ? [] : {}
  // 遍历 object，进行属性拷贝
  for (const key in object) {
    if (object.hasOwnProperty(key)) {
      newObject[key] = object[key]
    }
  }
  return newObject
}
// 测试
const obj1 = { x: 1, y: 2, z: 3 }
const obj2 = shallowCopy(obj1)
console.log(obj2) //--> { x: 1, y: 2, z: 3 }
const arr1 = [1, 2, 3]
const arr2 = shallowCopy(arr1)
console.log(arr2) //--> [1, 2, 3]
```

2. 深拷贝

```js
function deepCopy(object) {
  // 只拷贝对象类型的数据
  if (!object || typeof object !== 'object') return
  // object 如果是数组类型就新建一个空数组，否则新建空对象
  const newObject = Array.isArray(object) ? [] : {}
  for (const key in object) {
    if (object.hasOwnProperty(key)) {
      // object[key] 如果是对象类型，则使用递归继续遍历拷贝属性
      newObject[key] = typeof object[key] === 'object' ? deepCopy(object[key]) : object[key]
    }
  }
  return newObject
}
// 测试
const obj1 = { x: 1, y: { z: 3 } }
const obj2 = deepCopy(obj1)
console.log(obj2) //--> { x: 1, y: { z: 3 } }
const arr1 = [1, [2, 3]]
const arr2 = deepCopy(arr1)
console.log(arr2) //--> [1, [2, 3]]
```

### 函数柯里化

函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。例如：`add(1,2,3,4,5)`转换成`add(1)(2)(3)(4)(5)`

```js
function curry(fn, ...args) {
  return fn.length <= args.length ? fn(...args) : curry.bind(null, fn, ...args)
}
// 普通函数测试
function fn(a, b, c, d, e) {
  console.log(a, b, c, d, e)
}
// 生成的柯里化函数
const _fn = curry(fn)
_fn(1, 2, 3, 4, 5) //--> 1 2 3 4 5
_fn(1)(2)(3, 4, 5) //--> 1 2 3 4 5
_fn(1, 2)(3, 4)(5) //--> 1 2 3 4 5
_fn(1)(2)(3)(4)(5) //--> 1 2 3 4 5
```

### Promise

```js
const PENDING = 'pending';
const FULFILLED = 'fulfilled';
const REJECTED = 'rejected';

class MyPromise {
  constructor(executor) {
    this.status = PENDING;
    this.value = null;
    this.reason = null;
    this.onFulfilledCallbacks = [];
    this.onRejectedCallbacks = [];

    const resolve = (value) => {
      if (this.status === PENDING) {
        this.status = FULFILLED;
        this.value = value;
        this.onFulfilledCallbacks.forEach(fn => fn());
      }
    }

    const reject = (reason) => {
      if (this.status === PENDING) {
        this.status = REJECTED;
        this.reason = reason;
        this.onRejectedCallbacks.forEach(fn => fn());
      }
    }

    try {
      executor(resolve, reject);
    } catch (err) {
      reject(err);
    }
  }

  then(onFulfilled, onRejected) {
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;
    onRejected = typeof onRejected === 'function' ? onRejected : err => { throw err };
    const promise2 = new MyPromise((resolve, reject) => {
      if (this.status === FULFILLED) {
        setTimeout(() => {
          try {
            const x = onFulfilled(this.value);
            resolvePromise(promise2, x, resolve, reject);
          } catch (err) {
            reject(err);
          }
        }, 0);
      }

      if (this.status === REJECTED) {
        setTimeout(() => {
          try {
            const x = onRejected(this.reason);
            resolvePromise(promise2, x, resolve, reject);
          } catch (err) {
            reject(err);
          }
        }, 0);
      }

      if (this.status === PENDING) {
        this.onFulfilledCallbacks.push(() => {
          setTimeout(() => {
            try {
              const x = onFulfilled(this.value);
              resolvePromise(promise2, x, resolve, reject);
            } catch (err) {
              reject(err);
            }
          }, 0);
        });
  
        this.onRejectedCallbacks.push(() => {
          setTimeout(() => {
            try {
              const x = onRejected(this.reason);
              resolvePromise(promise2, x, resolve, reject);
            } catch (err) {
              reject(err);
            }
          }, 0);
        });
      }
    });
    return promise2;
  }
}

function resolvePromise(promise2, x, resolve, reject) {
  if (promise2 === x) {
    return reject(new TypeError('Chaining cycle detected for promise'));
  }
  let called;
  if (x != null && (typeof x === 'object' || typeof x === 'function')) {
    try {
      let then = x.then;
      if (typeof then === 'function') {
        then.call(x, (y) => {
          if (called) return;
          called = true;
          resolvePromise(promise2, y, resolve, reject);
        }, (r) => {
          if (called) return;
          called = true;
          reject(r);
        });
      } else {
        resolve(x);
      }
    } catch (err) {
      if (called) return;
      called = true;
      reject(err);
    }
  } else {
    resolve(x);
  }
}
```

### EventBus

```js
class EventBus {
  constructor() {
    this.events = {};
  }
  // 添加订阅
  subscribe(event, callback) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(callback);
  }
  // 发布事件
  publish(event, ...args) {
    if (!this.events[event]) {
      return;
    }
    this.events[event].forEach(callback => callback(...args));
  }
  // 取消订阅
  unsubscribe(event, callback) {
    if (!this.events[event]) {
      return;
    }
    this.events[event] = this.events[event].filter(curCallback => curCallback !== callback);
  }
}
// 使用EventBus
const bus = new EventBus();
function foo(x, y) {
  console.log(x, y);
}
bus.subscribe('event1', foo);
bus.publish('event1', 1, 2); // 1 2
```

### 快速排序

```js
function quickSort(array) {
  if (array.length <= 1) {
    return array;
  }
  const pivot = array[0];
  const left = [];
  const right = [];
  for( let i =1; i<array.length; i++ ) {
    if (array[i] < pivot) {
      left.push(array[i]);
    } else {
      right.push(array[i]);
    }
  } 
  return [...quickSort[left], pivot, ...quickSort[right]];
}
```

### 数组扁平化

```js
Array.prototype.myFlat = function(depth = 1) {
  let result = [];
  for (let i = 0; i < this.length; i++) {
    if (Array.isArray(this[i]) && depth > 0) {
      result = result.concat(this[i].myFlat(depth - 1));
    } else {
      result.push(this[i]);
    }
  }
  return result;
}
```

### reduce

```js
Array.prototype.myReduce = function(fn, initialValue) {
  let accumulator;
  let startIndex;
  if (initialValue) {
    accumulator = initialValue;
    startIndex = 0;
  } else {
    accumulator = this[0];
    startIndex = 1;
  }
  for(let i = startIndex; i<this.length; i++) {
    accumulator = fn(accumulator, this[i], i ,this);
  }
}
```

### new

```js
function myNew(constructor, ...args) {
  // 1. 创建一个空对象，作为一个新对象实例
  let obj = {};
  // 2. 将这个实例对象的原型，指向构造函数的原型；
  obj = Object.create(constructor.prototype);
  // 3. 将构造函数的this指向这个新实例，并执行构造函数中的代码
  res = constructor.apply(obj, args);
  // 4. 如果构造函数返回一个非空对象，则返回这个对象，否则返回新实例对象
  return instanceof res === 'object'? res : obj;
}
```

## Web存储

`cookie`、`localStorage`、`sessionStorage`都是在浏览器存储数据的方式，它们的用途和自身特点各有不同。

### cookie

`cookie`是存储在客户端的一小段文本数据，通过`document.cookie`属性来访问和修改，主要用于存储一些基本数据和用户身份信息，有以下特点：

* 可通过浏览器设置过期时间；
* 只能存储文本数据，存储大小限制为4KB；
* 会随着http请求一起发送到服务端，带来安全性问题。

### localStorage

`localStorage`是一种H5新增的在客户端存储数据的方式，用于存储需要长久保存的数据，可以无需获取用户的许可，有以下的特点：

* 单个域名下永久保存，除非清除缓存；
* 存储的类型为`string`类型，但可以通过`JSON.stringfy()`和`JSON.parse()`将其他类型转换成`string`类型存储；
* 最大存储数据量一般为5MB，不同浏览器略有差别；
* 只能通过JavaScript获取和修改，安全性略高。

### sessionStorage

`sessionStorage`类似于`localStorage`，也是一种H5新增的在客户端存储数据的方式，主要用于当前会话数据的存储，具有以下特点：

* 数据存储于session中，浏览器关闭后数据会自动删除；
* 与`localStorage`的API完全一致，仅使用方式略有不同。

### localStorage 和 sessionStorage的区别

* `localStorage`数据会永久存储，除非代码删除(`removeItem`)和手动删除(`清除浏览器缓存`)；
* `sessionStorage`数据只存在于当前会话，浏览器关闭则清空；
* 一般用`localStorage`比`sessionStorage`多一些。

## HTTP知识

### HTTP状态码

1. 状态码分类

* 1XX - 服务器收到请求；
* 2XX - 请求成功，如200；
* 3XX - 重定向，如302；
* 4XX - 客户端错误，如404；
* 5XX - 服务端错误，如500。

2. 常见状态码

* 200 - 成功
* 301 - 永久重定向，配合location，浏览器自动处理
* 302 - 临时重定向，配合location，浏览器自动处理
* 304 - 资源未被修改
* 403 - 无权限
* 404 - 资源未找到
* 500 - 服务器错误
* 504 - 网关超时

3. 关于协议和规范

* 状态码都是根据约定出来的
* 要求大家都跟着执行
* 不要违反规范，例如IE浏览器

### HTTP缓存

1. 缓存介绍

* 什么是缓存?

HTTP缓存指的是浏览器和web代理根据HTTP协议的缓存机制，存储网页中的资源(如html、图片、css、js等)副本的技术。

* 为什么要使用缓存？

当用户再次访问该网页时，浏览器首先会检查是否有缓存的资源副本，如果有切过期时间尚未到达，就直接用缓存中的资源，避免重新下载，可以显著提高网页访问速度，因为HTTP请求相比于CPU计算和页面渲染来说是非常慢的。

* 哪些资源可以被缓存？

静态资源，比如html页面、CSS样式表、JS脚本、图片、字体文件、AJAX数据、视频、音频等。

2. 强制缓存

强制缓存(Cache-Control)是 HTTP 缓存机制中的一种方式,用于强制浏览器/代理服务器缓存某个资源，在Response Headers中显示。当服务器返回一个资源时,会在 HTTP 头中添加 Cache-Control 字段指定该资源的缓存方式和时间。

![图片 1.png](https://s2.loli.net/2023/04/23/bLg7FGkcRZe89Ws.webp)

如下例所示，浏览器会收到响应后将该资源缓存一小时，在这一小时内，如果再次请求同一个资源，浏览器会直接从缓存中读取，而不会发送请求到服务器。

```js
Cache-Control: max-age=3600 //缓存最大过期时间
Cache-Control: no-cache //可以在客户端存储资源，每次都必须去服务端做新鲜度校验，来决定从服务度获取新的资源(200)，还是使用客户端缓存(304)。
Cache-Control: no-store //永远都不要在客户端存储资源，永远都去原始服务器去获取资源。

```

3. 协商缓存(对比缓存)

协商缓存(Cache-Negotiate)是 HTTP 缓存机制中的一种方式，用于在浏览器/代理服务器和原服务器之间，通过条件请求和响应来确定缓存资源是否可用，在Response Headers中显示。当服务器返回一个资源时,会在 HTTP 头中添加 Cache-Control 字段指定该资源的缓存方式和时间。

![图片 2.png](https://s2.loli.net/2023/04/23/i26hCMIgX7DkBsf.webp)

```js
If-Modified-Since: Mon, 21 Oct 2019 06:30:00 GMT //指向客户端缓存资源的最后修改时间，格式为UTC时间戳 
If-None-Match: "33a64df551425fcc55e4d42a148795d9f25f89d4" //指向服务器返回的ETag，用于标识缓存资源的版本
If-Unmodified-Since: //用于确保缓存资源在指定时间内未被修改,主要用于写请求(POST/PUT/DELETE 等)。
```

4. 总结

   一图解释强制缓存和协商缓存

![](https://s2.loli.net/2023/04/23/DWSegmplQLOqAE9.webp)

5. 三种刷新操作对HTTP缓存的影响

| 刷新操作 | 刷新操作                            | 强制缓存影响 | 协商缓存影响 |
| -------- | ----------------------------------- | ------------ | ------------ |
| 正常操作 | 地址栏输入url，跳转链接，前进后退等 | 强制缓存有效 | 协商缓存有效 |
| 手动刷新 | F5，点击刷新按钮，右键菜单刷新      | 强制缓存失效 | 协商缓存有效 |
| 强制刷新 | Ctrl+F5，Shift+Command+R            | 强制缓存失效 | 协商缓存失效 |

### GET和POST请求的区别

1. 从**缓存**的角度，GET请求会被浏览器主动缓存下来，留下历史记录，而POST默认不会；
2. 从**编码**的角度，GET只能进行URL编码，只能接收ASCII字符，而POST没有限制；
3. 从**参数安全**的角度，GET一般放在URL中，因此不安全，POST放在请求体中，更适合传输敏感信息；
4. 从**幂等性**的角度，GET是幂等的，而POST不是幂等的(幂等表示执行相同的操作，结果也是相同的)；
5. 从**TCP**的角度，GET请求会把请求报文一次性发出去，而POST会分为两个TCP数据包，首先发header部分，如果服务器响应100(Continue)，然后发body部分。(火狐浏览器除外，它的POST请求只发一个TCP包)。

### TCP/IP协议

TCP/IP是Internet的基础通讯协议，全称是Transmission Control Protocol/Internet Protocol，它规定了数据如何在网络中传输的标准。

TCP/IP协议栈主要由四层组成：

* 网络接入层：定义了网络接口卡与网络媒介的物理连接；
* Internet层：主要负责数据的地址与路由选择，对应IP协议；
* 传输层：主要负责端到端的连接通信，对应TCP协议；
* 应用层：对应各种应用协议，如HTTP、FTP、SMTP等。

TCP/IP的主要协议及其作用：

* IP协议：网络层协议，负责数据的寻址、路由选择和数据包转发；
* ARP协议：用来获取网络设备的物理地址，用于IP地址与MAC地址的映射；
* TCP协议：传输层协议，面向连接，提供高可靠的字节流服务；
* UDP协议：传输层协议，无连接，提供高效的数据报文服务；
* ICMP协议：Internet控制消息协议，用于在网络设备之间传递控制消息；
* DHCP：动态主机配置协议，用于自动分配IP地址给网络设备；
* DNS：域名系统，用于域名与IP地址的映射；
* FTP：文件传输协议，用于文件传输；
* HTTP：超文本传输协议，用于网页传输。

### HTTP1.1和HTTP2.0

HTTP1.1和HTTP2.0都是超文本传输协议(HTTP)的版本，但有以下主要区别：

1. HTTP1.1：

* 发布于1999年，是目前广泛使用的HTTP版本；
* HTTP1.1是一个文本协议，消息头和消息体是明文传输；
* 采用请求-响应模型，是无状态的。要维持状态需要使用Cookie；
* 文件都是按顺序传输的，所以会阻塞其他资源的下载；
* 支持管道化(pipeling)，但实际中由于head-of-line blocking问题，并不常用。

2. HTTP2.0：

* 发布于2015年，旨在更快速和更高效地传输数据；
* HTTP2.0是二进制协议，更加紧凑。消息头被压缩，以二进制格式传输；
* 支持请求与响应的多路复用，弥补了head-of-line blocking问题；
* 引入流(stream)的概念，允许同时发送多个请求与响应，提高了并行度；
* 引入了头部压缩，减少了相同类型的首部被重复发送的次数；
* 支持服务器主动推送(server push)资源，减少了回复次数，提高速度。

3. HTTP2.0的改进

* 二进制分帧
* 头部压缩，首部名称更短
* 多路复用
* 服务器推送
* 可取消请求

### HTTPS原理

HTTPS是HTTP的安全版，它是一个指向网页的超链接的网络协议，HTTPS的全称是Hypertext Transfer Protocol Secure。

HTTPS与HTTP的主要区别是，HTTPS在HTTP的基础上增加了SSL/TLS层，这一层通过对网络连接的加密来保证连接的安全性和数据传输的机密性。

HTTPS的主要特点：

1. 加密传输：通过SSL/TLS对HTTP报文的数据加密，防止被窃听和中间人攻击；
2. 身份认证：通过证书验证网站的真实身份，防止用户被钓鱼网站欺骗；
3. 数据完整性：通过算法验证报文是否被篡改，防止用户接收到经过恶意修改的数据。

### WebSocket协议

1. WebSocket是一种网络通信协议，可在单个TCP连接上进行全双工通讯。它的特点是：

* 建立在TCP之上，HTTP握手阶段采用HTTP协议，之后的数据交换阶段采用自定义的WebSocket协议；
* 会话持续，双向通讯，没有同源限制，客户端可以与任意服务器通讯；
* 更小的请求头和较少的握手设置会话，使得数据交换更加高效；
* 可以发送文本和二进制数据。

2. WebSocket协议通常用于客户端和服务器之间的交互通讯，常见的应用场景：

* 聊天室--客户端和服务器可以在任意时间互相推送消息；
* 运动连播--服务器可以持续将运动数据推送给客户端显示；
* 游戏--可以在玩家之间进行实时互动；
* 监控系统--将实时数据推送到前端显示。

3. WebSocket连接的三个阶段：

* 握手阶段：客户端发送一个HTTP请求，与定义的WebSocket端点进行握手，如果连接成功建立，则进入第二阶段；
* 数据传输阶段：客户端和服务器可以在任何时候互相发送数据，数据可以是文本或二进制；
* 关闭阶段：任意一方关闭连接，进入关闭阶段，关闭状态下，服务端和客户端都不再发送数据。

### 跨域问题

1. 跨域，是指浏览器不能执行其他网站的脚本，它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制。

2. 同源，就是指域名、协议、端口均相同。

```
http://www.123.com/index.html 调用 http://www.123.com/abc.do （非跨域）
http://www.123.com/index.html 调用 http://www.456.com/abc.do （主域名不同:123/456，跨域）
http://abc.123.com/index.html 调用 http://def.123.com/server.do （子域名不同:abc/def，跨域）
http://www.123.com:8080/index.html 调用 http://www.123.com:8081/server.do（端口不同:8080/8081，跨域）
http://www.123.com/index.html 调用 https://www.123.com/server.do （协议不同:http/https，跨域）
```

3. CORS(跨来源资源共享)，通过添加HTTP头信息，使浏览器判断是否可以发起跨域访问。
4. 浏览器将跨域请求分为两类：简单请求和非简单请求，简单请求采取先请求后判断的方式，非简单请求采取预检请求的方式是否允许跨域访问。
5. 解决跨域通常采用服务端代理转发和配置CORS两种方式。

## Vue

### MVVM的理解

MVVM是Model-View-ViewModel的缩写，是一种软件架构设计模式。它可以很好的应用在前端开发中，主要目的是实现视图(View)和业务逻辑(Model)的分离。

MVVM的主要构成有：

* Model：模型层，用于管理数据；
* View：视图层，用于显示数据(HTML DOM元素)；
* ViewModel：视图模型层，起到桥梁作用，进行视图和模型层的双向数据绑定。

MVVM的工作流程是：

![在这里插入图片描述](https://s2.loli.net/2023/05/04/aqoy7QcCNHhlMFv.png)

- View监听ViewModel中的数据变化，ViewModel监听Model中的数据变化。
- 当Model的数据发生变化时，会通知ViewModel更新数据。
- ViewModel更新后，会通知View刷新视图，显示最新数据。
- 如果在View上更改了数据，则会通知ViewModel，然后ViewModel调用Model的方法进行数据更改。

MVVM的优点：

* 低耦合：View可以独立于Model变化和修改，一个ViewModel可以绑定到不同的View上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变；
* 可重用性：可以把一些视图逻辑放在一个ViewModel里，让很多View重用这段视图逻辑；
* 独立开发：开发人员可以专注于业务逻辑和数据的开发(ViewModel)，设计人员可以专注于页面的DOM；
* 可测试：当界面复杂度高的时候，通过MVVM可以使用ViewModel来测试业务逻辑，不用关注页面的DOM。

### Vue的优点

Vue是一个构建数据驱动的Web界面的渐进式框架，Vue的目标是通过尽可能简单的API实现响应数据的绑定和组合的视图组件，核心是响应的数据绑定系统。关于Vue的优点，主要有：

* 响应式编程：Vue会自动对页面中某些数据的变化做出响应，通过MVVM思想实现数据的双向绑定，让开发者不用再操作DOM对象，有更多的时间去思考业务逻辑；
* 组件化开发：可以把一个单页应用中的各种模块拆分到一个一个单独的组件中，可以提高开发效率、方便重复使用、简化调试步骤、提升整个项目的可维护性、便于同事间协同开发；
* 虚拟DOM：不同于jQuery和原生JavaScript DOM操作需要对DOM进行频繁操作，浏览器需要不停地渲染新的DOM树，导致性能开销大。而虚拟DOM是可以预先通过JavaScript进行各种计算，把最终的DOM操作计算出来并优化，由于这个DOM操作属于预处理操作，并没有真实的操作DOM，所以叫做虚拟DOM，最后在计算完毕时才真正将DOM操作提交，将DOM操作变化反映到DOM树上。

### Vue2和Vue3的生命周期

1. Vue的生命周期是指一个Vue实例从创建到销毁的过程。在生命周期的过程中会运行着一些叫做生命周期的函数，给予开发者在不同的生命周期阶段添加业务代码的能力。

<img src="/Users/luojing/Library/Application Support/typora-user-images/image-20230504224824684.png" alt="image-20230504224824684" style="zoom:50%;" />



| Vue2            | Vue3                | 生命周期函数含义                                             |
| --------------- | ------------------- | ------------------------------------------------------------ |
| `beforeCreate`  | `setup()`           | new Vue后的第一个生命周期函数，当前阶段data、methods、computed、watch的数据和方法均不能被访问。 |
| `created`       | `setup()`           | 在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发 updated 函数。可以做一些初始数据的获取，在当前阶段无法与 DOM 进行交互，如果非要想，可以通过 vm.$nextTick 来访问 DOM 。 |
| `beforeMount`   | `onBeforeMount`     | 发生在挂载之前，在这之前 template 模板已导入渲染函数编译。而当前阶段虚拟 DOM 已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发 updated。 |
| `mounted`       | `onMounted`         | 在挂载完成后发生，在当前阶段，真实的 DOM 挂载完毕，数据完成双向绑定，可以访问到 DOM 节点，使用 $refs 属性对 DOM 进行操作。 |
| `beforeUpdate`  | `onBeforeUpdate`    | 发生在更新之前，也就是响应式数据发生更新，虚拟 DOM 重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。 |
| `updated`       | `onUpdated`         | 发生在更新完成之后，当前阶段组件 DOM 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。 |
| `beforeDestroy` | `onBeforeUnmount`   | 发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。 |
| `destroyed`     | `onUnmounted`       | 发生在实例销毁之后，这个时候只剩下了 DOM 空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。 |
| `errorCaptured` | `onErrorCaptured`   |                                                              |
| `----`          | `onRenderTracked`   |                                                              |
| `----`          | `onRenderTriggered` |                                                              |

2. 第一次页面加载会触发哪些生命周期钩子函数

   触发4个钩子函数，beforeCreate、created、beforeMount、mounted。

3. DOM渲染在哪个周期就已经完成

   DOM渲染是在mounted阶段完成，此阶段真实的DOM挂载完毕，数据完成双向绑定，可以访问到DOM节点。

4. 父子组件中生命周期的调用顺序

* 加载过程：父beforeCreate -> 父created -> 父beforeMount -> 子beforeCreate -> 子created -> 子beforeMount -> 子mounted -> 父mounted。
* 子组件更新过程：父beforeUpdate -> 子beforeUpdate -> 子updated -> 父updated。
* 父组件更新过程：父beforeUpdate -> 父updated。
* 销毁过程：父beforeDestroy -> 子beforeDestroy ->  子destroyed ->  父destroyed

### Vue实现双向绑定的原理

1. Vue2采用数据劫持及结合发布订阅模式的方式，通过Object.defineProperty来劫持各个属性的setter和getter，在数据变动时发布消息给订阅者，触发相应的监听回调。

2. 当把一个普通JavaScript对象传给Vue实例来作为它的data选项时，Vue将遍历它的属性，用Object.defineProperty将它们转为getter/setter，用户看不到getter/setter，但是在内部它们让Vue追踪依赖，在属性被访问和修改时通知变化。
3. Vue的数据双向绑定整合了Observer、Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新 -> 视图交互变化的效果。
4. Vue3放弃了Object.defineProperty，使用ES6原生的Proxy，来解决以前使用Object.defineProperty所存在的一些问题。

### Vue2响应式原理

Vue在初始化数据时，会使用Object.defineProperty重新定义data中的所有属性，当页面使用对应属性时，首先会进行依赖收集（手机当前组件的watcher），如果属性发生变化会通知相关依赖进行更新操作，即发布订阅模式，可详细阐述vue实现双向绑定的原理。

### Vue2如何监测数组的变化

1. Vue2中实现检测数组变化的方法，是将数组的常用方法进行了重写，Vue将data中的数组原型方法进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组的api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控，这样就实现了监测数组变化。

2. Vue2监测数组的变化实现流程：
   * 初始化传入data数据执行initData；
   * 将数据进行观测new Observer；
   * 将数组原型方法指向重写的原型方法；
   * 深度观察数组中的引用类型。
3. Vue2中有两种情况，无法检测到数组的变化：
   * 当利用索引直接设置一个数组项时，例如`vm.items[indexOfItem]=newValue`，可用`vm.$set(vm.items, indexOfItem, newValue)`替代操作;
   * 当修改数组的长度时，例如`vm.items.length = newLength`，可用`vm.items.splice(newLength)`或`vm.$set(vm.items, 'length' ,newLength)`替代操作。

### Vue3响应式数据

1. Vue3中使用Proxy方法，替代了之前Object.defineProperty来实现响应式数据，因为：

- Object.defineProperty无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；
- Object.defineProperty只能劫持对象的属性，从而需要对每个对象，每个属性值进行遍历，如果，如果属性值是对象，还需要深度遍历；
- Proxy可以劫持整个对象，并返回一个新的对象；
- Proxy不仅可以代理对象，还可以代理数组，还可以dialing动态增加的属性；
- Proxy有多达13种拦截方法；
- Proxy作为新标准将受到浏览器厂商重点持续的性能优化。

但是Object.defineProperty作为老标准，对老机器的兼容性比ES6的Proxy要好

2. Proxy只会代理对象的第一层，Vue3通过当前Reflect.get的返回值是否为Object，如果是则通过reactive方法做代理，这样就实现了深度监测。
3. Proxy监测数组的时候可能触发多次 get/set，可以通过判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件，才有可能执行trigger。

### v-model双向绑定的原理

1. v-model本质就是value+input方法的语法糖，可以通过model属性的prop和event属性来进行自定义，原生的v-model，会根据标签的不同生成不同的事件和属性，例如：

* text和textarea元素使用value属性和input事件；
* checkbox和radio使用checked属性和change事件；
* select字段将value作为prop并将change作为事件。

2. Vue中需要执行以下3个步骤，实现数据的双向绑定：

* 实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者；
* 实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图；
* 实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据初始化相应的订阅器。

### Vue2和Vue3渲染器的diff算法

1. diff算法有以下过程：

* 同级比较，再比较子节点；
* 先判断一方有子节点一方没有子节点的情况（如果新的children没有子节点，将旧的子节点移除）；
* 比较都有子节点的情况，为核心diff算法；
* 递归比较子节点。

2. Vue2的核心Diff算法采用了双端比较的算法。
3. Vue3的核心Diff算法借鉴了ivi算法和inferno算法。

### Vue组件的参数传递

1. 父子组件的传值实现过程

* 父组件传给子组件：子组件通过props方法接受数据；
* 子组件传给父组件：使用自定义事件，子组件通过$emit方法触发父组件的方法来传递参数。

2. 兄弟组件的传值实现过程

	* 采用eventBus，创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。
	* 使用vuex进行状态管理
	* 共同的父组件作为媒介传递

### Vue的路由实现

1. Hash模式实现原理：Hash模式利用URL的hash部分来模拟完整URL，于是当URL发生改变时，页面不会重新加载；

* URL中有“#”标记，如/#/home
* hash模式兼容性更好
* hashChange事件：当hash发生变化时，会触发hashChange事件，Vue Router就是利用这个事件来监听路由的变化，然后匹配路由规则，切换视图；
* 在页面加载时，Vue Router会通过hashChange事件监听hash的变化，所以初始的路由信息是通过hash来判断的；
* URL的hash部分不会包含在HTTP请求中，所以hash模式下的URL变化不会重新加载页面。

2. History模式实现原理：History模式利用history.pushState API来完成URL的跳转而无须重新加载页面。

* URL中没有“#”标记，如/home
* history模式需要服务器配置
* History.pushState API: pushState不会触发页面刷新，只会在浏览器历史记录里增加一个历史记录；
* popState事件，当用户点击浏览器后退时，会触发popState事件，这个时候我们就可以根据历史记录中的状态来还原视图；
* Vue Router在初始化时，会通过history.replaceState来记录当前的路由状态，以供后续的popState事件使用；
* 对于URL的变更，我们还需要在服务端增加一个覆盖所有情况的候选资源，如果URL匹配不到任何静态资源，则应该返回一个index.html页面，就是我们app依赖的页面。

3. Vue Router有哪些导航钩子：

* beforeEach：跳转开始前被调用；
* beforeResolve：在组件内部调用next之前；
* afterEach：跳转结束之后调用；
* beforeLeave：导航离开该组件的对应路由时调用。

4. Vue Router的嵌套路由是什么

```js
const routes = [
  {
    path: '/parent', 
    component: Parent,
    children: [
      {
        path: 'child1',
        component: Child1
      }
    ]
  }
]
<!-- Parent.vue -->
<router-view></router-view>

<!-- Child1.vue -->
// 子路由视图
```

### Vuex

1. 是什么？VueX是一个专为Vue应用程序开发的状态管理器，采用集中存储管理应用的所有组件的状态。每一个vuex应用的核心就是store(仓库)。“store”基本就是一个容器，它包含着应用中大部分的状态(state)。
2. 为什么用？由于组件只维护自身的状态(data)，组件创建时或者路由切换时，组件会被初始化，从而导致data也会被随之销毁，需要借用Vuex存储状态。
3. 怎么用？在main.js引入store，注入，只用来读取的状态集中放在store中，同步改变状态的方式是提交mutations，异步改变状态的方式封装在actions。
4. 什么场景使用？小型应用没必要使用，直接使用props和emits传递即可，大型复杂应用需要使用vuex，应用在状态登录、加入购物车、音乐播放等实现。

### v-if与v-show的区别

v-if和v-show都是动态显示DOM元素的语法糖，其区别是：

|          | v-if                                                         | v-show                                        |
| -------- | ------------------------------------------------------------ | --------------------------------------------- |
| 实现原理 | 动态向DOM树内添加或者删除DOM元素                             | 设置DOM元素的display样式控制显隐              |
| 编译过程 | 切换的时候有鬼局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件 | 只是简单CSS样式的切换                         |
| 编译条件 | 多醒的，如果条件为假，则什么也不做，只有第一次条件为真才会局部编译 | 条件真假都会被编译，然后缓存，DOM元数据被保留 |
| 性能消耗 | 更高的切换消耗                                               | 更高的出事渲染消耗                            |
| 适合场景 | 适合条件不太可能发生改变场景                                 | 适合频繁切换的场景                            |

### 如何让CSS值在当前的组件中起作用

在Vue文件中的style标签上，有一个特殊的属性：scoped。当一个style标签拥有scoped属性时，它的CSS样式就只能作用于当前的组件，也就是说，该样式只能适用于当前组件元素。通过该属性，可以使得组件之间的样式不互相污染，如果一个项目中的所有style标签全部加上了scoped，相当于实现了样式的模块化。Vue中scoped属性的效果主要是通过PostCSS转译实现的。PostCSS给一个组件中的所有DOM添加了一个独一无二的动态属性，然后，给CSS选择器额外添加一个对应的属性选择器来选择该组件中DOM，这种做法使得样式只作用于含有该属性的DOM，即组件内部DOM。

```css
// 转译前
<template>
  <div class="example">hi</div>
</template>
<style scoped>
.example {
  color: red;
}
</style>
// 转译后
<template>
  <div class="example" data-v-5558831a>hi</div>
</template>
<style>
.example[data-v-5558831a] {
  color: red;
}
</style>
```

### keep-alive相关

1. keep-alive的实现原理

   keep-alive组件是vue的内置组件，用于缓存内部组件实例。这样做的目的在于，keep-alive内部的组件切回时，不用重新创建组件实例，而直接使用缓存中的实例，一方面能够避免创建组件带来的开销，另一方面也可以保留组件的状态。

2. 与keep-alive相关的生命周期函数是什么，什么场景下会进行使用

   keep-alive内部所有嵌套的组件都具有两个生命周期钩子函数，分别是activated和deactivated，它们分别在组件激活时和失活时触发。第一次activated是在触发mounted之后。

3. keep-alive的常用属性有哪些

   keep-alive具有include和exclude属性，通过它们可以控制哪些组件进入缓存。另外它还提供了一个max属性，通过它可以设置最大缓存数，当缓存的实例超过该数时，vue会移除最久没有使用的组件缓存。

### Vue中如何进行组件的使用和全局注册

1. Vue2中，首先需要用import引入组件，然后再在components属性注册组件，之后就可以在模板中使用组件了。
2. 可以使用Vue.component方法来实现全局组件的注册。

### Vue-cli相关

构建vue-cli工程都用到了：

1. vue.js：主要特点是数据双向绑定和组件系统；
2. vue-router：vue官方推荐使用的路由框架；
3. vuex：转为vue.js应用项目开发的状态管理器，主要用于维护vue组件间共用的一些变量和方法；
4. axios（或者fetch、ajax）：用于发起HTTP请求，基于Promise设计；
5. webpack：模块加载和vue-cli工程打包器；
6. eslint：代码规范工具。

### nextTick的作用和实现原理

1. 作用：Vue更新DOM是异步更新的，数据变化，DOM的更新不会马上完成，nextTick的回调是在下次DOM更新循环结束之后执行的延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM；
2. 工作原理：
   * 在修改数据之后，Vue会开启一个队列，并缓冲在同一事件循环中发生的所有数据改变；
   * 如果同一个watcher被多次触发，只会被推入到队列中一次；
   * 这种在缓冲时去除重复数据对于不必要的计算和DOM操作上非常重要；
   * 在下次的事件循环“tick”中，Vue刷新队列并执行实际(已去重的)工作；
   * Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MessageChannel,如果执行环境不支持,会采用 setTimeout(fn, 0) 代替；
   * 所以 nextTick() 回调会在 DOM 更新完成后执行,并且是在下一个事件循环中。

### Vue的data为什么必须是函数

组件中的data写成一个函数，数据以函数返回值形式定义。这样每复用一次组件，就会返回一份新的data，类似于给每个组件实例创建一个私有的数据空间，让每个组件实例维护各自的数据。而单纯的写成对象，就使得所有组件实例共用了一份data，就会造成一个变了全都会变的结果。

### Vue的computed实现原理

1. computed的实现原理

当组件实例触发生命周期函数beforeCreate后，它会遍历computed配置中的所有属性，为每一个属性创建一个Watcher对象，并传入一个函数，该函数的本质就是computed配置中的getter，这样一来，getter运行过程中会收集依赖，但是和渲染函数不同，为计算属性创建的Watcher不会立即执行，因为要考虑到该计算属性是否会被渲染函数用，如果没有使用，就不会得到执行。因此，在创建Watcher的时候，它使用了lazy配置，lazy配置可以让Watcher不会立即执行。收到lazy的影响，Watcher内部会保存两个关键属性来实现缓存，一个是value，一个是dirty，value属性用于保存Watcher运行的结果，受lazy的影响，该值在最开始是undefined，dirty属性用于指示当前的value是否已经过时了，即是否为脏值，受lazy的影响，该值在最开始是true。当计算属性的依赖变化时，会触发计算属性的Watcher执行，此时，它只需设置dirty为true即可，不做任何处理。由于依赖同时会收集到组件的Watcher，因此组件会重新渲染，而重新渲染时又读取到了计算属性，由于计算属性目前已为dirty值true，因此会重新运行getter进行运算。而对于计算属性的setter，则极其简单，当设置计算属性时，直接运行setter即可。

2. computed的缓存原理

computed本质是一个惰性的观察者，当计算数据存在于data或者props里时会被警告。vue初次运行会对computed属性做初始化处理(initComputed)，初始化的时候会对每一个computed属性用watcher包装起来，这里面会生成一个dirty属性值为true；然后执行defineComputed函数来计算，计算之后将dirty值变为false，这里会根据dirty值来判断是否需要重新计算，如果属性依赖的数据发生变化，computed的watcher会把dirty变为true，这样就会重新计算computed属性的值。

### Vue complier的实现原理

compiler的主要作用是解析模板，生成渲染模板的render，而render的作用主要是为了生成VNode compiler，compiler主要分为3部分：

1. parse：接受template原始模板，按着模板的节点和数据生成ast；
2. optimize：遍历ast的每一个节点，标记静态节点，这样就知道哪部分不会变化，于是在页面需要更新时，通过diff减少去对比这部分DOM，提升性能；
3. generate：把前两步生成的ast，组成render字符串，然后将render字符串通过new Function的方式转换成渲染函数。

### Vue如何快速定位那个组件出现性能问题

用timeline工具，通过timeline工具来查看每个函数的调用时长，定位出哪个函数的问题，从而能判断哪个组件出了问题。

### watch与computed的区别及使用场景

watch和computed都是观察数据变化的，区别如下：

|          | watch                                                        | computed                                                     |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 监听范围 | 监听data、props里面数据的变化                                | 计算属性会混入到vue的实例中，需要监听自定义变量              |
| 缓存     | 没有缓存                                                     | 有缓存，依赖的值变了才会重新计算                             |
| 异步支持 | 支持异步                                                     | 不支持异步                                                   |
| 监听操作 | 一对多，监听某一个值变化，执行多个操作                       | 一或多对一，依赖一个或多个属性，计算出一个值                 |
| 函数形式 | 两个入参参数，oldVal，newVal                                 | computed是函数时，都有get/set方法，默认走get方法，get必须有返回值(watch)的参数 |
|          | watch的参数，deep深度监听，immediate组件加载立即触发回调函数 |                                                              |

### scoped属性是如何实现样式穿透的

1. 为什么需要scoped样式穿透，引用第三方组件，需要在局部修改第三方组件的样式，不想去除scoped属性造成组件之间的样式污染，只能透过特殊的方式，穿透scoped，来实现样式穿透。
2. 使用`/deep/`或`::v-deep`选择器穿透

```vue
// .a选择器作用于当前组件，但.b选择器会对子组件生效，也就样式穿透到了子组件
<style scoped>
.a /deep/ .b {
  /* ... */
}
</style>
// 作用于/deep/一致，但是由vue提供的语法糖
<style scoped>
.a ::v-deep .b {
  /* 样式 */
}
</style>
```

3. 使用不带scoped样式穿透，易造成组件污染，不推荐

```vue
// 定义两个style标签，一个全局的，一个作用域为本组件的，将穿透样式写在全局标签中即可
<style>
/* global styles */
</style>

<style scoped>
/* local styles */
</style>
```

### Vue与Angular以及React的区别

Vue、Angular和React都是目前非常流行的前端框架，但它们在概念和用法上有一定的区别：

|          | Vue                                            | React                                                        | Angular                                                      |
| -------- | ---------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 响应式   | 基于数据驱动和组件，具有响应式和组合的视图组件 | 也是数据驱动和基于组件的，但并不是响应式的，仅在状态改变时重新渲染组件 | 结合了响应式和非响应式，组件级别是响应式的，非组件级别是非响应式的 |
| 组件化   | 视图和控制器相对简单，易学易用                 | JSX使组件化更加灵活，复杂组件更易构建，更难掌握              | 强大的组件系统，打包了各种功能，难度和学习曲线较大           |
| 模板/JSX | 使用模板语法，简单易学                         | 使用JSX，更加灵活强大，有一定学习成本                        | 也使用模板语法，但复杂度较大                                 |
| 状态管理 | 内置vuex状态管理工具                           | 使用Redux等外部状态管理库                                    | 状态管理复杂，难度较大                                       |
| 基础知识 | 只需掌握HTML、CSS和JS基础                      | 需要掌握HTML、CSS、JS和JSX                                   | 需要掌握HTML、CSS、JS、TypeScript以及Angular的各种概念和用法 |
| 总结     | 易学易用，更适合快速开发项目                   | 灵活高效，更适合大型项目                                     | 功能强大完备，企业级开发首选，但学习成本高                   |

## webpack和vite

### 为什么要使用webpack和vite等构建工具

1. 解决开发与生产之间的矛盾，开发需要使用模块化的代码，提高代码的可读性、可维护性，故会使用一些新语法和框架写法(ts、vue、es6)等；但是在生产环境中，浏览器无法自身解析模块化代码，只认识js，甚至有的老的浏览器对ES6的语法支持都不完善。
2. 通过构建工具(比如webpack、vite)可以解决这个矛盾，使得开发使用的模块化代码(import进来的)和新框架(ts\vue\ES6)等特殊写法，能够被浏览器识别

### webpack和vite等构建工具具体做了什么

1. 编译浏览器无法理解的ES6代码、TS代码、VUE框架代码打包成一个文件，可以让浏览器能够识别；
2. 其中转换ES6、TS、VUE代码则需要利用webpack和vite的插件和Loader来完成；
3. webpack也可以代替一些人工操作，比如文件合并和拆分、图片压缩、资源的处理；
4. webpack的开发模式可以帮助开发。

### 构建工具有哪些

1. wepack，版本3以及3以下，版本4以及4以上
2. rollup
3. vite

### webpack配置

webpack的配置一般都放在项目根目录的`webpack.config.js`文件中，所以webpack的配置主要针对于该文件编写

```js
//webpack是在node环境中运行的组件，所以一定要采取common.js写法，即module.exports{}
//一定不要使用ES6写法，即import, export default, 这样在webpack执行的过程中，会报错
//webpack配置项概览
entry: //必填项，配置入口，以哪个文件为开始
output: //必填项，配置出口，最终产出js配置
mode: //必填项，配置模式，webpack4之后添加
devServer: //非必填项，开发模式配置
module: //非必填项，配置解析和转换文件的策略，loader编写的地方，babel-loader\tsx-loader\css-loader\file-loader\url-loader
plugins: //非必填项，插件相关
optimization: //非必填项，配置优化策略，如代码分割等
resolve: //非必填项，配置解析策略，提供一些简化功能，别名等
sourcemap: //非必填项，配置devtool
performance: //非必填项，配置性能策略
```

### rollup配置

1. rollup相较于webpack，不会生成过多的运行代码，可以多模块化规范打包，但是插件功能相对于webpack来说少了很多，比如js处理、CSS、图片处理等功能有欠缺。
2. rollup核心配置一般都放在项目根目录的`rollup.config.js`文件

```js
const resolve = require("@rollup/plugin-node-resolve") //引入第三方库的插件
const terser = require("@rollup/plugin-terser") //压缩插件
module.exports={
	input: "./app.js", //入口，必须
	output: { //出口，必须
    dir: "./dist", //输出目录,与file不可同时出现
		//file: "./dist/bundle.js", //与dir不可同时出现
		format: "cjs", //必须，输出的模块化方式，es(ES6)，cjs(commonJS)，umd，amd，iife
		},
	external: ["lodash-es"], //不打包入bundle的文件，如不将lodash-es模块打包入bundle.js
	plugins: [resolve(), terser()], //插件，引入resolve和terser两个插件
}
```

### vite配置

1. vite利用ESM，让代码不像传统的构建工具一样去分析引入，打包构建，而是直接保持模块化，省去了大量编译时间，让代码更改后的响应速度大量提升，vite构建底层使用的是rollup，vite天生支持CSS以及预处理语言模块，不需要引入更多的loader，vite也支持typescript，vite也可以处理各种资源。
2. vite核心配置一般都放在项目根目录的`vite.config.js`文件

```js
import { defineConfig } from "vite" // 从vite引入defineConfig方法
import vue from "@vitejs/plugin-vue" // 从vitejs引入plugin-vue插件帮助vite解析vue文件
export default defineConfig({ //将引入的defineConfig对象export出去，就完成vite配置基本架构
  //root:"/", //设置根目录,默认就是/
  base:"www.xxx.com", //相当于webpack的publicPath
  //publicDir: "./static", //静态资源访问目录
  esbuild: { //引入.jsx文件支持
    jsxFactory:"h",
    jsxFragment:"Fragment",
    jsxInject: "import {h} from 'vue'"
  },
  resolve: {
    extensions: [".js", ".ts", ".css"], //路径省略
    alias: { //别名配置
      "@": __ + "/src"
    }
  },
  build: { //打包配置 --build模式
    rollupOptions: { //此处同rollup的配置，因为vite底层使用的rollup打包
      input: "./index.build.html", //入口，入口文件的设置
      output:{ //出口，打包文件的命名
        entryFileNames: "bundle.js", // 打包bundle的命名
        chunkFileNames: "[name].chunks.js" // 代码分割的命名
      },
   /* manualChunks: { //指定vue代码分割
        vendor: ["vue"]
      },*/
      manualChunks: (id) => { //可以用代码方式进行代码分割
        if (id.includes('node_modules')) {
          return "vendor"
        }
      }
    },
    //与rollup无关的主要是base64，css过大转变等功能
    assetInlineLimit: 20000, //超过该尺寸的图片会转换成base64放入bundle.js中
  }, 
  server: { //开发模式配置 --dev模式
    port: 2000, //端口
    proxy: { //代理转发
      "/api": {
        target: "www.xxx.com",
        rewrite: (path) => {
          return path.replace(/^\/api/, "xxx")
        }
      }
    },
    headers: {
      
    }
  },
  plugins:[
    vue() //引入.vue文件支持
  ],
})
```



## 性能优化

### 代码优化

1. 缓存DOM查询结果
2. 合理使用事件代理
3. 避免重绘重排
4. 优化CSS选择器
5. 减少HTTP请求
6. 图片懒加载

### 资源优化

1. 最小化JS/CSS/HTML
2. 图片压缩
3. CDN加速
4. 资源并发加载
5. 利用浏览器缓存
6. 预渲染

### 缓存优化

1. 数据缓存
2. 服务端缓存
3. CDN缓存
4. 浏览器缓存

### 性能监控与处理

1. 首屏时间
2. 白屏时间
3. FPS
4. JS堆内存使用
5. 网络请求
6. 接口时间分布
7. 设备/浏览器性能

### 项目构建方面

1. 压缩代码文件

   在 webpack 中使用`terser-webpack-plugin`压缩Javascript代码；使用 `css-minimizer-webpack-plugin` 压缩CSS代码；使用 `html-webpack-plugin`压缩html代码。

2. 开启gzip压缩

   webpack 中使用 `compression-webpack-plugin` ，node作为服务器也要开启，使用`compression`。

3. 常见的第三方库使用CDN服务，在webpack中我们要配置externals，将比如React，Vue这种包不打倒最终生成的文件中，而是采用CDN服务。

## H5移动端尺寸适配

我们在做H5移动端开发时，用到最多的单位是PX，也就是CSS像素，当页面缩放比为1:1时，一个CSS像素等于一个设备独立像素。但CSS像素是很容易被改变的，比如用户对页面进行放大，CSS像素会被放大，此时的CSS像素会跨越更多的设备像素。

其中，页面缩放系数 = CSS像素/设备独立像素

1. rem适配

利用阿里flexible开源方案，在入口的index.html文件设置一下响应式rem方案

```html
<!-- // index.html 设置-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>Document</title>
    <style>
        *{margin:0;padding:0}
        .box{
            width: 10rem;
            height: 4rem;
            background-color: antiquewhite;
            font-size: 0.53rem; /* 20px*/
        }
    </style>
    <script>
        function setRootRem() {
            const root = document.documentElement;
            /** 我们项目里一般设定 1rem = 100px，37.5px
             * 以iPhone6为例：布局视口为375px，我们把它分成10份，则1rem = 37.5px，
             * 这时UI给定一个元素的宽为375px（设备独立像素），
             * 我们只需要将它设置为375 / 37.5 = 10rem。
            */
            const scale = root.clientWidth / 10
            root.style.fontSize = scale + 'px'  
        }
        setRootRem()
      	//添加监听，监听浏览器页面发生变化，就重新设置一下rem
        resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize',
        window.addEventListener(resizeEvt, setRootRem) 
    </script>
</head>
<body>
    <div class="box">REM适配</div>
</body>
</html>

```

但是，团队中不是所有人都了解这个设置，需要我们在用webpack打包的过程中，引入插件，将一些不符合规定的px值转换成rem值，以消除差异。

```

```

2. vw、vh适配

`vw（Viewport Width）`、`vh(Viewport Height)`是基于视图窗口的单位，是css3中提出来的，基于视图窗口的单位。`vh、vw`方案即将视觉视口宽度 `window.innerWidth`和视觉视口高度 `window.innerHeight` 等分为 100 份。如果按视觉视口为`375px`，那么`1vw = 3.75px`，这时`UI`给定一个元素的宽为`75px`（设备独立像素），我们只需要将它设置为`75 / 3.75 = 20vw`。此时，可以利用css预处理语言来计算，不用自己手动计算，所得过程完全交给css预处理语言。

```less
// 还是rem.less 我们加一个@vw变量
@device-width: 375;
@rem: (@device-width/10rem);
@vw: (100vw/@device-width);
```

```vue
<template>
    <div class="songyao">
        <h1>{{ username }}</h1>
    <p>
      了解脚手架及脚手架指令请移步个人博客<br>
      check out the
      <a href="http://47.100.126.169/zmengBlog" target="_blank" rel="noopener">逐梦博客</a>.
    </p>
    <p>微信公众号：<span class="wx_name">前端南玖</span></p>
    </div>
</template>
<script>
export default {
    name: 'songyao',
    data() {
        return {
            username: 'songyao-cli(vue 模板)'
        }
    },
}
</script>
<style lang="less">
.songyao{
    h1{
        // font-size: (24/@rem);
        font-size: 24*@vw;
    }
    p{
        // font-size: (16/@rem);
        font-size: 16*@vw;
    }
   .wx_name{
    color:brown;
    }
}
</style>
```

3. viewport+px适配

viewport方案让我们在开发时不用关注设备屏幕尺寸的差异，直接按照设计稿上的标注进行开发，也无需单位的换算，直接使用px。

在HTML的head标签里加入 <meta name="viewport" content="width={设计稿宽度}, initial-scale={屏幕逻辑像素宽度/设计稿宽度}" > 。

假如UI给我们提供的设计稿宽度时375px，我们则需要将页面的viewport的width设为375，然后再根据设备的逻辑像素将页面进行整体放缩。

```js
export function initViewport() {
    const width = 375;  // 设计稿宽度
    const scale = window.innerWidth / width
    // console.log('scale', scale)
    let meta = document.querySelector('meta[name=viewport]')
    let content = `width=${width}, init-scale=${scale}, user-scalable=no`
    if(!meta) {
        meta = document.createElement('meta')
        meta.setAttribute('name', 'viewport')
        document.head.appendChild(meta)
    }
    meta.setAttribute('content', content)
}
```

```vue
<template>
    <div class="songyao">
        <h1 class="name_rem">{{ username }}</h1>
        <h1 class="name_vw">{{ username }}</h1>
        <h1 class="name_px">{{ username }}</h1>
    <p>
      了解脚手架及脚手架指令请移步个人博客<br>
      check out the
      <a href="http://47.100.126.169/zmengBlog" target="_blank" rel="noopener">逐梦博客</a>.
    </p>
    <p>微信公众号：<span class="wx_name">前端南玖</span></p>
    </div>
</template>
<script>
export default {
    name: 'songyao',
    data() {
        return {
            username: 'songyao-cli(vue 模板)'
        }
    },
}
</script>
<style lang="less">
.songyao{
    p{
        // font-size: (16/@rem);
        font-size: 16*@vw;
    }
    .name_rem{
        font-size: (24/@rem);
    }
    .name_vw{
        font-size: 24*@vw;
    }
    .name_px{
        font-size: 24px;
    }
   .wx_name{
    color:brown;
    }
}
</style>
```

4. 总结

* rem：适配原理复杂、需要使用js适配，设计稿标注的px换算到css的rem计算简单，方案灵活，既能实现整体缩放，又能实现局部不缩放；
* vw：适配原理简单，不需要js即可适配，设计稿标注的px换算到css的vw计算复杂，方案灵活，既能实现整体缩放，又能实现局部不缩放；
* viewport+px：适配原理简单，需要使用js适配，直接使用设计稿标注无需换算，方案死板，

## 原生和H5的APP混合开发

1. 原生Native + JSSDK + H5的开发模式：

* Native不但负责APP基础架构和APP能力输出，提供封装好的webview容器，webview容器是基于腾讯TBS的定制开发，含有JSBridge的双向通信方法JSSDK；

* JSSDK作为H5和原生Native间的桥梁，提供双向通信通道，使双方可以相互调用；

* H5分为两部分用于实现业务，业务上称为一级H5和二级H5，形式上称为内嵌H5(APP本地内置，无需网络也可以加载，稳定)和线上H5(CDN地址，利用缓存策略，第一次加载比较慢，之后响应比较及时)。

2. 为什么使用这种Hybrid的APP开发模式，而不是选择Cordova、React Native、Flutter、Weex、Uniapp的混合开发模式？

答： 技术选型不但需要考虑技术先进性、业务符合性、项目可维护性等，还需要考虑企业现状及公司成本问题。目前来看，当时最想选择的Flutter和原生+H5混合开发是目前最适合我们公司的，但是Flutter对于当时公司技术人员的学习曲线较陡峭，市面上的会Dart和Flutter的开发人员也较少，不利于未来公司成本控制和项目维护。而原生+H5混合开发仅需少量原生开发人员和大量H5开发人员分别独自进行开发，他们之间的差别由自研的JSSDK方法抹平，这样就能应对业务的需求，而原生开发和H5开发市面上存在不少这样的技术人员，对于成本和未来项目维护也是优选。而对于编程语言的熟练度，后端、前端、移动端原生开发经过短暂训练也可迅速进入APP开发。React Native虽然当时也比较流行，但是使用React Native的开发，需要开发人员熟练掌握RN，并对安卓和iOS开发有所了解，对于现有人员的学习曲线比较陡峭，每一位都需要了解三者，虽然现有人员可以满足这样的要求，但是Java、JS、OC的培养成本比较大，未来招人成本也较大。Cordova和Weex曾经推出一时无两，现在也渐渐偃旗息鼓，并且很难达到100%原生应用的性能，而一些原生插件需要原生开发人员负责开发。

3. JSSDK提供能力的一览，JSSDK的原理基于JS和原生通信通道JSBridge，JSSDK的名称也借鉴自微信JSSDK，我们当时开发目标也是尽可能接近微信JSSDK的效果，但是由于微信JSSDK的内部机制把控的比较严格，我们只能形似而不能神似，之后又借鉴uniapp的api设计，最终使我们的JSSDK能力成型，一览如下：

* 基础部分：appPause(onPause)、appResume(onResume)、pageIn(进入页面)、pageOut(离开页面)、pageBack(返回页面)、pageError(页面加载错误，更新时间戳)、startSystemBrowser(打开系统浏览器)、startBhfaeBrowser(打开bhfae浏览器)、bhfaeBrowserReplace(打开bhfae浏览器，并关闭之前的浏览器)、setNavigationDisplayMode(设置bhfae的浏览器展示模式，全屏、浏览器)、webviewGoBack(返回上次页面)、backToRoot(返回一级页面)，testMethods(检测原生是否支持该方法)；
* 网络部分：nativeRequest(普通网络请求)、downloadFile(下载视频/文件)、uploadImage(上传图片)、uploadVideo(上传视频)；
* 数据缓存：nativeSetSessionStorage(临时存储-存)、nativeGetSessionStor(临时存储-取)、nativeDeleteSessionStorage(临时存储-删)、nativeSetLocalStorage(长期存储-存)、nativeGetLocalStorage(长期存储-取)、nativeDeleteStorage(长期存储-删)；
* 位置部分：getIpAddress(获取IP地址)、getLocation(获取位置经纬度)；
* 媒体部分：chooseImage(选择图片)、previewImage(预览图片)、saveImage(保存图片)、getLocalImageData(根据图片ID获取本地图片的base64)、startAudioAction(开始语音转义)、stopAudioAction(停止语音转义)、palyAudioAction(播放语音转义)；
* 设备部分：getNativeInfo(获取通用信息)、getDeviceInfo(获取设备信息)、getNetworkType(获取网络类型)、phoneCall(拨打电话)、setScreenShotDisable(设置页面截屏)、shortVibrate(短震动)；
* 其他：视频客服TRTC、打开第三方app、微信相关、埋点相关。

4. 原生app的keystore也就是打包秘钥为什么要两种，dev和pro？需要两个包名，使开发/测试和生产环境完全隔离，让一些业务如OCR识别、push推送的测试环境数据永远不污染生产环境，怎么保存keystore，开发keystore必须每个开发人员都持有，而生产用keystore置于打包jenkins服务器，通过jenkins构建流程自动化构建生产包，这样keystore的秘钥只有app负责人才可以解除，保持安全，并且使用-P password在控制台打印的秘钥也会是***。
5. 安卓端使用TBSwebview内核抹平不同安卓厂商webview的显示盒使用差异，安卓端的提供给H5使用的webview是基于TBSwebview的定制开发，但是TBS初始化时，会异步加载一个很大的包，这样会导致第一次启动app体验感不行，这里会有一个判断逻辑，如果第一次启动就是用系统webview加载H5，而再次启动APP，如果TBS初始化成功则会使用基于TBS定制的webview。
6. 为了避免一级页面，也就是APP内置H5初次加载白屏体验不佳，在APP初始化过程中就预加载H5内置页面，这样app启动就会展示app一级页面，而二级页面由于是线上的链接，初次加载一定会有加载时间，这需要与后端商讨缓存策略，我们在试验下还是使用TBSwebview的默认缓存策略，而二级H5页面的组件尽量使用keepalive缓存住，避免需要频繁加载页面，造成体验不佳。

## 保险MGA项目简介

1. MGA，即管理型总代理(Managing General Agent)，MGA模式指保险专业代理机构在保险销售的基本功能之外，可以接受保险公司委托从事市场营销、收取保费、核保、理赔、风险管理、产品开发、精算定价、协助安排再保险等业务，原则上，保险公司不把承保风险转移给MGA，MGA不管理投保人资金，其余业务环节都可以MGA来承担。
2. MGA系统构成：

* 核心业务系统：传统保险公司模式的业务系统，具有全面的保险业务功能，主要用于维护保险公司、配置自营产品功能，而销售人员信息、保单数据、结算数据均有电商系统同步过来；
* 电商展业后台：电商展业后台是整个系统的枢纽，具有产品管理、人员管理、订单管理、结算管理、业务统计、渠道考核等功能；
* 下游机构管理后台：下游机构有两种模式，持牌机构(大B)和非持牌机构(小B)，具有配置产品权限、管理人员、查询订单、结算佣金等功能；
* A端公众号：面向代理人(ToA)，提供代理人分享投保链接给客户购买，代理人可查看自己销售出去的订单；
* C端公众号：面向客户(ToC)，客户可直接购买在线产品，也可查看自己名下保单。
